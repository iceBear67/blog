<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>「9+」 Java 编译器插件教程 101 - nstd::out</title><link rel="manifest" href="../../../../manifest.json"><meta name="application-name" content="nstd::out"><meta name="msapplication-TileImage" content="/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="nstd::out"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="写了上万行 Java 代码，相比你已经对 Java “木纳呆板”的语法恨之入骨了。   那么，有没有一种可能，我是说可能，我们可以给 Java 编译器写插件？"><meta property="og:type" content="blog"><meta property="og:title" content="「9+」 Java 编译器插件教程 101"><meta property="og:url" content="https://blog.0w0.ing/2022/07/06/Extending-Java-Compiler/"><meta property="og:site_name" content="nstd::out"><meta property="og:description" content="写了上万行 Java 代码，相比你已经对 Java “木纳呆板”的语法恨之入骨了。   那么，有没有一种可能，我是说可能，我们可以给 Java 编译器写插件？"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.0w0.ing/cover-compiler-plugin.png"><meta property="article:published_time" content="2022-07-06T11:25:58.000Z"><meta property="article:modified_time" content="2023-01-16T03:07:03.661Z"><meta property="article:author" content="iceBear67"><meta property="article:tag" content="compiler"><meta property="article:tag" content="tech"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://blog.0w0.ing/cover-compiler-plugin.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.0w0.ing/2022/07/06/Extending-Java-Compiler/"},"headline":"「9+」 Java 编译器插件教程 101","image":["https://blog.0w0.ing/cover-compiler-plugin.png"],"datePublished":"2022-07-06T11:25:58.000Z","dateModified":"2023-01-16T03:07:03.661Z","author":{"@type":"Person","name":"iceBear67"},"publisher":{"@type":"Organization","name":"nstd::out","logo":{"@type":"ImageObject","url":"https://blog.0w0.ing/sitelogo.png"}},"description":"写了上万行 Java 代码，相比你已经对 Java “木纳呆板”的语法恨之入骨了。   那么，有没有一种可能，我是说可能，我们可以给 Java 编译器写插件？"}</script><link rel="canonical" href="https://blog.0w0.ing/2022/07/06/Extending-Java-Compiler/"><link rel="alternate" href="../../../../atom.xml" title="nstd::out" type="application/atom+xml"><link rel="icon" href="../../../../favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/idea.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="../../../../css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer="defer"></script><!--!--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="follow.it-verification-code" content="Ma2d4UPTxWm9UELy5eqP"><link rel="stylesheet" href="https://blog.0w0.ing/styles/admonition.css"><script>!function(){function e(){var e,t,a;location.hash&&(e="#"+CSS.escape(location.hash.substring(1)),t=document.querySelector(`.tabs a[href="${e}"]`))&&(a=t.parentElement.parentElement,Array.from(a.children).forEach(e=>e.classList.remove("is-active")),Array.from(a.querySelectorAll("a")).map(e=>document.getElementById(e.getAttribute("href").substring(1))).forEach(e=>e.classList.add("is-hidden")),t&&t.parentElement.classList.add("is-active"),a=document.querySelector(e))&&a.classList.remove("is-hidden")}e(),window.addEventListener("hashchange",e,!1)}()</script><meta name="generator" content="Hexo 7.0.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="../../../../index.html"><img src="../../../../sitelogo.png" alt="nstd::out" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="../../../../index.html">主页</a><a class="navbar-item" href="../../../../archives">归档</a><a class="navbar-item" href="../../../../categories">分类</a><a class="navbar-item" href="../../../../links">友链</a><a class="navbar-item" href="../../../../%E7%A9%BA%E8%B0%83%E6%88%BF">空调房</a><a class="navbar-item" href="../../../../about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="../../../../cover-compiler-plugin.png" alt="「9+」 Java 编译器插件教程 101"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2022-07-06T11:25:58.000Z" title="2022/7/6 19:25:58">2022-07-06</time>发表</span><span class="level-item"><time datetime="2023-01-16T03:07:03.661Z" title="2023/1/16 11:07:03">2023-01-16</time>更新</span><span class="level-item"><a class="link-muted" href="../../../../categories/%E8%AE%B0%E4%BA%8B/">记事</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="../../../../categories/%E6%95%99%E7%A8%8B/">教程</a></span><span class="level-item">36 分钟读完 (大约5416个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">「9+」 Java 编译器插件教程 101</h1><div class="content"><p>写了上万行 Java 代码，相比你已经对 Java “木纳呆板”的语法恨之入骨了。</p><p>那么，有没有一种可能，我是说可能，我们可以给 Java 编译器写插件？</p><span id="more"></span><p>如果你要在面包店里买面包，你最好跟店员说你要买哪块面包。本文所指的 <code>Java 编译器</code> 均为 OpenJDK 自带的那个 <code>javac</code>，而不是其他的前端编译器实现。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自从 Java 8 起，Oracle 就将<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Plugin.html">插件</a>系统引入了 <code>javac</code> 中，因此是可以写 Javac 插件的。</p><p>虽然写一个 Javac 插件并且修改代码是可能的，但是这方面的资料很少（国内就更少了），并且大多内容重复（教你写个 HelloWorld 然后就结束），其次 javac 的东西也不是很好摸，毕竟不是公开 API（ JDK 9+ 开始已经不暴露在外了）。</p><p>恰逢今年还没写技术类的博客，就拿来磨磨刀吧。</p><h1 id="先从插件说起"><a href="#先从插件说起" class="headerlink" title="先从插件说起"></a>先从插件说起</h1><p>上文刚刚提到了一个词，<code>插件</code>。它其实正是 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Plugin.html">com.sun.source.util.Plugin</a>。通过这个类，我们可以让 Javac 在编译时加载我们的代码。</p><p>加载了代码，那么做什么呢？所以我们立一个目标：<em>给所有 <code>@Jsonized</code> 标注过的类都生成一个可以输出 json 的 <code>toString()</code> 方法。</em></p><p>什么意思呢？就比如说这样一个类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyResponse</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> success;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyResponse</span><span class="params">(String message, <span class="type">boolean</span> success)</span>{</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        <span class="built_in">this</span>.success = success;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后你想把它序列化成 Json。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyResponse</span>(<span class="string">"\"Success!\" Took me 114514 yr 1919810 m"</span>,<span class="literal">false</span>).toString();</span><br><span class="line">response.equals(<span class="string">"""</span></span><br><span class="line"><span class="string">    {"message": "\"Success!\" Took me 114514 yr 1919810 m", "success": false}</span></span><br><span class="line"><span class="string">"""</span>);</span><br></pre></td></tr></tbody></table></figure><p>又快又便捷，还不需要第三方类库，这就是我们的目标。</p><p>那么先把这个注解写出来吧！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.inlambda.kiwi.magic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Classes with this type can be serialized to json by their {<span class="doctag">@link</span> #toString()} method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Jsonized {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>值得提一点就是这些编译器注解的 <code>Retention</code> 用 <code>RetentionPolicy.SOURCE</code> 也是可以的，但是以后可能运行期间我们需要识别到这些被修改过的类，所以设置为 <code>RUNTIME</code>。</p><p>接着是，实现 Javac 的 <code>Plugin</code> 接口！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.inlambda.kiwi.magic.plugin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.source.util.Plugin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KiwiJavacPlugin</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Kiwi"</span>; <span class="comment">// 插件的名字</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(JavacTask task, String... args)</span> { <span class="comment">// 插件初始化回调</span></span><br><span class="line">        System.out.println(<span class="string">"Hello Kiwi"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是它不让你过编译。</p><h2 id="打通模块的穴位"><a href="#打通模块的穴位" class="headerlink" title="打通模块的穴位"></a>打通模块的穴位</h2><p>这怎么能忍！在默认包目录下创建一个 <code>module-info.java</code>。</p><p><img src="https://i.ibb.co/JH5k9PV/image.png" alt="Package Layout"></p><p>然后我们写点东西进去。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> kiwi.magic.main { <span class="comment">// module 后跟模块名，下文要用</span></span><br><span class="line">    <span class="keyword">requires</span> jdk.internal.vm.compiler;</span><br><span class="line">    <span class="keyword">requires</span> jdk.compiler;</span><br><span class="line">    <span class="keyword">requires</span> java.naming;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>加入这些之后，还要配置一下构建工具的编译参数。</p><p>（本教程使用 Gradle, Maven/SBT 用户请自行摸索….）</p><figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">compileJava {</span><br><span class="line">    options.compilerArgs &lt;&lt; <span class="string">"--add-exports=jdk.compiler/com.sun.tools.javac.tree=kiwi.magic.main"</span></span><br><span class="line">            &lt;&lt; <span class="string">"--add-exports=jdk.compiler/com.sun.tools.javac.code=kiwi.magic.main"</span></span><br><span class="line">            &lt;&lt; <span class="string">"--add-exports=jdk.compiler/com.sun.tools.javac.util=kiwi.magic.main"</span></span><br><span class="line">            &lt;&lt; <span class="string">"--add-exports=jdk.compiler/com.sun.tools.javac.api=kiwi.magic.main"</span></span><br><span class="line">            &lt;&lt; <span class="string">"--add-exports=jdk.compiler/com.sun.tools.javac.processing=kiwi.magic.main"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就能过编译了！虽然 IDEA 仍然会划出红线，但是只要接受他的解决方案就好（形如 <code>add XX to compiler option</code>）</p><blockquote><p>由于 IDEA 可能不会自动补全没有确定模块关系的类，教程可能会大量使用完整的类名或是指向 Java SE 8 Documentation 的引用链接。</p></blockquote><h2 id="配置-Service"><a href="#配置-Service" class="headerlink" title="配置 Service"></a>配置 Service</h2><p>Javac 通过 <a target="_blank" rel="noopener" href="https://www.baeldung.com/java-spi">Java SPI</a> 发现插件，因此你需要写一个 Service 文件让他能够发现你。</p><p>在 <code>src/main/resource/META-INF/services/com.sun.source.util.Plugin</code> 中写出：</p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 填写你的插件主类名，这是教程的例子。</span></span><br><span class="line">org.inlambda.kiwi.magic.plugin.KiwiJavacPlugin</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.ibb.co/zbHD9vS/image.png" alt="File Location"></p><p>但是还差一步。</p><h2 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h2><p>Javac 也是一个 Java 程序，他是在他的运行时 classpath 里面寻找插件的。</p><p>而在 Gradle 中，<code>annotationProcessor</code> 就会被加入到编译器的 classpath 中。但我们不能用 <code>annotationProcessor this</code> ，因为 gradle 不允许，所以我们需要另外新建一个模块专门测试插件。</p><p><img src="https://i.ibb.co/Cs4fckp/image.png" alt="Module Layout"></p><p>为了加载插件，应当确保 <code>build.gradle</code> 中有如下内容：</p><figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies {</span><br><span class="line">    testImplementation <span class="string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span></span><br><span class="line">    testRuntimeOnly <span class="string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span></span><br><span class="line">    compileOnly(project(<span class="string">":magic"</span>))</span><br><span class="line">    annotationProcessor(project(<span class="string">":magic"</span>)) <span class="comment">// 就是这个！</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">compileJava { options.compilerArgs &lt;&lt; <span class="string">'-Xplugin:Kiwi'</span> } <span class="comment">// Kiwi 是插件的名字</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>万事具备，开 <code>assemble</code> ！</p><p><img src="https://i.ibb.co/VpfMFc4/image.png" alt="Gradle Assemble Output"></p><p>现在，我们已经让 Javac 加载了我们的代码，但这仅仅是个开始。为了实现 <code>@Jsonized</code> 的目标，我们还需要注入代码。</p><h1 id="得到编译单元"><a href="#得到编译单元" class="headerlink" title="得到编译单元"></a>得到编译单元</h1><p>对 AST 下手，首先要拿到 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/CompilationUnitTree.html">CompilationUnit</a></p><p>而 Javac 通过 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/TaskEvent.html">TaskEvent</a> 将它传递给我们，因此我们要注册一个 <code>com.sun.source.util.TaskListener</code> 来收 <code>TaskEvent</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(JavacTask task, String... args)</span> { <span class="comment">// 插件初始化回调</span></span><br><span class="line">    System.out.println(<span class="string">"Hello Kiwi"</span>);</span><br><span class="line">    task.addTaskListener(<span class="keyword">new</span> <span class="title class_">KiwiTaskListener</span>(((BasicJavacTask) task).getContext()); <span class="comment">// this!</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>KiwiTaskListener</code>:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.inlambda.kiwi.magic.plugin.jc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.source.util.TaskEvent;</span><br><span class="line"><span class="keyword">import</span> com.sun.source.util.TaskListener;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KiwiTaskListener</span> <span class="keyword">implements</span> <span class="title class_">TaskListener</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KiwiTaskListener</span><span class="params">(Context context)</span> {</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">started</span><span class="params">(TaskEvent e)</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(TaskEvent e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (e.getKind() != TaskEvent.Kind.PARSE) { <span class="comment">// 注意此处</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">var</span> <span class="variable">compUnit</span> <span class="operator">=</span> e.getCompilationUnit();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>编译流程:<br>Java 编译器的几个阶段:</p><ul><li>COMPILATION</li><li>PARSE – 构造抽象语法树 (AST)</li><li>ENTER – 源码里的引用均已被解析</li><li>ANALYZE – 生成 AST 并用于分析错误</li><li>GENERATE – 为源码生成输出 (.class)</li><li>ANNOTATION_PROCESSING - 注解处理器被唤起</li><li>ANNOTATION_PROCESSING_ROUND</li><li>COMPILATION</li></ul><p>因为我们的目标是修改代码（对编译器来说，也就是对抽象语法树下手），所以只需要关心 PARSE 阶段就好了。<br>如果你对 “AST” 和 “PARSE” 的概念还不太了解，那么你可以先看看我的<a href="./Writting-A-Compiler-1.md">另一篇博客</a></p></blockquote><h2 id="获取-AST"><a href="#获取-AST" class="headerlink" title="获取 AST"></a>获取 AST</h2><p>得到 <code>CompilationUnit</code> 后，我们便可以<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/visitor">“访问”</a>到对应的 <code>class</code> 了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.inlambda.kiwi.magic.plugin.jc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.source.tree.ClassTree;</span><br><span class="line"><span class="keyword">import</span> com.sun.source.util.TreeScanner;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.JCTree; <span class="comment">//注意这些完整类名，如果你的 IDEA 补全不了尝试复制这些到 IDEA 里面去。</span></span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeMaker; </span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Context;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Names;</span><br><span class="line"><span class="keyword">import</span> org.inlambda.kiwi.magic.plugin.gens.GenJsonToString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonizedTreeScanner</span> <span class="keyword">extends</span> <span class="title class_">TreeScanner</span>&lt;Void, Context&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Void <span class="title function_">visitClass</span><span class="params">(ClassTree node, Context ctx)</span> { <span class="comment">// 此处 Context 是类型参数里规定的</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">var</span> <span class="variable">maker</span> <span class="operator">=</span> TreeMaker.instance(ctx); <span class="comment">// 1</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">name</span> <span class="operator">=</span> Names.instance(ctx); <span class="comment">// 2</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">claz</span> <span class="operator">=</span> (JCTree.JCClassDecl) node; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.getModifiers()</span><br><span class="line">                .getAnnotations()</span><br><span class="line">                .stream()</span><br><span class="line">                .anyMatch(e -&gt;</span><br><span class="line">                    e.getAnnotationType()</span><br><span class="line">                        .toString()</span><br><span class="line">                        .equals(<span class="string">"Jsonized"</span>))) { <span class="comment">// 判断是否有 Jsonized</span></span><br><span class="line">                System.out.println(<span class="string">"Jsonized class found: "</span> + node.getSimpleName());</span><br><span class="line">                <span class="built_in">super</span>.visitClass(node, ctx);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            System.err.println(t.getMessage());</span><br><span class="line">            <span class="keyword">for</span> (StackTraceElement stackTraceElement : t.getStackTrace()) {</span><br><span class="line">                System.out.println(stackTraceElement); </span><br><span class="line">                <span class="comment">// Javac 会屏蔽掉正常的报错输出，因此需要手动打印出来。</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">super</span>.visitClass(node, ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来逐个讲解这些代码。</p><ol><li><p><strong>TreeMaker</strong> 是一个非常重要的组件，通过 <code>TreeMaker</code> 我们可以创建语法树的组件然后把它们插入到现有的语法树里，也就是修改代码。</p></li><li><p><strong>Names</strong> 也是一个重要组件，因为它几乎就是符号表，虽然其本身是 <code>Identifier</code> ….。</p></li><li><p><code>JCTree.JCClassDecl</code> 就是类在AST中的定义，我们接下来会讲解到它以及更多 <code>JCTree</code> 子类的应用。</p></li></ol><p>同时，我们在 <code>magic-test</code> 模块中创建一个类用于测试 <code>@Jsonized</code>，但为了节约篇幅，类的代码不列出。</p><p>让我们的访客访问 <code>CompilationUnit</code>:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(TaskEvent e)</span> {</span><br><span class="line">    <span class="keyword">if</span> (e.getKind() != TaskEvent.Kind.PARSE) { <span class="comment">// 注意此处</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">var</span> <span class="variable">compUnit</span> <span class="operator">=</span> e.getCompilationUnit();</span><br><span class="line">    compUnit.accept(<span class="keyword">new</span> <span class="title class_">JsonizedTreeScanner</span>(), context); <span class="comment">// 此处 context 是上文类构造器依赖注入进来的</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>尝试编译 <code>magic-test</code>，你应当能在 <code>compileJava</code> 阶段看到 <code>Jsonized class found: XXX</code>。</p><h1 id="对-AST-动手动脚"><a href="#对-AST-动手动脚" class="headerlink" title="对 AST 动手动脚"></a>对 AST 动手动脚</h1><p><em>哎呀，你怎么动手动脚的！</em></p><p>拿到了类定义，我们就可以访问类里的所有元素了！另外，<code>JCTree</code> 的子类通常是可以<em>直接 toString()</em> 出来的，你可以利用这一点查看编译的输出。</p><p>但在修改之前，得先了解一下 Javac 内部的 List 实现。</p><h2 id="List-in-Javac"><a href="#List-in-Javac" class="headerlink" title="List in Javac"></a>List in Javac</h2><p>Javac 不知道出于什么缘故，他自己有一个链表（<code>com.sun.tools.javac.util.List&lt;A&gt;</code>）的实现，而且他是不可变的。</p><p>这个链表不对外公开（因为 Oracle 官方网站也没有 Javadoc），所以不提供引用链接了。</p><p>此处介绍几个常用的方法。</p><ul><li><p>List.nil()<br>静态方法。顾名思义，空集。</p></li><li><p>List.of(A x1, A x2, A x3, A… rest)<br>一个静态工厂，用于创建一个定长的 List.</p></li><li><p>一些类似 <code>prepend</code> 和 <code>append</code> 这样对元素操作的方法…<br>他们都返回新的实例，因为 <code>List&lt;A&gt;</code> 是不可变的，小心别被坑了。</p></li></ul><p>等等，那不定长的呢？于是我们还有一个类，他就是 <code>com.sun.tools.javac.util.ListBuffer&lt;A&gt;</code>。</p><p><code>ListBuffer&lt;A&gt;</code> 是 <code>List&lt;A&gt;</code> 某种类似 <a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/builder">Builder</a> 的工具，他的 <code>append</code> 等方法始终返回他自己，用完之后可以 <code>toList()</code> 转换成 <code>List&lt;A&gt;</code>。</p><p>做好这些基础知识的准备工作，我们终于，终于，终于可以开始动工了。</p><h2 id="访问类里的元素"><a href="#访问类里的元素" class="headerlink" title="访问类里的元素"></a>访问类里的元素</h2><p><img src="https://i.ibb.co/ZGJ4Gts/image.png" alt="Methods of JCClassDecl"></p><p><code>JCClassDecl</code> 并没有严格区分开来方法和字段，他们都是 <code>member</code>。然而 <code>getMembers()</code> 是只读的（因为 <code>List&lt;A&gt;</code> 不可变），所以我们要绕开 <code>getMembers()</code> 直接访问到后面的字段。</p><p>绕也很简单…</p><p><img src="https://i.ibb.co/vk3yMcv/image.png" alt="field defs"></p><p>没想到吧，Javac 里面就是这么乱。</p><p>接下来往 <code>defs</code> 里面插入方法即可。</p><h2 id="构造方法然后插进去！"><a href="#构造方法然后插进去！" class="headerlink" title="构造方法然后插进去！"></a>构造方法然后插进去！</h2><p>这里我们就要请出刚刚提到过的大名鼎鼎的 <code>TreeMaker</code> 了！ 方法定义在 Javac 中就是 <code>com.sun.tools.javac.tree.JCTree.MethodDecl</code>，可以通过 <code>TreeMaker#MethodDef</code> 构造。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建议把生成方法单独放起来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JCTree.JCMethodDecl <span class="title function_">genMethod</span><span class="params">(TreeMaker maker, Names symbolTable, JCTree.JCClassDecl claz)</span> {</span><br><span class="line">    <span class="type">var</span> <span class="variable">method</span> <span class="operator">=</span> maker.at(claz.pos).MethodDef( <span class="comment">// 1</span></span><br><span class="line">            maker.Modifiers(Flags.PUBLIC | Flags.FINAL), <span class="comment">// 方法的修饰符</span></span><br><span class="line">            symbolTable.fromString(<span class="string">"toString"</span>), <span class="comment">// 2 方法的名称</span></span><br><span class="line">            maker.Ident(symbolTable.fromString(<span class="string">"String"</span>)), <span class="comment">// 3 返回值类型</span></span><br><span class="line">            List.nil(),</span><br><span class="line">            List.nil(), <span class="comment">// 这三个先忽略再说</span></span><br><span class="line">            List.nil(),</span><br><span class="line">            maker.Block(<span class="number">0</span>, makeReturnJsonExpress(maker, symbolTable, claz)) <span class="comment">// 方法体</span></span><br><span class="line">            , <span class="literal">null</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>是不是有些迷糊？我们”娓娓道来”…</p><ol><li><code>at(claz.pos).MethodDef(</code><br>这句的意思是把 <code>TreeMaker</code> 当前的位置调整到目标类上然后再创建一个方法定义，不然可能会把方法生成到别的地方。（不过我没试过，其实方法和类关系是比较确定的，所以这个 <code>pos</code> 可能是给语句用的，因为语句有顺序。）</li><li><code>symbolTable.fromString("toString")</code><br><code>Names</code> 提供了 <code>fromString</code> 方法用来创建对应的标识符/名字（Identifier）。</li><li><code>maker.Ident</code><br><code>Ident</code> 是一个很常用的方法，他可以接受一个 <code>Names</code> 然后输出一个 <code>JCIdent</code>。<br>而 <code>JCIdent</code> 恰好是 <code>JCExpression</code>，也就是 <code>JCTree</code> 的子类。</li></ol><p>注意，从符号表拿类型并不需要把命名写完整（就好像上文写的不是 java.lang.String），如果要引入外部的类型只需要 <code>maker.Import</code> 即可</p><blockquote><p>例如：<code>maker.Import(maker.Ident(names.fromString("java.util.Objects")).getTree(), false);</code></p></blockquote><p>这还只是方法的基本信息，接下来是方法体，也就是最关键的那部分。</p><p>但在写输出 Json 之前，我们不妨先写个 <code>HelloWorld</code> 试试。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;JCTree.JCStatement&gt; makeReturnJsonExpress(TreeMaker maker, Names name, JCTree.JCClassDecl claz) {</span><br><span class="line">    <span class="keyword">return</span> List.of(maker.Return(maker.Literal(<span class="string">"Hello Jsonized!"</span>)));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后我们回到上文，把新的方法体插入到类里。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">var</span> <span class="variable">claz</span> <span class="operator">=</span> (JCTree.JCClassDecl) node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.getModifiers().getAnnotations().stream().anyMatch(e -&gt; e.getAnnotationType().toString().equals(<span class="string">"Jsonized"</span>))) {</span><br><span class="line">        System.out.println(<span class="string">"Jsonized class found: "</span> + node.getSimpleName());</span><br><span class="line">        claz.def = claz.def.append(genMethod(maker,name,claz)); <span class="comment">// THIS</span></span><br><span class="line">        <span class="built_in">super</span>.visitClass(node, ctx);</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">    System.err.println(t.getMessage());</span><br></pre></td></tr></tbody></table></figure><p>尝试编译 <code>magic-test</code> 模块并且查看编译输出，如果你没有干坏事的话应该能看到 <code>@Jsonized</code> 标注过的类里多出来一个 <code>public final String toString()</code>，并且代码体正是 <code>return "Hello Jsonized!";</code>。</p><p><img src="https://i.ibb.co/Rjqrbwh/image.png" alt="Decompiler Output"><br><em>(由于我的 Jsonized 用的是 <code>RetentionPolicy.SOURCE</code>，所以注解编译后就被抹除掉了)</em></p><h1 id="AST-的常用姿势"><a href="#AST-的常用姿势" class="headerlink" title="AST 的常用姿势"></a>AST 的常用姿势</h1><p>到上一节，你已经成功的：</p><ul><li>让 Javac 加载你的代码</li><li>对特定注解标志过的类添加代码</li></ul><p>那么这一节，我们着重讲解一些常用的操作以及更多基础知识。</p><h2 id="从获取字段开始"><a href="#从获取字段开始" class="headerlink" title="从获取字段开始"></a>从获取字段开始</h2><p>为了序列化出所有字段，我们首先需要知道我们的类里有哪些字段。</p><p>幸好，使用 <code>Stream</code> 就可以很轻松地做到这件事:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">nameToVar</span> <span class="operator">=</span> claz.getMembers().stream()</span><br><span class="line">    .filter(e -&gt; e.getKind() == Tree.Kind.VARIABLE) <span class="comment">// 其实这个可能可以省略</span></span><br><span class="line">    .filter(e -&gt; e <span class="keyword">instanceof</span> JCTree.JCVariableDecl)</span><br><span class="line">    .map(e -&gt; (JCTree.JCVariableDecl) e)</span><br><span class="line">    .collect(Collectors.toMap(e -&gt; e.getName(), e -&gt; e.getType()));</span><br></pre></td></tr></tbody></table></figure><p>产出一个 <code>Map&lt;Names, JCTree&gt;</code>。<code>JCTree</code> 就是类定义，此处为 <code>JCVariableDecl</code></p><p>有了这样一个 nameToVar 之后，我们就可以构造 Json 了。</p><h2 id="拼接字符串与二元表达式"><a href="#拼接字符串与二元表达式" class="headerlink" title="拼接字符串与二元表达式"></a>拼接字符串与二元表达式</h2><p><em>哪个男孩不想体验一下二元运算符呢？</em></p><p><img src="https://i.ibb.co/gSj670J/image.png" alt="Figure: Binary Operator"></p><p>“+” 是一个二元运算符，它接受两个参数: <code>a</code> 和 <code>b</code> 并且产出一个结果。</p><p>在 Java 里，我们是这样写的：<code>a + b</code></p><p>那么如果更多参数呢？</p><p><img src="https://i.ibb.co/RDdyC40/image.png" alt="Figure: Complexier Binary Tree"></p><p>以此类推，可以构造出一个很长很长的二元树，而这正好是我们今天要做的事情。</p><hr><p>先从拼接字符串开始，举个例子：<code>a + "literal"</code></p><p>如果我们要让一个命名 <code>a</code> 和一个字面量（<code>"literal"</code>）相加，要怎么做呢？其实很简单：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JCTree.<span class="type">JCBinary</span> <span class="variable">binary</span> <span class="operator">=</span> maker.Binary(</span><br><span class="line">    JCTree.Tag.PLUS,</span><br><span class="line">     maker.Ident(names.fromString(<span class="string">"a"</span>)),</span><br><span class="line">      maker.Literal(<span class="string">"literal"</span>)); <span class="comment">// 此处 PLUS 为运算符 "+"</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.ibb.co/6g320J4/image.png" alt="Figure: Explaination of Java Code"></p><p>回过头来，我们拼接 Json 的代码应该是这样的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"{\"success\":"</span>+ success +<span class="string">",\"response\":+"</span> response <span class="string">"+}"</span></span><br></pre></td></tr></tbody></table></figure><p>也就是:</p><p><img src="https://i.ibb.co/drS5xr3/image.png" alt="Figure: Example of Json Concatenating"></p><p>不难看出，到最后这些拼接代码都会被聚合成一个 <code>JCBinary</code>。通过这个性质，我们可以使用 <code>Stream#reduce</code> 来把众多元素聚合成一个 <code>JCBinary</code>。</p><p>此处贴出完整的 <code>makeReturnJsonExpress</code> 以供参考。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;JCTree.JCStatement&gt; makeReturnJsonExpress(TreeMaker maker, Names name, JCTree.JCClassDecl claz) {</span><br><span class="line">    <span class="type">var</span> <span class="variable">json</span> <span class="operator">=</span> claz.getMembers().stream()</span><br><span class="line">        .filter(e -&gt; e.getKind() == Tree.Kind.VARIABLE)</span><br><span class="line">        .filter(e -&gt; e <span class="keyword">instanceof</span> JCTree.JCVariableDecl)</span><br><span class="line">        .map(e -&gt; (JCTree.JCVariableDecl) e)</span><br><span class="line">        .collect(Collectors.toMap(e -&gt; e.getName(), e -&gt; e.getType()));</span><br><span class="line">    <span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> json.entrySet().stream()</span><br><span class="line">            .map(e -&gt; </span><br><span class="line">            maker.Binary(JCTree.Tag.PLUS, </span><br><span class="line">                maker.Literal(<span class="string">"\""</span> + e.getKey() + <span class="string">"\":"</span>),</span><br><span class="line">                maker.Ident(e.getKey()) <span class="comment">// 引用字段名</span></span><br><span class="line">            )</span><br><span class="line">            ).reduce((e1, e2) -&gt; </span><br><span class="line">                maker.Binary(</span><br><span class="line">                    JCTree.Tag.PLUS, </span><br><span class="line">                    e1, </span><br><span class="line">                    maker.Binary(</span><br><span class="line">                        JCTree.Tag.PLUS, </span><br><span class="line">                        maker.Literal(<span class="string">","</span>),</span><br><span class="line">                        e2)</span><br><span class="line">            ))</span><br><span class="line">            .orElseThrow();</span><br><span class="line">    list = maker.Binary(JCTree.Tag.PLUS, maker.Literal(<span class="string">"{"</span>), list);</span><br><span class="line">    list = maker.Binary(JCTree.Tag.PLUS, list, maker.Literal(<span class="string">"}"</span>));</span><br><span class="line">    <span class="keyword">return</span> List.of(maker.Return(</span><br><span class="line">            list</span><br><span class="line">    ));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此，我们的 <code>@Jsonized</code> 生成的 <code>toString</code> 已经可以处理简单情况了。</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>但是游戏还没结束，你很快会发现一个问题…. 如果数据里存有特殊字符，例如 <code>"</code> 那就出事了！因此，要给字符串加一些特殊处理。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"{\"success\":"</span>+ success +<span class="string">",\"response\":+"</span> response.replaceAll(<span class="string">"\\\""</span>,<span class="string">"\\\\\""</span>) <span class="string">"+}"</span> <span class="comment">// 拼接的时候把 " 替换为 \"</span></span><br></pre></td></tr></tbody></table></figure><p>也就是说，我们要对 <code>response</code> 进行方法调用。那么，先引入一个新方法吧！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JCTree.JCExpression <span class="title function_">processValue</span><span class="params">(JCTree value, Name name, TreeMaker maker, Names names)</span> {</span><br><span class="line">    <span class="type">var</span> <span class="variable">typeName</span> <span class="operator">=</span> value.toString();</span><br><span class="line">    <span class="keyword">switch</span> (typeName) {</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"String"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"CharSequence"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"StringBuilder"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"StringBuffer"</span>: <span class="comment">// 一切可以 toString 的...</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">toS</span> <span class="operator">=</span> maker.Exec(maker.Apply(</span><br><span class="line">                    List.nil(),</span><br><span class="line">                    maker.Select(</span><br><span class="line">                            maker.Ident(name),</span><br><span class="line">                            names.fromString(<span class="string">"toString"</span>)</span><br><span class="line">                    ),</span><br><span class="line">                    List.nil()</span><br><span class="line">            )); <span class="comment">// toS: name.toString()</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">replaced</span> <span class="operator">=</span> maker.Exec( <span class="comment">// 1</span></span><br><span class="line">                    maker.Apply( <span class="comment">// 2</span></span><br><span class="line">                            List.nil(), <span class="comment">// 类型参数，就是方法的泛型，不多过关心</span></span><br><span class="line">                            maker.Select( <span class="comment">// 3</span></span><br><span class="line">                                    toS.expr,</span><br><span class="line">                                    names.fromString(<span class="string">"replaceAll"</span>)</span><br><span class="line">                            ),</span><br><span class="line">                            List.of( <span class="comment">// 方法参数</span></span><br><span class="line">                                    maker.Literal(<span class="string">"\\\""</span>),</span><br><span class="line">                                    maker.Literal(<span class="string">"\\\\\""</span>)</span><br><span class="line">                            )</span><br><span class="line">                    )</span><br><span class="line">            ); <span class="comment">// replaced: name.toString().replaceAll(...)</span></span><br><span class="line">            <span class="keyword">return</span> maker.Binary(JCTree.Tag.PLUS, maker.Literal(<span class="string">"\""</span>),</span><br><span class="line">                    maker.Binary(JCTree.Tag.PLUS, replaced.expr, maker.Literal(<span class="string">"\""</span>)));</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> maker.Ident(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>写这篇博文的时候我还没有去深究具体要怎么获取到 <code>JCVariable</code> 的类型关系，所以只有这么蠢的方法。</p></blockquote><p>还是老样子，逐步解释代码：</p><ol><li><code>Exec</code> 执行的意思，这里可以传入一个 <code>JCExpression</code></li><li><code>Apply</code> 返回一个 <code>JCMethodInvocation</code>，正是我们要的东西</li><li><code>Select</code> 返回一个 <code>JCFieldAccess</code>，而参数是发起操作的对象和他对应的方法/字段（瞎猜的）<br>当然这里你也可以用 <code>maker.Ident(name)</code> 来代替 <code>Select</code>，也就是直接对 name 对应的对象发起动作。</li></ol><p>之后再修改一下之前的代码：</p><figure class="highlight patch"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                .map(e -&gt; </span><br><span class="line">                maker.Binary(JCTree.Tag.PLUS, </span><br><span class="line">                    maker.Literal("\"" + e.getKey() + "\":"),</span><br><span class="line"><span class="deletion">-                   maker.Ident(e.getKey()) // 引用字段名</span></span><br><span class="line"><span class="addition">+                   processValue(e.getValue(), e.getKey(), maker, name)</span></span><br><span class="line">                )</span><br><span class="line">                ).reduce((e1, e2) -&gt; </span><br></pre></td></tr></tbody></table></figure><p><em>大功告成。现在你已经得到了一个可以处理 <code>String/CharSequence/StringBuilder/StringBuffer</code> 里的转义问题（当然，只限于双引号）的编译期序列化 Json 的编译器插件了！</em></p><blockquote><p>一种更好的做法: 委托<br>与其这样大费周章的在编译器完成这些工作，倒不如再带几个类进去然后委托到类上的静态方法进行转换。<br>这样做的好处有很多，例如无需重新编译这些 <code>class</code> , 例如可以通过代码编写更灵活的转换机制… 等等。实际上，Java 14+ 中 Record 的 <code>equals</code> 正是通过 <code>INVOKEDYNAMIC</code> 委托到别处比较实现的，并且高版本 Java 中 String 类型的拼接也使用了委托。</p></blockquote><h1 id="附：使用注解处理器"><a href="#附：使用注解处理器" class="headerlink" title="附：使用注解处理器"></a>附：使用注解处理器</h1><p>除了直接编写 Javac 插件，我们还有另外一种做法，就是 <code>Annotation Processor</code>，注解处理器。</p><p>比起 Javac 插件，它的局限较高，但是用起来会方便一点<del>因为不用加那个”-Xplugin”的编译器 参数</del></p><p>所以这里简单介绍一下如何使用注解处理器访问 AST。类似 <code>Plugin</code>，你需要先继承一个 <code>AbstractProcessor</code>:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.inlambda.kiwi.magic.plugin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.source.util.Trees;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.JCTree;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeMaker;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Context;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Names;</span><br><span class="line"><span class="keyword">import</span> org.inlambda.kiwi.magic.Jsonized;</span><br><span class="line"><span class="keyword">import</span> org.inlambda.kiwi.magic.NoNullExcepted;</span><br><span class="line"><span class="keyword">import</span> org.inlambda.kiwi.magic.plugin.gens.GenJsonToString;</span><br><span class="line"><span class="keyword">import</span> org.inlambda.kiwi.magic.plugin.gens.GenNoNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes("*")</span> <span class="comment">// 表示处理任意元素</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_11)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KiwiAnnotationProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> {</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> Trees trees; <span class="comment">// 注意这里还有个 Trees</span></span><br><span class="line">    <span class="keyword">private</span> TreeMaker maker;</span><br><span class="line">    <span class="keyword">private</span> Names names;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> {</span><br><span class="line">        <span class="built_in">super</span>.init(processingEnv);</span><br><span class="line">        trees = Trees.instance(processingEnv);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">var</span> <span class="variable">f</span> <span class="operator">=</span> processingEnv.getClass().getDeclaredField(<span class="string">"context"</span>); <span class="comment">// 得到 context</span></span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            context = (Context) f.get(processingEnv);</span><br><span class="line">            maker = TreeMaker.instance(context);</span><br><span class="line">            names = Names.instance(context);</span><br><span class="line">        } <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后一样在 <code>META-INF/services/javax.annotation.processing.Processor</code> 里写上你的类名，注意是 <code>Processor</code> 而不是 <code>AbstractProcessor</code> …</p><p>拿到 <code>TreeMaker</code>, <code>Context</code>，<code>Trees</code> 和 <code>Names</code> 之后就好办很多了，接下来的问题是怎么获取到 AST。</p><p>好在 Annotation Processor API 允许我们处理所有元素而不只是规定的几个注解标注过的元素，我们可以在 <code>boolean process(...)</code> 方法中访问到所有我们要的元素（前提是 <code>@SupportedAnnotationTypes("*")</code> ）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> {</span><br><span class="line">    <span class="keyword">for</span> (TypeElement annotation : annotations) {</span><br><span class="line">        <span class="keyword">if</span> (annotation.getQualifiedName().contentEquals(Jsonized.class.getName())) { <span class="comment">// 先判断这个注解是不是我们的</span></span><br><span class="line">            <span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(annotation)) { </span><br><span class="line">                <span class="comment">//接着可以拿到注解标注过的所有元素</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 因为我们的注解 Target 是 TYPE，所以只能在类上。这里直接强转成 JCClassDecl 即可。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过 Trees 得到它对应的 AST 元素。这里的 element 实际上是个 ClassSymbol</span></span><br><span class="line">                <span class="type">var</span> <span class="variable">jtree</span> <span class="operator">=</span> (JCTree.JCClassDecl) trees.getTree(element);</span><br><span class="line">                <span class="type">var</span> <span class="variable">method</span> <span class="operator">=</span> GenJsonToString.genMethod(maker, names, jtree); <span class="comment">// 似曾相似的套路，这就是我什么推荐你单独放....</span></span><br><span class="line">                jtree.defs = jtree.defs.append(method);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em>That’s it!</em> 其实这种需求用注解处理器的话似乎比直接写 Javac 插件还要简单一些？</p><blockquote><p>注意: 注解处理器不能和 javac 插件混着用，而且在 gradle 中，他们似乎是在不同的环境里被加载的。（也就是你无法通过静态字段传递加载信息来判断用户想用的是插件还是注解处理器）</p></blockquote><h1 id="End-结语"><a href="#End-结语" class="headerlink" title="End / 结语"></a>End / 结语</h1><p>本文简要介绍了 javac 闭包 API 的基本使用以及一种使用注解处理器访问 javac AST 的方法。</p><p>不过需要注意的是，虽然这些 API 自从 1.8 加入以来就没怎么变过（应该？），他们仍然是<strong>不稳定，不安全，无保障</strong>的。因此，若要使用，请总是进行单元测试并且尝试检查版本兼容性。</p><p>本篇博客的所有代码均为 <a target="_blank" rel="noopener" href="https://codeberg.org/InlinedLambdas/Kiwi">Kiwi</a> 项目的一部分，Kiwi 以 MIT 协议开源，如果你想 Star 但是没有 Codeberg 帐号的话可以去 GitHub 上的<a target="_blank" rel="noopener" href="https://github.com/InlinedLambdas/kiwi">镜像</a> (疯狂暗示)</p><p>文章可能有偏差，可以在评论区指正。</p><p>End.</p><hr><p>Credits:</p><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/46773519/accessing-com-sun-tools-javac-util-from-java-9">StackoverFlow - Accessing com.sun.tools.javac.util from Java 9</a><br><a target="_blank" rel="noopener" href="https://www.baeldung.com/java-annotation-processing-builder">Baeldung - Java Annotation Processing and create a builder</a><br><a target="_blank" rel="noopener" href="https://www.baeldung.com/java-build-compiler-plugin">Baeldung - Creating a Java Compiler Plugin</a></p><p>… and many random StackoverFlow Answers. Thanks for them.</p></div><div class="article-licensing box"><div class="licensing-title"><p>「9+」 Java 编译器插件教程 101</p><p><a href="https://blog.0w0.ing/2022/07/06/Extending-Java-Compiler/">https://blog.0w0.ing/2022/07/06/Extending-Java-Compiler/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>iceBear67</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-07-06</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-01-16</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="icon fab fa-creative-commons"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="../../../../tags/compiler/">compiler</a><a class="link-muted mr-2" rel="tag" href="../../../../tags/tech/">tech</a><a class="link-muted mr-2" rel="tag" href="../../../../tags/Java/">Java</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer="defer"></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="../../../08/19/From-GitHub-To-Github/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">尝鲜 CodeBerg : "非主流" Git 服务现状</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="../../../02/10/How-to-help-Others/"><span class="level-item">关于提问与回答</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js"></script><script>var gitalk=new Gitalk({id:"ec4212cd15b776596880ceacf861d915",repo:"blog",owner:"iceBear67",clientID:"1921dfb2956e75e07c83",clientSecret:"3562a78b24480abde8046eedd4b04f5890b63b2b",admin:["iceBear67"],createIssueManually:!1,distractionFreeMode:!1,perPage:10,pagerDirection:"last",proxy:"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",enableHotKey:!0});gitalk.render("comment-container")</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="../../../../avatar.png" alt="iceBear 67"></figure><p class="title is-size-4 is-block" style="line-height:inherit">iceBear 67</p><p class="is-size-6 is-block">思绪转瞬即逝</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>UTC +8</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="../../../../archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="../../../../categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="../../../../tags"><p class="title">12</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="GitHub" href="https://github.com/iceBear67"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Channel" href="https://t.me/ib67_pm_bot"><i class="fab fa-telegram-plane"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="../../../../atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="../../../../archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="../../../../archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="../../../../archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="../../../../archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="../../../../categories/%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">教程</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="../../../../categories/%E6%9D%82%E6%96%87/"><span class="level-start"><span class="level-item">杂文</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="../../../../categories/%E6%9D%82%E6%96%87/%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">教程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="../../../../categories/%E8%AE%B0%E4%BA%8B/"><span class="level-start"><span class="level-item">记事</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="../../../../categories/%E9%98%90%E8%BF%B0/"><span class="level-start"><span class="level-item">阐述</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="../../../../tags/Java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/compiler/"><span class="tag">compiler</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/daily/"><span class="tag">daily</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/guide/"><span class="tag">guide</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/memories/"><span class="tag">memories</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/minecraft/"><span class="tag">minecraft</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/minestom/"><span class="tag">minestom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/misc/"><span class="tag">misc</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/security/"><span class="tag">security</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/summary/"><span class="tag">summary</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/tech/"><span class="tag">tech</span><span class="tag">5</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#先从插件说起"><span class="level-left"><span class="level-item">2</span><span class="level-item">先从插件说起</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#打通模块的穴位"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">打通模块的穴位</span></span></a></li><li><a class="level is-mobile" href="#配置-Service"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">配置 Service</span></span></a></li><li><a class="level is-mobile" href="#加载插件"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">加载插件</span></span></a></li></ul></li><li><a class="level is-mobile" href="#得到编译单元"><span class="level-left"><span class="level-item">3</span><span class="level-item">得到编译单元</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#获取-AST"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">获取 AST</span></span></a></li></ul></li><li><a class="level is-mobile" href="#对-AST-动手动脚"><span class="level-left"><span class="level-item">4</span><span class="level-item">对 AST 动手动脚</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#List-in-Javac"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">List in Javac</span></span></a></li><li><a class="level is-mobile" href="#访问类里的元素"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">访问类里的元素</span></span></a></li><li><a class="level is-mobile" href="#构造方法然后插进去！"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">构造方法然后插进去！</span></span></a></li></ul></li><li><a class="level is-mobile" href="#AST-的常用姿势"><span class="level-left"><span class="level-item">5</span><span class="level-item">AST 的常用姿势</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#从获取字段开始"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">从获取字段开始</span></span></a></li><li><a class="level is-mobile" href="#拼接字符串与二元表达式"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">拼接字符串与二元表达式</span></span></a></li><li><a class="level is-mobile" href="#调用方法"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">调用方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#附：使用注解处理器"><span class="level-left"><span class="level-item">6</span><span class="level-item">附：使用注解处理器</span></span></a></li><li><a class="level is-mobile" href="#End-结语"><span class="level-left"><span class="level-item">7</span><span class="level-item">End / 结语</span></span></a></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="../../../../js/toc.js" defer="defer"></script></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/eVNUemxxajR2WGJyck1mTU03MlUxZ3Z5RkhRUlVMTDFGOTU0Z3VPd0Nwb3czV3VmRVJ2Vm41dUVaMUtkelRkQmlIeUt4SloyVTdCQ1JpMHJjQkJGelE4T1lDL0VERDFWWnc5Qi9oQU1PckU5a3N2Wm5BcGJkTXFnenRqaG9aYnd8dmxBeEN6ZXZyaC82UHRRZHZIZEdFeHA0Q3ZKL1BhTEV3Yk5UY25EQXVrZz0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div><p class="help">在此或仓库里订阅以获取最新水文。</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="../../../../index.html"><img src="../../../../sitelogo.png" alt="nstd::out" height="28"></a><p class="is-size-7"><span>© 2024 iceBear67</span>&nbsp;&nbsp;Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>&nbsp;&amp;&nbsp;<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span><br><a target="_blank" href="https://icp.gov.moe/?keyword=20233335"><img style="width:16px;height:16px;" src="./moe.png"><span>萌ICP备20233335</span></a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer="defer"></script><script>moment.locale("zh-cn")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="../../../../js/column.js"></script><script src="../../../../js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="../../../../js/back_to_top.js" defer="defer"></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer="defer"></script><script>window.addEventListener("load",()=>{window.cookieconsent.initialise({type:"info",theme:"edgeless",static:!1,position:"bottom-left",content:{message:"此网站使用Cookie来改善您的体验。",dismiss:"知道了！",allow:"允许使用Cookie",deny:"拒绝",link:"了解更多",policy:"Cookie政策",href:"https://www.cookiesandyou.com/"},palette:{popup:{background:"#edeff5",text:"#838391"},button:{background:"#4b81e8"}}})})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer="defer"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer="defer"></script><script>window.addEventListener("load",()=>{"function"==typeof $.fn.lightGallery&&$(".article").lightGallery({selector:".gallery-item"}),"function"==typeof $.fn.justifiedGallery&&($(".justified-gallery > p > .gallery-item").length&&$(".justified-gallery > p > .gallery-item").unwrap(),$(".justified-gallery").justifiedGallery())})</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="../../../../js/main.js" defer="defer"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="../../../../js/insight.js" defer="defer"></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"../../../../content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script></body></html>