<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>一种使用 /transfer 的轻量化子服方案 - nstd::out</title><link rel="manifest" href="../../../../manifest.json"><meta name="application-name" content="nstd::out"><meta name="msapplication-TileImage" content="/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="nstd::out"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="李华是一个生电服的玩家，他总是在想，要是服务器里面有创造实验室就好了。 小叶是一个喜欢 PvP 的玩家，他总是在想，要是服务器里面有一个能干脆利落开启决斗的地方就好了。 作为这个服务器的 OP，这些场景对你来说不陌生。如果把这两个问题抛在 Minecraft 服务器社区里，相信绝大多数的回答都是「开一个新的子服务器并且建立跨服群组」，但是，这真的值得吗？"><meta property="og:type" content="blog"><meta property="og:title" content="一种使用 /transfer 的轻量化子服方案"><meta property="og:url" content="https://blog.0w0.ing/2024/07/17/multiserver-based-on-one-utilizing-transfer/"><meta property="og:site_name" content="nstd::out"><meta property="og:description" content="李华是一个生电服的玩家，他总是在想，要是服务器里面有创造实验室就好了。 小叶是一个喜欢 PvP 的玩家，他总是在想，要是服务器里面有一个能干脆利落开启决斗的地方就好了。 作为这个服务器的 OP，这些场景对你来说不陌生。如果把这两个问题抛在 Minecraft 服务器社区里，相信绝大多数的回答都是「开一个新的子服务器并且建立跨服群组」，但是，这真的值得吗？"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.0w0.ing/cover-transfer.jpg"><meta property="article:published_time" content="2024-07-17T08:39:11.000Z"><meta property="article:modified_time" content="2024-07-18T12:34:48.244Z"><meta property="article:author" content="iceBear67"><meta property="article:tag" content="tech"><meta property="article:tag" content="minecraft"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://blog.0w0.ing/cover-transfer.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.0w0.ing/2024/07/17/multiserver-based-on-one-utilizing-transfer/"},"headline":"一种使用 /transfer 的轻量化子服方案","image":["https://blog.0w0.ing/cover-transfer.jpg"],"datePublished":"2024-07-17T08:39:11.000Z","dateModified":"2024-07-18T12:34:48.244Z","author":{"@type":"Person","name":"iceBear67"},"publisher":{"@type":"Organization","name":"nstd::out","logo":{"@type":"ImageObject","url":"https://blog.0w0.ing/sitelogo.png"}},"description":"李华是一个生电服的玩家，他总是在想，要是服务器里面有创造实验室就好了。 小叶是一个喜欢 PvP 的玩家，他总是在想，要是服务器里面有一个能干脆利落开启决斗的地方就好了。 作为这个服务器的 OP，这些场景对你来说不陌生。如果把这两个问题抛在 Minecraft 服务器社区里，相信绝大多数的回答都是「开一个新的子服务器并且建立跨服群组」，但是，这真的值得吗？"}</script><link rel="canonical" href="https://blog.0w0.ing/2024/07/17/multiserver-based-on-one-utilizing-transfer/"><link rel="alternate" href="../../../../atom.xml" title="nstd::out" type="application/atom+xml"><link rel="icon" href="../../../../favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/idea.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="../../../../css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer="defer"></script><!--!--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="follow.it-verification-code" content="Ma2d4UPTxWm9UELy5eqP"><link rel="stylesheet" href="https://blog.0w0.ing/styles/admonition.css"><script>!function(){function e(){var e,t,a;location.hash&&(e="#"+CSS.escape(location.hash.substring(1)),t=document.querySelector(`.tabs a[href="${e}"]`))&&(a=t.parentElement.parentElement,Array.from(a.children).forEach(e=>e.classList.remove("is-active")),Array.from(a.querySelectorAll("a")).map(e=>document.getElementById(e.getAttribute("href").substring(1))).forEach(e=>e.classList.add("is-hidden")),t&&t.parentElement.classList.add("is-active"),a=document.querySelector(e))&&a.classList.remove("is-hidden")}e(),window.addEventListener("hashchange",e,!1)}()</script><meta name="generator" content="Hexo 7.0.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="../../../../index.html"><img src="../../../../sitelogo.png" alt="nstd::out" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="../../../../index.html">主页</a><a class="navbar-item" href="../../../../archives">归档</a><a class="navbar-item" href="../../../../categories">分类</a><a class="navbar-item" href="../../../../links">友链</a><a class="navbar-item" href="../../../../%E7%A9%BA%E8%B0%83%E6%88%BF">空调房</a><a class="navbar-item" href="../../../../about">关于</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="../../../../cover-transfer.jpg" alt="一种使用 /transfer 的轻量化子服方案"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-07-17T08:39:11.000Z" title="17/07/2024, 16:39:11">2024-07-17</time>发表</span><span class="level-item"><time datetime="2024-07-18T12:34:48.244Z" title="18/07/2024, 20:34:48">2024-07-18</time>更新</span><span class="level-item"><a class="link-muted" href="../../../../categories/%E6%9D%82%E6%96%87/">杂文</a><span>&nbsp;/&nbsp;</span><a class="link-muted" href="../../../../categories/%E6%9D%82%E6%96%87/%E6%95%99%E7%A8%8B/">教程</a></span><span class="level-item">38 分钟读完 (大约5685个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">一种使用 /transfer 的轻量化子服方案</h1><div class="content"><p>李华是一个生电服的玩家，他总是在想，要是服务器里面有创造实验室就好了。</p><p>小叶是一个喜欢 PvP 的玩家，他总是在想，要是服务器里面有一个能干脆利落开启决斗的地方就好了。</p><p>作为这个服务器的 OP，这些场景对你来说不陌生。如果把这两个问题抛在 Minecraft 服务器社区里，相信绝大多数的回答都是「开一个新的子服务器并且建立跨服群组」，但是，这真的值得吗？</p><span id="more"></span><div class="admonition info"><p class="admonition-title">info</p><p>这篇文章在 <a target="_blank" rel="noopener" href="https://wiki.sfclub.cc/s/55f6bd7b-d900-4daf-ad12-b157d80fe0da">blog stash</a> 上有着更好的阅读体验</p></div><p>显然，这不值得。如果只是为了这两样功能启动一个跨服群组，你将会面临以下问题：</p><ul><li><strong>额外的维护成本：</strong> 使用群组服则基本排除了面板服务器部署方案的可能性，并且一个没有适当配置过的群组服务器会引起诸多问题，例如：玩家使用 <code>/server</code> 跳过验证关卡，子服务器的端口意外的暴露在外网等等。</li><li><strong>资源需求上升</strong>： 启动额外的子服 + 代理程序则意味着你需要更多的资源。Java 主流 GC 的策略通常都会为了速度而将堆所占的空间悉数预分配，这导致即使程序使用的内存并没有那么多也会造成较高的 RSS.</li><li><strong>资源分配不灵活：</strong>上一个问题并不能简单的通过减少堆的大小解决。就以创造实验室为例，平时服务器内的人并不多，但一旦到了演示/大型机器实验时，较小的堆空间将会给 GC 带来相当的压力，并且无法利用到分配到其他（类似情况的，比如 PvP 竞技场）子服的空闲资源。</li><li>……</li></ul><p>光是想到从单端变群组，大多数服主就已经汗流浃背了。那么，本文所述的基于 <code>transfer</code> 机制的方案是如何规避这些问题的呢，他与其他类似方案又有何优劣之分呢？</p><h1 id="基于世界的子服划分方式"><a href="#基于世界的子服划分方式" class="headerlink" title="基于世界的子服划分方式"></a>基于世界的子服划分方式</h1><p>这个情境中使用群组方案，归根结底是为了做服务器区域之间的划分。而 Minecraft 自带的多世界机制就已经很好的解决了活动空间的划分问题：没有传送门的情况下，玩家并不能随意大小跨。</p><p>早在 2013 年，<a target="_blank" rel="noopener" href="https://www.spigotmc.org/resources/perworldplugins.96161/">PerWorldPlugins</a> 就已经实现了将插件的生效范围降级到世界层次。通过切割插件在整个服务器中的作用域，这些世界得以模拟「服务器的子服」，使用此插件的用户可以通过限定不同世界里启用的插件来模拟多服务器的效果。而在约 2020 年，<a target="_blank" rel="noopener" href="https://afdian.com/a/Valorin">Valorin 的 DuelTime / Dantiao (付费)</a> 将这个概念进一步推进，完全实现了本文引入部分时提到的「干脆利落开启决斗的地方」的设想。</p><p>然而，这样实现引入了许多需要额外维护的状态：生存服的玩家不能将物品带到创造服，他们也不希望在 PvP 服丢掉自己一身的好装备。插件需要小心翼翼的维护好这些状态，在跨世界转移的时候将他们的背包数据暂存起来，甚至有必要储存到硬盘上以防 崩服/断电/插件自身异常 导致<strong>数据丢失</strong>（数据无价！）。</p><p>并且，除了物品数据，还有许多问题需要考虑，比如玩家身上的 scoreboard / team 数据，其他插件储存的玩家相关的状态数据都可能会导致数据切割不干净。甚至如果这些插件涉及到储存功能，例如类末影箱类插件，邮箱等，被滥用的后果不堪设想。</p><p>而本文所述的方案使用 <code>transfer</code> 特性解决这些问题。</p><h1 id="Transfer-是什么"><a href="#Transfer-是什么" class="headerlink" title="Transfer 是什么"></a>Transfer 是什么</h1><p><a target="_blank" rel="noopener" href="https://minecraft.wiki/w/Commands/transfer">/transfer 命令</a> 是一项在 1.20.5 才被加入的新特性。如果你不知道他，只需要看这条命令的语法就可略知一二：</p><p><code>/transfer &lt;hostname&gt; &lt;port&gt; [players]</code></p><p>他可以让玩家的客户端主动连接加入另一个服务器。那么这有什么用呢？</p><p>首先我们要知道，Minecraft 中玩家是以 UUID 而不是名称确定的。因此，理论上可能发生这样的情况：</p><p><img src="/attachment/f7285a8b-1987-41ff-8e88-02a2d07f6ec0.png" alt="两个同名玩家在同一个服务器里, 图源 YggdrasilOfficialProxy, 作者 Karlatemp."></p><p>虽然他们的名字相同，但是他们的 UUID 不同，因此他们就是不同的玩家，而且账号数据也是毫不相干的（除了一些插件使用名称辨别，<strong>这是错误的做法</strong>）。</p><p>在一般情况下，玩家的 UUID，伴随着他的 <code>GameProfile{name, id}</code> 离开 Login State （也就是进入游戏）后就不可变了。如果想变更它的 UUID，我们只能在指派 Profile，也就是登录的时候做处理，否则会导致很多异常行为甚至数据损坏，服务端崩溃等。</p><p>但是这样做又引入了一个新的问题，也就是玩家体验不佳。他们需要在游戏内指定下一次登录时用的 GameProfile，然后退出重进，体验十分不好。并且对于离线玩家，退出重进时我们如何确定玩家的身份？IP + 玩家名并不可靠，如果你的服务器有为海外玩家设置的代理，情况将更加糟糕。</p><p>而 Transfer + Cookie 机制就可以很好的解决这个问题。Transfer 用于无缝转移玩家到新的 “子服” 中，Cookie 用于辨识玩家的身份，接下来本文将会开始分析这两者，并且给出应用实例以帮助您理解我所描述的过程。</p><h2 id="Transfer-机制的原理"><a href="#Transfer-机制的原理" class="headerlink" title="Transfer 机制的原理"></a>Transfer 机制的原理</h2><p>为什么 Transfer 能够让我们安全修改 GameProfile 呢？先从原理说起。如果你在一个服务器内使用 <code>/transfer mc.hypixel.net 25565</code>, 你将会得到一条错误信息。</p><p><img src="/attachment/908ac4b0-7e65-40fa-9e34-0f9af5533423.png" alt="transfer 失败" title=" =862x516"></p><p>这是因为对端服务器并没有启用 transfer 导致的，但服务器是如何知道我们正在使用 transfer 的呢？</p><p>既然是在登录时出错，那么这段错误的区间应该能在 HandShake ~ Login 期间找到答案。翻阅文档，可以找到这一条目：</p><p><img src="/attachment/72412c6f-f89b-4f4d-b8f4-7f3bb39c6f01.png" alt="图源 wiki.vg" title=" =934x378"></p><p>也就是说，客户端通过连接时候指定 <code>nextState=3</code> 标识该连接为 transfer 连接，并且，这个状态标识正好就在 <code>Handshake</code> 阶段。那么，如果我们 transfer 自己，玩家不就会把 Handshake → Play 的流程走个遍，而且我们还能知道他正在 transfer 回来了吗？</p><p>将 Handshake → Play 走一遍，也就意味着他将会重新启动登录流程。换句话说，也就是我们将有一个修改 Game Profile 的窗口期。现在，修改 GameProfile 的问题解决了一半，玩家只需要和跨世界一样等一下黑屏就行了——如果他不满意，还可以直接点击断线。现在来看问题的另一半——我们如何辨别这是刚刚请求跨服的玩家，而不是从其他服务器 transfer 过来的玩家呢？</p><h2 id="与-Transfer-伴随而来的-Cookies-机制"><a href="#与-Transfer-伴随而来的-Cookies-机制" class="headerlink" title="与 Transfer 伴随而来的 Cookies 机制"></a>与 Transfer 伴随而来的 Cookies 机制</h2><div class="admonition error"><p class="admonition-title">注意！</p><p>Cookies 机制是一个高度实验性的机制，Minecraft Wiki 上也没有记载与其相关的命令，并且 Notchian（也就是原版）服务端通常会<strong>直接拒绝处理客户端发来的 Cookie Response</strong>.</p></div><p>伴随着 <code>/transfer</code> 来到 1.20.5 的还有新的 cookies 机制，对，就类似你想的那个浏览器上的 cookies.</p><p>Cookies 机制非常特别，它贯穿了 Minecraft 从 Login 到 Play 的所有 State。我们从 Login 开始就可以向客户端请求 Cookies, 而在 Play 阶段也仍然能操作 Cookies. 并且，客户端储存的 Cookies 数据对使用 /transfer 过程中的所有服务器可用，这使得本方案也易于拓展成多服务器无代理的形式，因为服务器间不需要额外同步状态（除了吊销令牌）</p><p>先来看看 Cookies 机制有关的三种包</p><p><img src="/attachment/676ac638-14f3-47bd-a9d8-01e77df0614c.png" alt="Login State 下查询客户端 Cookie" title=" =643x150"></p><p><img src="/attachment/a2e4b66a-1fbc-4372-bb4a-f08246a0754c.png" alt="Login State 下客户端对 Cookie Request 的回应" title=" =966x243"></p><p><img src="/attachment/e0efec05-6302-4281-8ccf-f6febf35a628.png" alt="Configuration State 下服务器设置客户端 Cookie 的请求，注意有延迟" title=" =1054x178"></p><p>Cookie Request/Response 在 Play 到 Login 的所有 State 中都可用，封包格式一致。而 Store Cookie 比较特殊，他在 Configuration 往后可用。使用 Cookie 机制，我们就可以有效辨别跨服流程中的玩家，避免外源，而且不需要额外登录验证措施，因为 Cookies 数据只在 /transfer 中涉及的服务器里有效，当玩家主动离线后，Cookies 数据将会丢失。（这也是他的一个弱点）</p><p>由这两个机制，我们可以设计出这样一个简单的流程：</p><ul><li><p><strong>[PLAY] 玩家请求跨服（准备 Transfer）</strong></p><p>此时玩家会将需要加入的子服名称告诉服务器。</p></li><li><p><strong>[PLAY] 储存 Cookies 到客户端</strong></p><p>我们将玩家请求的子服名称作为 Cookies 存入玩家的客户端中，准备开始”跨服”。</p></li><li><p><strong>[PLAY] 进入重配置阶段</strong></p><p>我们发送 <code>Start Configuration (0x69)</code> 将玩家的客户端重置到 Configuration State.</p><p>在这个阶段，我们可以安全的准备 Cookies 和房间设施。（注意时间长了是可以点 Disconnect 的，不是不能）</p><p><img src="/attachment/5e27984b-74f1-496f-b9cf-eee56fb7f9ed.png" alt="进入重配置阶段的客户端 （Configuration State）" title=" =862x516"></p></li><li><p><strong>[CONFIG] 发送 Cookies 给客户端，并等待。</strong></p></li></ul><div class="admonition error"><p class="admonition-title">注意！</p><p>客户端支持的 Cookie 的 Value 负荷上限为 5KiB, 不要超过这个数值</p></div><ul><li><p><strong>[CONFIG]</strong> <strong>开始 Transfer 到自己</strong>（发送 <code>Transfer (0x0B)</code>）</p><p>此时客户端从服务器断开连接，但他即将重新连接。</p></li><li><p><strong>[LOGIN]</strong> Login State 下，我们可以确定客户端的 Cookies，为其<strong>依据 Room ID 计算一个新的 UUID 覆盖掉原本 GameProfile 中的结果</strong></p></li></ul><div class="admonition note"><p class="admonition-title">note</p><p>这个过程可以做到和正版验证不冲突，因此正版玩家仍然可以在登录之后才能进入服务器。你也可以直接根据 Cookies 直接放行</p></div><ul><li><p><strong>[PLAY]</strong> <strong>玩家以”新玩家但同名”的身份成功加入游戏</strong></p><p>数据和之前同名字不同 UUID 的存档完全隔离，你可以安全的对他做任何事情，比如传送到一个新世界的地皮并且赋予创造模式。</p></li></ul><p>以下是具体实现环节，命名均来自 1.21 Yarn Mapping。</p><h1 id="实例：使用-goto-在服务器内反复横跳"><a href="#实例：使用-goto-在服务器内反复横跳" class="headerlink" title="实例：使用 /goto 在服务器内反复横跳"></a>实例：使用 /goto 在服务器内反复横跳</h1><p>如果你喜欢直接看代码，可以直接看<a target="_blank" rel="noopener" href="https://github.com/saltedfishclub/sfcraft/commit/021907d2d69ec9ebb80ede7f7012bafc51306b34">我的这个 spike test</a>，但本文中的代码相对更加清晰一些（重写了）。</p><p>本篇文章讨论的特性正在 <a target="_blank" rel="noopener" href="https://github.com/saltedfishclub/sfcraft">sfcraft</a> 中被应用，欢迎留个 star。</p><p><del>接下来是我踩坑的总结</del></p><p>首先，为了辨别一下当前的 GameProfile, 写个提示工具：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onJoin</span><span class="params">(ServerPlayNetworkHandler handler, PacketSender sender, MinecraftServer server)</span> {</span><br><span class="line">    <span class="type">var</span> <span class="variable">profile</span> <span class="operator">=</span> handler.player.getGameProfile();</span><br><span class="line">    handler.player.sendMessage(Text.of(<span class="string">"Your uuid: "</span> + profile.getId()));</span><br><span class="line">    handler.player.sendMessage(Text.of(<span class="string">"Is room player: "</span>+ Helper.isRoomPlayer(profile)));</span><br><span class="line">    handler.player.sendMessage(Text.of(<span class="string">"Room id:"</span> + rooms.get(profile)));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个工具的逻辑比较简单，因此不多赘述，他能帮助你了解后面发生了什么事。</p><p>过程的第一步是玩家请求 transfer, 这里我用一个命令 <code>/goto &lt;room&gt;</code> 来做，让我们看看这个命令的逻辑：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">onGoto</span><span class="params">(CommandContext&lt;ServerCommandSource&gt; ctx)</span> {</span><br><span class="line">    <span class="type">var</span> <span class="variable">room</span> <span class="operator">=</span> ctx.getArgument(<span class="string">"room"</span>, String.class);</span><br><span class="line">    <span class="type">var</span> <span class="variable">player</span> <span class="operator">=</span> ctx.getSource().getPlayer();</span><br><span class="line">    <span class="keyword">if</span> (player == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">var</span> <span class="variable">network</span> <span class="operator">=</span> player.networkHandler;</span><br><span class="line">    network.reconfigure();</span><br><span class="line">    network.send(<span class="keyword">new</span> <span class="title class_">StoreCookieS2CPacket</span>(IDENTIFIER_ROOM, room.getBytes(StandardCharsets.UTF_8)), PacketCallbacks.always(()-&gt;{</span><br><span class="line">        network.sendPacket(<span class="keyword">new</span> <span class="title class_">ServerTransferS2CPacket</span>(<span class="string">"localhost"</span>, serverSupplier.get().getServerPort())););</span><br><span class="line">    }));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>乍看没什么，但是这里其实有个雷，就是我没有直接发 <code>Start Configuration (0x69)</code> 而是使用了 <code>network.reconfigure()</code>，他们之间有什么区别吗？有，大大的有，因为你要是直接发包</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[23:18:10] [Server thread/INFO] (Minecraft) iceBear67[/127.0.0.1:38938] logged <span class="keyword">in</span> with entity <span class="built_in">id</span> 11 at (673.0034440744827, 73.7776368487581, 2774.6987246258886)</span><br><span class="line">[23:18:10] [Server thread/INFO] (Minecraft) iceBear67 joined the game</span><br><span class="line">[23:18:14] [Server thread/INFO] (Minecraft) iceBear67 lost connection: Internal Exception: io.netty.handler.codec.EncoderException: Pipeline has no outbound protocol configured, can\<span class="string">'t process packet net.minecraft.network.packet.s2c.play.ChunkDeltaUpdateS2CPacket@31cb9619</span></span><br><span class="line"><span class="string">[23:18:14] [Server thread/INFO] (Minecraft) iceBear67 left the game</span></span><br></pre></td></tr></tbody></table></figure><p>他就会爆</p><p><img src="/attachment/77887025-61c6-4a88-a402-df8157abdffa.png" alt="真的会爆"></p><p>因为你光发这个包，两端的状态是对不上的，我们点开 <code>configure</code> 的实现就能看到：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reconfigure</span><span class="params">()</span> {</span><br><span class="line">	<span class="built_in">this</span>.requestedReconfiguration = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">this</span>.cleanUp();</span><br><span class="line">	<span class="built_in">this</span>.sendPacket(EnterReconfigurationS2CPacket.INSTANCE);</span><br><span class="line">	<span class="built_in">this</span>.connection.transitionOutbound(ConfigurationStates.S2C);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对比一下，如果你直接发，服务端这边并不会 <code>transitionOutbound</code> 到 <code>ConfigurationState</code>, 所以我们需要使用这个包装好的方法才能正常进入状态。</p><div class="admonition info"><p class="admonition-title">info</p><p>这里发 Transfer 最好放到 PacketCallbacks 中，避免可能的问题。</p></div><div class="admonition note"><p class="admonition-title">note</p><p>Server Transfer 包需要填写 IP 和 Port, 你可以手填，但还有一种更加稳定的方法。 在 Handshake 阶段，我们可以看到：</p><p><img src="/attachment/bea8d201-2169-40f3-8999-c58c9efd1f8f.png" alt="Handshake (0x00)" title=" =1719x325"></p><p>可以发现，客户端是会发送他们使用的 IP 和端口的。如果使用这里的凭据我们就可以适配上述的海外代理情形，而 Hypixel 实际上也使用这种方法来封禁 TCP 转发（虽然很容易被绕过）。说到这里，其实还可以用 Transfer 做代理 IP 检查，但是超出了本文的范畴，欢迎读者研究分享经验。</p></div><p>到这里为止，玩家进入了 Configuratation 状态，接收到了 Cookies 而且即将要开始他的 Transfer 了，我们要准备迎接他。</p><h2 id="迎接-Transfer-玩家"><a href="#迎接-Transfer-玩家" class="headerlink" title="迎接 Transfer 玩家"></a>迎接 Transfer 玩家</h2><p>在上一步结束之后，玩家会从服务器断线并且尝试重新加入（客户端提示： <code>Transferring to new server</code> ）</p><p>根据上面所述的流程，我们要在他进入 Login State 时指派他将使用的 GameProfile.</p><p>在 Yarn 命名表中，负责该流程的类为 <code>ServerLoginNetworkHandler</code>, 我们找到它的代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerLoginNetworkHandler</span> <span class="keyword">implements</span> <span class="title class_">ServerLoginPacketListener</span>, TickablePacketListener{</span><br><span class="line">    <span class="comment">// ... 无关代码被忽略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServerLoginNetworkHandler.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> ServerLoginNetworkHandler.State.HELLO;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> transferred; <span class="comment">// &lt;- 这就是上文说的标识</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ServerLoginNetworkHandler</span><span class="params">(MinecraftServer server, ClientConnection connection, <span class="type">boolean</span> transferred)</span> {</span><br><span class="line">        <span class="comment">// ... 无关代码被忽略</span></span><br><span class="line">		<span class="built_in">this</span>.transferred = transferred;</span><br><span class="line">	}</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tick</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.state == ServerLoginNetworkHandler.State.VERIFYING) {</span><br><span class="line">			<span class="built_in">this</span>.tickVerify((GameProfile)Objects.requireNonNull(<span class="built_in">this</span>.profile));</span><br><span class="line">		}</span><br><span class="line">        <span class="comment">// ... 无关代码被忽略</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onHello</span><span class="params">(LoginHelloC2SPacket packet)</span> { <span class="comment">// 登录入口从这里开始</span></span><br><span class="line">		Validate.validState(<span class="built_in">this</span>.state == ServerLoginNetworkHandler.State.HELLO, <span class="string">"Unexpected hello packet"</span>);</span><br><span class="line">		Validate.validState(StringHelper.isValidPlayerName(packet.name()), <span class="string">"Invalid characters in username"</span>);</span><br><span class="line">		<span class="built_in">this</span>.profileName = packet.name();</span><br><span class="line">		<span class="type">GameProfile</span> <span class="variable">gameProfile</span> <span class="operator">=</span> <span class="built_in">this</span>.server.getHostProfile();</span><br><span class="line">		<span class="keyword">if</span> (gameProfile != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.profileName.equalsIgnoreCase(gameProfile.getName())) {</span><br><span class="line">			<span class="built_in">this</span>.startVerify(gameProfile);</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.server.isOnlineMode() &amp;&amp; !<span class="built_in">this</span>.connection.isLocal()) {</span><br><span class="line">				<span class="built_in">this</span>.state = ServerLoginNetworkHandler.State.KEY; <span class="comment">// 开始正版验证</span></span><br><span class="line">				<span class="built_in">this</span>.connection.send(<span class="keyword">new</span> <span class="title class_">LoginHelloS2CPacket</span>(<span class="string">""</span>, <span class="built_in">this</span>.server.getKeyPair().getPublic().getEncoded(), <span class="built_in">this</span>.nonce, <span class="literal">true</span>));</span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				<span class="built_in">this</span>.startVerify(Uuids.getOfflinePlayerProfile(<span class="built_in">this</span>.profileName)); <span class="comment">// 离线玩家流程</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">startVerify</span><span class="params">(GameProfile profile)</span> {</span><br><span class="line">		<span class="built_in">this</span>.profile = profile;</span><br><span class="line">		<span class="built_in">this</span>.state = ServerLoginNetworkHandler.State.VERIFYING;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tickVerify</span><span class="params">(GameProfile profile)</span> {</span><br><span class="line">		<span class="comment">// 最后的检查...</span></span><br><span class="line">        <span class="built_in">this</span>.sendSuccessPacket(profile); <span class="comment">// 进入游戏</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>发现 <code>ServerLoginNetworkHandler</code> 已经提供了一个 <code>transferred</code> 标识，我们不需要做额外处理来获取他。我们来想一下一个问题，如果要做 GameProfile 的指派，我们就需要 Cookies, 那么这个 Cookies 哪里来呢？于是乎，我们需要发一个 Cookie Request.</p><p><img src="/attachment/676ac638-14f3-47bd-a9d8-01e77df0614c.png" alt="Login State 下查询客户端 Cookie" title=" =643x150">当客户端发来的 Cookie Response 到达后，他会调用该类里面的一个回调方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCookieResponse</span><span class="params">(CookieResponseC2SPacket packet)</span> {</span><br><span class="line">       <span class="comment">// 从这里也可以看出是实验性功能</span></span><br><span class="line">	<span class="built_in">this</span>.disconnect(ServerCommonNetworkHandler.UNEXPECTED_QUERY_RESPONSE_TEXT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析结束，接下来是实现环节。</p><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><p>观察这个类的代码结构可以发现，一个玩家加入服务器首先会从 <code>onHello</code> 出发，接着判断正盗版之后选择启动正版验证流程（<code>State.KEY</code>）或者是直接开始准备进入游戏（ <code>startVerify</code>）</p><p>但是，<code>startVerify</code> 并不直接开始进入游戏流程，而是设置 <code>state = VERIFING</code> 之后直接返回，等待 <code>tick</code> 时根据 State 指派调用到 <code>tickVerify</code>. 而和正版验证有关的 <code>State.KEY</code> 也是回归到 <code>startVerify</code> 里处理。由此，我们可以选择在 <code>startVerify</code> 下钩子，这样就可以兼顾正盗版问题，并且不会引入更多复杂问题。</p><div class="admonition warning"><p class="admonition-title">思考题</p><p>如果我们想让玩家绕过正版验证登录，应该怎么做呢？</p></div><p>在 <code>startVerify</code> 的 <code>HEAD</code> 处注入一段代码（接下来不会贴出全部代码）向玩家请求 cookie，并且阻止服务器进入 <code>State.VERIFYING</code> 状态，否则玩家会直接进入服务器。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Inject</span>(method = <span class="string">"startVerify"</span>, at = @<span class="title class_">At</span>(<span class="string">"HEAD"</span>), cancellable = <span class="literal">true</span>)</span><br><span class="line">private <span class="keyword">void</span> <span class="title function_">sf$queryCookies</span>(<span class="title class_">GameProfile</span> profile, <span class="title class_">CallbackInfo</span> ci) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">transferred</span>) {</span><br><span class="line">        <span class="keyword">switch</span>(<span class="variable language_">this</span>.<span class="property">sf$cookieState</span>){</span><br><span class="line">           <span class="keyword">case</span> <span class="attr">NOT_SENT</span>:</span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">profile</span> = profile;</span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">connection</span>.<span class="title function_">send</span>(<span class="keyword">new</span> <span class="title class_">CookieRequestS2CPacket</span>(<span class="title class_">HintModule</span>.<span class="property">IDENTIFIER_ROOM</span>));</span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">sf$cookieState</span> = <span class="variable constant_">SENT</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">sf$cookieState</span> != <span class="variable constant_">DONE</span>){</span><br><span class="line">            ci.<span class="title function_">cancel</span>()</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接着，我们要注入 <code>onCookieResponse</code> 从而得到对应的数据。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject(method = "onCookieResponse", at = @At("HEAD"), cancellable = true)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> sf$onRoomId(CookieResponseC2SPacket packet, CallbackInfo ci) {</span><br><span class="line">    <span class="keyword">if</span> (packet.key().equals(SOME_SERVER_IDENTIFIER_KEY)) {</span><br><span class="line">        <span class="keyword">if</span>(sf$cookieState != SENT) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"Protocol error"</span>);</span><br><span class="line">        <span class="type">var</span> <span class="variable">payload</span> <span class="operator">=</span> packet.payload();</span><br><span class="line">        sf$roomId = <span class="keyword">new</span> <span class="title class_">String</span>(payload);</span><br><span class="line">    }</span><br><span class="line">    ci.cancel();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们就得到了子服务器的 ID，接下来我们要考虑恢复到 <code>VERIFYING</code> 状态的问题。</p><p>情况有两个：</p><ol><li><strong>没有正确 Cookie 的 Transfer</strong>: 玩家将会因为给不出 Cookie 超时从而掉线</li><li><strong>给了 Cookie 并且正确</strong>: 进入 Profile 的指派流程</li></ol><p>第一个情况不需要考虑，我们只需要考虑第二个。我选择的方法是在 <code>tick()</code> 尾巴多插入一段逻辑用于触发 <code>startVerify</code>:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject(method = "tick", at = @At("TAIL"))</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> sf$awaitRoom(CallbackInfo ci) {</span><br><span class="line">    <span class="keyword">if</span> (sf$cookieState == SENT &amp;&amp; sf$roomId != <span class="literal">null</span>) {</span><br><span class="line">        sf$cookieState = COOKIE_RECV;</span><br><span class="line">        startVerify(<span class="built_in">this</span>.profile);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到这里，又会回归到我们在 <code>startVerify</code> 下的 hook 里面。现在我们已经有了子服务器的 ID（ <code>sf$roomId</code> ），可以继续正式开始指派了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject(method = "startVerify", at = @At("HEAD"), cancellable = true)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> sf$queryCookies(GameProfile profile, CallbackInfo ci) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.transferred) {</span><br><span class="line">        <span class="keyword">switch</span>(<span class="built_in">this</span>.sf$cookieState){</span><br><span class="line">           <span class="keyword">case</span> NOT_SENT:</span><br><span class="line">             <span class="built_in">this</span>.profile = profile;</span><br><span class="line">             <span class="built_in">this</span>.connection.send(<span class="keyword">new</span> <span class="title class_">CookieRequestS2CPacket</span>(HintModule.IDENTIFIER_ROOM));</span><br><span class="line">             <span class="built_in">this</span>.sf$cookieState = SENT;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">+           <span class="keyword">case</span> COOKIE_RECV:           </span><br><span class="line">+             <span class="comment">// 根据 roomId hash 出一个新的 profile 以此做到数据隔离</span></span><br><span class="line">+             <span class="comment">// 当然在这里你还可以检查一下冲突情况</span></span><br><span class="line">+             <span class="built_in">this</span>.profile = Helper.generateProfileForRoom(sf$roomId, <span class="built_in">this</span>.profile); <span class="comment">// 此处是之前存进去的 profile</span></span><br><span class="line">+             <span class="comment">// 但是要注意：参数里的 profile 是原本的 profile,如果这里不 cancel 的话会把你设置的 profile 覆盖掉</span></span><br><span class="line">+             <span class="comment">// 你也可以把这段注入到 TAIL 来避免问题</span></span><br><span class="line">+             <span class="built_in">this</span>.sf$cookieState = DONE;</span><br><span class="line">+             <span class="built_in">this</span>.startVerify(<span class="built_in">this</span>.profile);</span><br><span class="line">+             ci.cancel()</span><br><span class="line">+             <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.sf$cookieState != DONE){</span><br><span class="line">            ci.cancel()</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到此，指派 Profile 的过程就完毕了。如果你的服务器和我的一样开了白名单，那么还要额外给予赦免。</p><div class="admonition info"><p class="admonition-title">info</p><p>在 Cookies 被检查过的情况下，可以认为玩家的连接是可信的（但我这里没做签名校验）</p></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Redirect(method = "tickVerify", at = @At(value = "INVOKE", target = "Lnet/minecraft/server/PlayerManager;checkCanJoin(Ljava/net/SocketAddress;Lcom/mojang/authlib/GameProfile;)Lnet/minecraft/text/Text;"))</span></span><br><span class="line"><span class="keyword">private</span> Text sf$bypassRoomPlayer(PlayerManager instance, SocketAddress address, GameProfile profile) {</span><br><span class="line">    <span class="keyword">if</span> (sf$cookieVerified) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> instance.checkCanJoin(address, profile);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以下是示例：</p><p><img src="/attachment/03337f12-9d9b-4a74-8798-446c5cf56a14.png" alt="第一次进入服务器，并且即将进入 test_room" title=" =642x191"> ![中间过渡]/(attachment/e7ab3fc4-c988-4b63-8666-cc6cbecc28fa.png “ =862x516”)</p><p><img src="/attachment/c907f8a2-f194-499e-b29f-5fc431294b53.png" alt="以一个新的 UUID 重新加入了游戏，注意 room_id 被正确读取，我在文章之外写了一部分状态管理" title=" =862x516"></p><p>这篇文章完整的技术 demo 可以在 <a target="_blank" rel="noopener" href="https://github.com/saltedfishclub/sfcraft/commit/021907d2d69ec9ebb80ede7f7012bafc51306b34">这里</a> 找到</p><h1 id="End-总结"><a href="#End-总结" class="headerlink" title="End / 总结"></a>End / 总结</h1><p>总结一下。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>使用 Transfer 机制可以帮助你让玩家拥有多个不同的账号数据（也就是存档），并且你可以根据这个特性设计出很多好玩的东西，而不只是子服。</p><p>再者，使用此方案较 BungeeCord / Velocity 类更加轻量，在开头所述的轻量级子服情境下有着更高的资源利用率，且无论是腐竹还是开发者的运维/状态维护状态都更低。</p><p>该方案实现的多存档可以完美的抵御掉电/插件 bug 带来的切换账号时数据丢失，而且 cookies 的应用也使得服务器能够在 transfer 的窗口期间确定盗版玩家的身份，避免同 IP 情况卡着窗口期错误登录或者是其他特殊的情况，并有望减少多个服务器间状态同步的棘手问题。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>难以对服务器进行扩容，且群组服情境下要使用这个方案较为复杂，需要代理支持。</p><h2 id="机制术语表"><a href="#机制术语表" class="headerlink" title="机制术语表"></a>机制术语表</h2><p>Transfer —— 一个让客户端重新启动加入服务器流程的机制</p><p>Cookies —— 配合 Transfer 机制使用，可以<strong>（仅）</strong>在 Transfer 期间让玩家客户端储存自定义数据，大小不超过 5KiB</p><h2 id="保留节目"><a href="#保留节目" class="headerlink" title="保留节目"></a>保留节目</h2><p>这个功能其实主要也是服务器需求推动的，文章开头的两个需求都是真实的例子，而我也确实是面板服（悲）</p><p>自从去年高考之后已经很久没有更新文章了，这次刚好有材料写了，一次性更个大的，感谢大家支持。</p><p>感觉 Hexo 越来越难用了，没准我会迁移到 Outline 上面去。。</p><p><strong>🥰</strong> Thank you for reading this</p></div><div class="article-licensing box"><div class="licensing-title"><p>一种使用 /transfer 的轻量化子服方案</p><p><a href="https://blog.0w0.ing/2024/07/17/multiserver-based-on-one-utilizing-transfer/">https://blog.0w0.ing/2024/07/17/multiserver-based-on-one-utilizing-transfer/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>iceBear67</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-07-17</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-07-18</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="icon fab fa-creative-commons"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="../../../../tags/tech/">tech</a><a class="link-muted mr-2" rel="tag" href="../../../../tags/minecraft/">minecraft</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer="defer"></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="../../../09/23/changed/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">GPG 公钥更新</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="../../../06/11/Domain-Migration/"><span class="level-item">关于域名更改</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js"></script><script>var gitalk=new Gitalk({id:"d84a858726b3909d6fa34d8d3ba52173",repo:"blog",owner:"iceBear67",clientID:"1921dfb2956e75e07c83",clientSecret:"3562a78b24480abde8046eedd4b04f5890b63b2b",admin:["iceBear67"],createIssueManually:!1,distractionFreeMode:!1,perPage:10,pagerDirection:"last",proxy:"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",enableHotKey:!0});gitalk.render("comment-container")</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="../../../../avatar.png" alt="iceBear 67"></figure><p class="title is-size-4 is-block" style="line-height:inherit">iceBear 67</p><p class="is-size-6 is-block">思绪转瞬即逝</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>UTC +8</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="../../../../archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="../../../../categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="../../../../tags"><p class="title">12</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="GitHub" href="https://github.com/iceBear67"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Channel" href="https://t.me/ib67_pm_bot"><i class="fab fa-telegram-plane"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="../../../../atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="../../../../archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="../../../../archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="../../../../archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="../../../../archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="../../../../categories/%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">教程</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="../../../../categories/%E6%9D%82%E6%96%87/"><span class="level-start"><span class="level-item">杂文</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="../../../../categories/%E6%9D%82%E6%96%87/%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">教程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="../../../../categories/%E8%AE%B0%E4%BA%8B/"><span class="level-start"><span class="level-item">记事</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="../../../../categories/%E9%98%90%E8%BF%B0/"><span class="level-start"><span class="level-item">阐述</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="../../../../tags/Java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/compiler/"><span class="tag">compiler</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/daily/"><span class="tag">daily</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/guide/"><span class="tag">guide</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/memories/"><span class="tag">memories</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/minecraft/"><span class="tag">minecraft</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/minestom/"><span class="tag">minestom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/misc/"><span class="tag">misc</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/security/"><span class="tag">security</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/summary/"><span class="tag">summary</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../../../tags/tech/"><span class="tag">tech</span><span class="tag">5</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/eVNUemxxajR2WGJyck1mTU03MlUxZ3Z5RkhRUlVMTDFGOTU0Z3VPd0Nwb3czV3VmRVJ2Vm41dUVaMUtkelRkQmlIeUt4SloyVTdCQ1JpMHJjQkJGelE4T1lDL0VERDFWWnc5Qi9oQU1PckU5a3N2Wm5BcGJkTXFnenRqaG9aYnd8dmxBeEN6ZXZyaC82UHRRZHZIZEdFeHA0Q3ZKL1BhTEV3Yk5UY25EQXVrZz0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div><p class="help">在此或仓库里订阅以获取最新水文。</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="../../../../index.html"><img src="../../../../sitelogo.png" alt="nstd::out" height="28"></a><p class="is-size-7"><span>© 2024 iceBear67</span>&nbsp;&nbsp;Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>&nbsp;&amp;&nbsp;<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span><br><a target="_blank" href="https://icp.gov.moe/?keyword=20233335"><img style="width:16px;height:16px;" src="./moe.png"><span>萌ICP备20233335</span></a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer="defer"></script><script>moment.locale("zh-cn")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="../../../../js/column.js"></script><script src="../../../../js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="../../../../js/back_to_top.js" defer="defer"></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer="defer"></script><script>window.addEventListener("load",()=>{window.cookieconsent.initialise({type:"info",theme:"edgeless",static:!1,position:"bottom-left",content:{message:"此网站使用Cookie来改善您的体验。",dismiss:"知道了！",allow:"允许使用Cookie",deny:"拒绝",link:"了解更多",policy:"Cookie政策",href:"https://www.cookiesandyou.com/"},palette:{popup:{background:"#edeff5",text:"#838391"},button:{background:"#4b81e8"}}})})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer="defer"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer="defer"></script><script>window.addEventListener("load",()=>{"function"==typeof $.fn.lightGallery&&$(".article").lightGallery({selector:".gallery-item"}),"function"==typeof $.fn.justifiedGallery&&($(".justified-gallery > p > .gallery-item").length&&$(".justified-gallery > p > .gallery-item").unwrap(),$(".justified-gallery").justifiedGallery())})</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="../../../../js/main.js" defer="defer"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="../../../../js/insight.js" defer="defer"></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"../../../../content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script></body></html>