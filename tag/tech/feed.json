{
    "version": "https://jsonfeed.org/version/1",
    "title": "nstd::out • All posts by \"tech\" tag",
    "description": "iceBear 的博客",
    "home_page_url": "https://nstd.sfclub.cc",
    "items": [
        {
            "id": "https://nstd.sfclub.cc/2022/03/05/Meeting-With-Modern-Java/",
            "url": "https://nstd.sfclub.cc/2022/03/05/Meeting-With-Modern-Java/",
            "title": "现代 Java 入门指北",
            "date_published": "2022-03-05T13:07:55.000Z",
            "content_html": "<p>一天，你坐在办公桌上开始编写新的项目，而为了写起来方便，你开始往项目里添加工具依赖。  </p>\n",
            "tags": [
                "tech",
                "java"
            ]
        },
        {
            "id": "https://nstd.sfclub.cc/2021/11/05/How-Does-Java-Tag-Garbages/",
            "url": "https://nstd.sfclub.cc/2021/11/05/How-Does-Java-Tag-Garbages/",
            "title": "浅谈 Java 虚拟机是如何标识垃圾的",
            "date_published": "2021-11-05T15:20:16.000Z",
            "content_html": "<p>Java 作为一门 VM 语言，它的垃圾回收机制确实帮我们省了很多事情，我们不再需要去”手动管理内存的分配和释放”，只需要交给 VM 来做就好了。  </p>\n<p>然而，真的是这样吗？即使有<a href=\"https://malloc.se/blog/zgc-jdk16\">神一般高性能的垃圾回收器</a>，我们写代码时仍然需要注意它是<em>如何标记垃圾对象</em>的，因为垃圾回收器并不是万能的，仍然有一些工作需要程序员自己完成。  </p>\n<p>本文试图通俗易懂的讲解 JVM 上标记垃圾的方法，如有错误请在评论区指正。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"两种标记垃圾的方式\"><a href=\"#两种标记垃圾的方式\" class=\"headerlink\" title=\"两种标记垃圾的方式\"></a>两种标记垃圾的方式</h1><p>或许你曾听闻过 <code>引用计数法</code>，也就是 <code>一个对象被引用时计数器 + 1 ，解除引用时计数器 - 1，当计数器为 0 时将会被 GC</code>，看起来非常可行。  </p>\n<p>但是这种方法没有被 Java 采用，因为他有两个显而易见的问题：</p>\n<ul>\n<li>循环引用问题 如果一个对象内部引用了另一个 引用这个对象的 对象，那么计数器将永远不会为 0</li>\n<li>计数器的维护问题 引用计数器的值会以极快的速度更新，更新任务变得繁重 </li>\n</ul>\n<p>或许因此，Java 采用了 <code>可达性分析</code> 的方法对垃圾进行标记。</p>\n<h1 id=\"可达性分析\"><a href=\"#可达性分析\" class=\"headerlink\" title=\"可达性分析\"></a>可达性分析</h1><p>可达性分析的思路很简单。</p>\n<p>他从一组叫 <code>GC Root</code> 的引用出发，递归搜索出所有能被到达的节点作为<strong>存活</strong>的对象，而此外那些没有被搜索到的对象就会被标记 <strong>将被清理</strong>。</p>\n<p><img src=\"https://upload.cc/i1/2021/11/05/cvqtiw.png\">  </p>\n<p>途中，被蓝色尖头指向的对象将不会被清除，因为他们间接或者直接的被 <code>GC Root</code> 引用。而旁边没有被 <code>GC Root</code> 引用的两个对象将会被清除，无论他们之间有什么关系。</p>\n<p>不久，因为 <code>Garbage F</code> 和他的朋友 <code>Garbage E</code> 没有来自 <code>GC Root</code> 的直接/间接引用，他们就会被 gc 回收掉了。</p>\n<blockquote>\n<p>想想看，如果在这个图中 <code>Object C</code> 建立了到 <code>Garbage F</code> 的一个引用，会发生什么？  </p>\n</blockquote>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>在聊 <code>GC Root</code> 是什么之前，你可能需要知道引用是什么。  </p>\n<p>举个例子:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object a = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = b;</span><br><span class=\"line\"><span class=\"keyword\">assert</span> a == c;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码运行不会报错，因为他们是在内存中是同一个对象。这是如何做到的呢？ JVM 并没有把这个对象拷贝很多次，因为他赋值并不是赋一个对象，而是引用。  </p>\n<p>这是因为对象是分配在堆里的，<code>new Object()</code> 返回的实际上是一个<code>引用</code>。引用就是指向对象的钥匙。  </p>\n<p>打个比方说， <code>网盘链接</code> 可以指向一个资源，你把链接给了别人并不是直接把资源发送给了别人，只是给了一个指向资源的钥匙，它可以通过这个钥匙获取到资源。  </p>\n<p>再来看一个例子  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt; someObject = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">someObject.add(objectA);</span><br><span class=\"line\">someObject.add(objectB);</span><br></pre></td></tr></table></figure>\n\n<p>显然，以上的代码将两个对象塞到了一个容器里，看起来是这样的：</p>\n<p><img src=\"https://upload.cc/i1/2021/11/05/7QuXlj.png\">   </p>\n<p>当然，不只是塞到容器才有引用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    A anotherA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">A b = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">a.anotherA = b;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload.cc/i1/2021/11/06/0Dv9Rg.png\"></p>\n<p>另外，Java 还有多种引用类型来帮助你实现更加灵活的对象生命周期管理。本文主要讨论的是强引用的情况，并不考虑弱引用类型，有兴趣的读者可以自行了解( WeakReference , PhantomReference , SoftReference )。</p>\n<p>如果你无法理解引用也没有问题，只需要理解成一个对象存了另一个对象之间建立的关系就好了。  </p>\n<h2 id=\"GC-Root\"><a href=\"#GC-Root\" class=\"headerlink\" title=\"GC Root\"></a>GC Root</h2><p>GC Root 是垃圾收集器进行分析的起点，不会被回收，而且类型有很多种<del>但是基本上不用特地记</del>，主要就注意这几个。</p>\n<ol>\n<li>局部变量，参数之类的 就是指方法里面声明的那些变量，不过出了方法就没了</li>\n<li>类静态字段或常量 比如 <code>private static final XX xx = new XX()</code> </li>\n<li>虚拟机内部引用</li>\n<li>被同步锁持有的对象</li>\n</ol>\n<h1 id=\"来个例子\"><a href=\"#来个例子\" class=\"headerlink\" title=\"来个例子\"></a>来个例子</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;OOMObject&gt; oomObjects = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">114514</span> ; i++) &#123;</span><br><span class=\"line\">    oomObjects.add(<span class=\"keyword\">new</span> OOMObject());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>试图说明程序内存溢出的原因。</p>\n<h1 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h1><p>总之，写代码的时候要注意一些潜在的，未消除的引用，虽然一般碰不到。</p>\n",
            "tags": [
                "tech"
            ]
        },
        {
            "id": "https://nstd.sfclub.cc/2021/10/01/Writting-A-Compiler-1/",
            "url": "https://nstd.sfclub.cc/2021/10/01/Writting-A-Compiler-1/",
            "title": "从零开始的编译器生涯",
            "date_published": "2021-10-01T14:12:37.000Z",
            "content_html": "<p>近日一屑高二学生无聊动手写起了编译器….这是他的珍贵作战记录    </p>\n<span id=\"more\"></span>\n\n<h1 id=\"0x01-理论基础\"><a href=\"#0x01-理论基础\" class=\"headerlink\" title=\"0x01 理论基础\"></a>0x01 理论基础</h1><p>我摊牌，我没有看任何编译原理相关的书籍，因此这篇文章并不能作为严格的参考资料，甚至很多地方可能是错误的。  </p>\n<p>编译器，编译器，就是把高级语言的代码编译成另一种形式（class，asm，二进制，IR），而他在编译成另一种形式之前大概需要过这么个流程:</p>\n<p>Lex -&gt; Parse -&gt; Compile  </p>\n<p>接下来逐步讲解这个过程。</p>\n<h2 id=\"Lexer\"><a href=\"#Lexer\" class=\"headerlink\" title=\"Lexer\"></a>Lexer</h2><p>就是分词器，输入用户提供的代码接着把他分成 <code>tokens</code>，也就是 <code>tokenstream</code>。<br>你肯定看不懂上面那句话的意思，让我们来点实例：<br><img src=\"https://upload.cc/i1/2021/10/01/gGftuh.png\" alt=\"image\"><br><code>a.value</code> 里的那个 <code>ArrayList</code> 就是一个 <code>token stream</code>，<code>str</code> 是被解析的代码。不难发现，语句被 Lexer 按顺序进行了分类以及数据的分割，如 <code>a</code> 被识别为了一个 <code>Identify</code> (标记)。 </p>\n<p>因此也可以归纳出来 <code>Token</code> 大致的代码长啥样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Token</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> line;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Parser\"><a href=\"#Parser\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p>Lexer 从源码中提取出 <code>token stream</code> 后将会交给 <code>Parser</code> 处理，它负责对 <code>token stream</code> 进行解析，生成一个 <code>AST (Abstract Syntax Tree)</code>，也就是 <code>抽象语法树</code>。  </p>\n<p><img src=\"https://upload.cc/i1/2021/10/01/nVE3wl.png\"><br>这张图直观的描述了这一过程，你可以看到它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。  </p>\n<p>接着，AST 将会丢给代码生成器用于生成代码，但是一般会先对 AST 进行优化，例如 <code>常量折叠</code></p>\n<h2 id=\"Static-Analyzing\"><a href=\"#Static-Analyzing\" class=\"headerlink\" title=\"Static Analyzing\"></a>Static Analyzing</h2><p>但在这之前，我们还有一些问题要解决。<br><del>其实这玩意我是和 Parser 写一块的</del><br>试想一下，如果有这样一行代码：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = love + cats</span><br></pre></td></tr></table></figure>\n<p>代码生成器如何知道 <code>love</code> 和 <code>cats</code> 是什么？ 在 Parser 的眼里，他们只是 <code>Identifier</code>，然而它们之间不能相加减。  </p>\n<p>在这种时候，Parser 需要预先建立一个符号表，这样他才能找出 <code>love</code> 和 <code>cats</code> 究竟是什么以及是否能够编译。</p>\n<p>同理，下面的代码也一样需要这一过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(List&lt;String&gt; args)</span></span>&#123; <span class=\"comment\">// 此处 Parser 将会分析出 java.lang.String 和 java.util.List</span></span><br><span class=\"line\">  NullCat nc = <span class=\"keyword\">new</span> SBNC(); <span class=\"comment\">// 按照 Java 的逻辑，此处没有导入（或同包）于是会产生错误，因为Parser找不到 SBNC / NullCat</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Code-Generation\"><a href=\"#Code-Generation\" class=\"headerlink\" title=\"Code Generation\"></a>Code Generation</h2><p>接着是生成代码！<br>一般编译器都会输出一种 <code>IR (Intermediate Representation)</code> 码，而他的作用则是一种中间表示。<br>例如，如果你输出 LLVM 的 IR 码，那么接下来你的编译工作（win,x64,linux,…jvm）就可以交给 LLVM 来完成，而像 <code>LLVM</code> 这样负责最后这一步骤的我们称之为 <code>编译器的后端</code></p>\n<p>使用这一种方法有几个好处：</p>\n<ul>\n<li>它可以使得开发者更专注于 <code>语言设计</code> 而不用过多的考虑 <code>优化</code>，因为大多数编译器后端会帮你完成这件事情 <del>，除非你直接输出汇编那就得你自己负责优化了</del>。</li>\n<li>IR 是中间表示，它可以按照相同的语义编译出不同平台，不同架构的代码，大大节省了开发者时间</li>\n<li>…</li>\n</ul>\n<p> 处于个人习惯，我选择了 Java 的字节码作为 “IR”，他将会被 JVM 加载并在运行过程中收集数据被更好的优化以及可以享受和 Java 互操作，跨平台的优势。</p>\n<h1 id=\"0x02-实践\"><a href=\"#0x02-实践\" class=\"headerlink\" title=\"0x02 实践\"></a>0x02 实践</h1><p>知道了这些理论，我们立即可以开始编写我们的第一个 Lexer 了。</p>\n<p>这是我们这一大章节的目标代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using java.util.List</span><br><span class=\"line\"></span><br><span class=\"line\">fn main(args: List&lt;String&gt;)&#123;</span><br><span class=\"line\">  println &quot;hello world!&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，让我们开始吧！<br>下文将会有大量代码，为了可读性，我会删掉一些无关紧要的部分。</p>\n<h2 id=\"Lexer-1\"><a href=\"#Lexer-1\" class=\"headerlink\" title=\"Lexer\"></a>Lexer</h2><p>我的 Lexer 分为两步：<code>fuzzyTokenize</code> 和 <code>tokenize</code>。<br>实际上这是取决于做法的，有正则转 DFA（状态机）的，也有直接 <code>charStream</code> 的。</p>\n<p>我选择了第二种，因为我认为使用正则的代码可读性比较糟糕，不易于维护。那么，让我们开始做一些准备工作…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lexer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String fileName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String rawContent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Lexer</span><span class=\"params\">(String content,String fileName)</span> </span>&#123;</span><br><span class=\"line\">        rawContent = content.replaceAll(<span class=\"string\">&quot;//.*|(\\&quot;(?:\\\\\\\\[^\\&quot;]|\\\\\\\\\\&quot;|.)*?\\&quot;)|(?s)/\\\\*.*?\\\\*/&quot;</span>, <span class=\"string\">&quot;$1 &quot;</span>); <span class=\"comment\">// remove comments.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName=fileName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从构造方法接受源代码和文件名并且删除注释。你可能会问文件名用来干啥，那当然是用来报错的～<br>接着，还有一个 <code>LexedNode</code> 用来表示 <code>fuzzyTokenize</code> 后的产物。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LexedNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> NodeType type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 初始化和getter...</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">NodeType</span> </span>&#123;</span><br><span class=\"line\">        IDENTIFIER,SYMBOL,KEYWORD,OPERATOR,</span><br><span class=\"line\">        LINE_SEPERATOR,</span><br><span class=\"line\">        LITERAL_STRING,LITERAL_NUMBER</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这就是一个最基本的 <code>token</code>! 在后文，我们将会进行第二次 <code>tokenize</code> 使它变得更详细。  </p>\n<p>准备好了，开始写吧！首先是一个状态机：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;LexedNode&gt; <span class=\"title\">fuzzyTokenize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] charStream = rawContent.toCharArray();</span><br><span class=\"line\">    List&lt;LexedNode&gt; nodes = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> line = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; charStream.length; i++) &#123; <span class=\"comment\">// 使用 fori 是为了循环时移动指针</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> now = charStream[i];</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (now) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\n&#x27;</span>:</span><br><span class=\"line\">              nodes.add(<span class=\"keyword\">new</span> LexedNode(NodeType.LINE_SEPERATOR,<span class=\"string\">&quot;\\n&quot;</span>))</span><br><span class=\"line\">              <span class=\"keyword\">continue</span>; <span class=\"comment\">// 此处使用 continue 立即跳到下一次循环</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nodes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是你的第一个 Lexer，可以先输出一下看看结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LINE_SEPERATOR</span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR</span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR</span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR</span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR</span><br></pre></td></tr></table></figure>\n\n<p>因为代码有五行，因此是五个 <code>LINE_SEPERATOR</code>。<br>只有换行符可不够，我们还要识别 <code>KEYWORD</code> ，也就是关键词。<br>然而关键词使用空格分割，因此我们可以这样做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(...)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27; &#x27;</span>:                </span><br><span class=\"line\">        inIdOrLiteral = !inIdOrLiteral;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inIdOrLiteral) &#123; <span class=\"comment\">// start collecting</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// end!</span></span><br><span class=\"line\">        String str = buffer.toString();</span><br><span class=\"line\">        identifierParse(str, nodes);</span><br><span class=\"line\">        buffer = <span class=\"keyword\">new</span> StringBuilder(); <span class=\"comment\">// compose</span></span><br><span class=\"line\">         <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 此处换行同理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Collect String or Identifier */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inIdOrLiteral) &#123;</span><br><span class=\"line\">        buffer.append(now);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以看到，我们引入了两个新的变量和一个方法，它们分别是 <code>inIdOrLiteral</code> 和 <code>buffer</code> 以及 <code>identifierParse</code>。</p>\n<p><strong>inIdOrLiteral</strong> 表示当前是否正在遍历一个 <code>Identifier</code> 或者一个字面量<br><strong>buffer</strong> 用于收集这个字面量，当然你也可以使用 <code>substring</code> 和 <code>charAt</code> 的方法<br><strong>identifierParse</strong> 是一个方法，他用于分类 Identifier。对于 <code>11</code>，他会分类成一个 <code>LITERAL_NUMBER</code>，对于 <code>not_a_keyword</code>，他会分类成一个 identifier，对于 <code>fn</code>，他会分类成一个 Keyword。</p>\n<p>还没完，天资聪颖的你肯定已经注意到了这里少了一样东西——我要怎么匹配最开头的一个 <code>using</code> ？ <code>using</code> 的前头可没有一个空格。<br>这时你可以回忆一下，在各种编程语言中作为 <code>Identifier</code> 的符号应该符合什么规则….是的，他们通常不会以运算符作为开头，以及他们不是一个关键字，因此我们还可以利用这个特性写出这样的代码:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         <span class=\"comment\">/* Other Symbols */</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (SYMBOL_OR_OPERATORS.contains(now）) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (inIdOrLiteral) &#123; <span class=\"comment\">// keyword</span></span><br><span class=\"line\">                 <span class=\"comment\">// now == a symbol,we should end this.</span></span><br><span class=\"line\">                 identifierParse(buffer.toString(), nodes);</span><br><span class=\"line\">                 buffer = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                 inIdOrLiteral = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (SYMBOLS.contains(now)) &#123;</span><br><span class=\"line\">                 nodes.add(<span class=\"keyword\">new</span> LexedNode(now, LexedNode.NodeType.SYMBOL));</span><br><span class=\"line\">                 <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (OPERATORS.contains(now)) &#123;</span><br><span class=\"line\">                 nodes.add(<span class=\"keyword\">new</span> LexedNode(now, LexedNode.NodeType.OPERATOR));</span><br><span class=\"line\">                 <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> LexerException(fileName+<span class=\"string\">&quot;: Unknown char: &quot;</span> + now+<span class=\"string\">&quot; line: &quot;</span>+line);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             inIdOrLiteral = <span class=\"keyword\">true</span>; <span class=\"comment\">// not symbol &amp; not identifier</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Collect String or Identifier */</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (inIdOrLiteral) &#123;</span><br><span class=\"line\">     buffer.append(now);</span><br><span class=\"line\">     <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一段代码将会在匹配第一个字符没有遇到语言规定的操作符或者特殊符号的时候把 <code>inIdOrLiteral</code> 设置为 <code>true</code>。配合上面的代码，在遇到一个空格的时候他会结束收集并且尝试判断是什么。</p>\n<p>实际上应该是 <code>switch</code> 的任务但是写成 <code>if</code> 更加直观一些。  </p>\n<p>那么到现在，我们可以开始尝试代码了！这是 Lexer 的输出：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEYWORD using</span><br><span class=\"line\">IDENTIFIER java</span><br><span class=\"line\">OPERATOR .</span><br><span class=\"line\">IDENTIFIER util</span><br><span class=\"line\">OPERATOR .</span><br><span class=\"line\">IDENTIFIER List</span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">KEYWORD fn</span><br><span class=\"line\">IDENTIFIER main</span><br><span class=\"line\">SYMBOL (</span><br><span class=\"line\">IDENTIFIER args</span><br><span class=\"line\">OPERATOR :</span><br><span class=\"line\">IDENTIFIER List&lt;String&gt;</span><br><span class=\"line\">SYMBOL )</span><br><span class=\"line\">SYMBOL &#123;</span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">KEYWORD println</span><br><span class=\"line\"><span class=\"deletion\">- LITERAL_STRING hello world!</span></span><br><span class=\"line\"><span class=\"addition\">+ IDENTIFIER &quot;hello</span></span><br><span class=\"line\"><span class=\"addition\">+ IDENTIFIER world!&quot;</span></span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">SYMBOL &#125;</span><br><span class=\"line\">5: RIGHT_BRACKET &#125;</span><br></pre></td></tr></table></figure>\n\n<p>相比你已经注意到了，理应出现的 <code>LITERAL_STRING</code> 被两个 IDENTIFIER 代替了，这显然不是我们想要的结果。因此，我们要给 String 加入特 殊 支 持  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(now)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&quot;&#x27;</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; charStream[i - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;\\\\&#x27;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// string starts or end</span></span><br><span class=\"line\">                        inIdOrLiteral = !inIdOrLiteral;</span><br><span class=\"line\">                        stringMode = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!inIdOrLiteral) &#123;</span><br><span class=\"line\">                            stringMode = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                            <span class=\"comment\">// a new string!</span></span><br><span class=\"line\">                            nodes.add(<span class=\"keyword\">new</span> LexedNode(buffer.toString(), LexedNode.NodeType.LITERAL_STRING));</span><br><span class=\"line\">                            buffer = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    case &#x27; &#x27;:</span><br><span class=\"line\"><span class=\"addition\">+        if (stringMode) &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+            break;</span></span><br><span class=\"line\"><span class=\"addition\">+        &#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">- if (SYMBOL_OR_OPERATORS.contains(now)) &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+ if (SYMBOL_OR_OPERATORS.contains(now) &amp;&amp; !stringMode) &#123;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样我们就躲开了这个陷阱，完成了对于 String 的支持后，我们的 <code>fuzzyTokenize</code> 就做好了！</p>\n<blockquote>\n<p>关于 OPERATORS 和 SYMBOLS<br>一门语言里的符号很多，你绝对不会想把他们一个个 add 到 list 里面的，但你可以写一个 <a href=\"https://github.com/iceBear67/NullCatLang/blob/85a9b3234bcaab21451c0c6023f46d3599e5764d/src/main/java/io/ib67/lexer/Lexer.java#L11-L34\">loader</a> 来解决这个问题  </p>\n<p><img src=\"https://upload.cc/i1/2021/10/01/HwBhRN.png\"></p>\n</blockquote>\n<hr>\n<p>然后，是 <code>tokenizer</code>。<code>fuzzyTokenize</code> 输出的结果显然不足以交给 Parser 做解析，我们需要使i结果更加详细。</p>\n<p>好在经过 <code>fuzzyTokenize</code> 后代码已经被格式化成了比较模糊的 <code>Token Stream</code>，这一点使我们写第二次 tokenize 的时候会轻松很多，因为你不会再见到 <code>inIdOrLiteral</code> 和 <code>stringMode</code> 这种让人抓狂的东西了。</p>\n<p>首先，让我们从一个新的 Token 开始（你不会想和 LexedNode 混一块的）:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Token</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> line;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Type</span></span>&#123;</span><br><span class=\"line\">        IDENTIFIER(<span class=\"string\">&quot;&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        CLASS(<span class=\"string\">&quot;class&quot;</span>),FUNCTION(<span class=\"string\">&quot;fn&quot;</span>),ANNOTATION(<span class=\"string\">&quot;annotation&quot;</span>),FOR(<span class=\"string\">&quot;for&quot;</span>),WHILE(<span class=\"string\">&quot;while&quot;</span>),IF(<span class=\"string\">&quot;if&quot;</span>),USING(<span class=\"string\">&quot;using&quot;</span>)</span><br><span class=\"line\">        ,THIS(<span class=\"string\">&quot;this&quot;</span>),TRUE(<span class=\"string\">&quot;true&quot;</span>),FALSE(<span class=\"string\">&quot;false&quot;</span>),ELSE(<span class=\"string\">&quot;else&quot;</span>),VAR(<span class=\"string\">&quot;var&quot;</span>),NULL(<span class=\"string\">&quot;null&quot;</span>),PRINTLN(<span class=\"string\">&quot;println&quot;</span>), <span class=\"comment\">// KEYWORDS</span></span><br><span class=\"line\">        VAL(<span class=\"string\">&quot;val&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        LEFT_BRACE(<span class=\"string\">&quot;(&quot;</span>),RIGHT_BRACE(<span class=\"string\">&quot;)&quot;</span>),</span><br><span class=\"line\">        LEFT_BRACKET(<span class=\"string\">&quot;&#123;&quot;</span>),RIGHT_BRACKET(<span class=\"string\">&quot;&#125;&quot;</span>),</span><br><span class=\"line\">        LEFT_MID_BRACE(<span class=\"string\">&quot;[&quot;</span>),RIGHT_MID_BRACE(<span class=\"string\">&quot;]&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        COMMA(<span class=\"string\">&quot;,&quot;</span>),DOT(<span class=\"string\">&quot;.&quot;</span>),MINUS(<span class=\"string\">&quot;-&quot;</span>),PLUS(<span class=\"string\">&quot;+&quot;</span>),STAR(<span class=\"string\">&quot;*&quot;</span>),SLASH(<span class=\"string\">&quot;/&quot;</span>), <span class=\"comment\">// operators</span></span><br><span class=\"line\">        BREAK_LINE(<span class=\"string\">&quot;\\n&quot;</span>),ASSIGNMENT(<span class=\"string\">&quot;=&quot;</span>),EQUALS(<span class=\"string\">&quot;==&quot;</span>),SEMICOLON(<span class=\"string\">&quot;;&quot;</span>),AT(<span class=\"string\">&quot;@&quot;</span>),COLON(<span class=\"string\">&quot;:&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        LITERAL_STRING(<span class=\"string\">&quot;&quot;</span>),LITERAL_NUMBER(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// literals</span></span><br><span class=\"line\">        <span class=\"meta\">@Getter</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String def;</span><br><span class=\"line\">        Type(String def)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.def=def;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>比上文的 LexedNode 详细了很多——比如他主动去分类 keyword 了。<br>接着是一个 fori ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Pair&lt;String,List&lt;Token&gt;&gt; tokenize() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lexedNodes = fuzzyTokenize();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tokens = <span class=\"keyword\">new</span> ArrayList&lt;Token&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> line = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lexedNodes.size(); i++) &#123;</span><br><span class=\"line\">        LexedNode lexedNode = lexedNodes.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (lexedNode.getType()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LINE_SEPERATOR:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.BREAK_LINE,<span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">                line++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SYMBOL:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> KEYWORD:</span><br><span class=\"line\">                <span class=\"keyword\">var</span> type = Arrays.stream(Token.Type.values()).filter(e -&gt; e.getDef().equals(lexedNode.getContent())).findFirst().orElseThrow(()-&gt;&#123;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NullPointerException(lexedNode.toString());</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, type, type.getDef()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LITERAL_STRING:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.LITERAL_STRING, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LITERAL_NUMBER:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.LITERAL_NUMBER, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OPERATOR:</span><br><span class=\"line\">                <span class=\"comment\">// =</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> isEnd = (i == lexedNodes.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (lexedNode.getContent()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;=&quot;</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (isEnd) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> LexerException(fileName+<span class=\"string\">&quot;: Invalid syntax line &quot;</span>+line);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (lexedNodes.get(i + <span class=\"number\">1</span>).getType() == LexedNode.NodeType.OPERATOR &amp;&amp; lexedNodes.get(i + <span class=\"number\">1</span>).getContent().equals(<span class=\"string\">&quot;=&quot;</span>)) &#123; <span class=\"comment\">// ==</span></span><br><span class=\"line\">                            tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.EQUALS, <span class=\"string\">&quot;==&quot;</span>));</span><br><span class=\"line\">                            i = i + <span class=\"number\">1</span>; <span class=\"comment\">// skip next</span></span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.ASSIGNMENT, <span class=\"string\">&quot;=&quot;</span>));</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;.&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.DOT, <span class=\"string\">&quot;.&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;,&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.COMMA, <span class=\"string\">&quot;,&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.MINUS, <span class=\"string\">&quot;-&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.PLUS, <span class=\"string\">&quot;+&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.STAR,<span class=\"string\">&quot;*&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.SLASH,<span class=\"string\">&quot;/&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;;&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.SEMICOLON,<span class=\"string\">&quot;;&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;:&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line,Token.Type.COLON,<span class=\"string\">&quot;:&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IDENTIFIER:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.IDENTIFIER, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pair.of(fileName,tokens);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码并不难懂。在这个例子中，我们遍历来自 fuzzyTokenizer 的数据并且通过 switch 分类枚举来处理把他们转化成 <code>Token</code> 来表达并且存储到 <code>tokens</code>。对于 symbol 和 keyword，我们通过直接搜索 enum 内值的方法避免写出了像 <code>case OPERATOR</code> 里更糟糕的代码。  </p>\n<p><code>case OPERATOR</code> 里写成这样是为了双符号操作的支持，例如 <code>==</code></p>\n<p>回到原题，这次我们可以通过 tokenize 解析出这样的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1: USING using</span><br><span class=\"line\">1: IDENTIFIER java</span><br><span class=\"line\">1: DOT .</span><br><span class=\"line\">1: IDENTIFIER util</span><br><span class=\"line\">1: DOT .</span><br><span class=\"line\">1: IDENTIFIER List</span><br><span class=\"line\">1: BREAK_LINE </span><br><span class=\"line\">2: BREAK_LINE </span><br><span class=\"line\">3: FUNCTION fn</span><br><span class=\"line\">3: IDENTIFIER main</span><br><span class=\"line\">3: LEFT_BRACE (</span><br><span class=\"line\">3: IDENTIFIER args</span><br><span class=\"line\">3: COLON :</span><br><span class=\"line\">3: IDENTIFIER List&lt;String&gt;</span><br><span class=\"line\">3: RIGHT_BRACE )</span><br><span class=\"line\">3: LEFT_BRACKET &#123;</span><br><span class=\"line\">3: BREAK_LINE </span><br><span class=\"line\">4: PRINTLN println</span><br><span class=\"line\">4: LITERAL_STRING hello world!</span><br><span class=\"line\">4: BREAK_LINE </span><br><span class=\"line\">5: RIGHT_BRACKET &#125;</span><br><span class=\"line\">5: RIGHT_BRACKET &#125;</span><br></pre></td></tr></table></figure>\n<p>是不是详细了很多？接着我们就可以靠着这个写一个 Parser了</p>\n<h2 id=\"在-Parse-之前\"><a href=\"#在-Parse-之前\" class=\"headerlink\" title=\"在 Parse 之前\"></a>在 Parse 之前</h2><p>在 Parse 之前，我们需要先做一次 Static Analyzing。在这个阶段，Parser 会对文件里的类型和导入表作出关联，同时也是多文件编译的基础。</p>\n<h3 id=\"Metadata\"><a href=\"#Metadata\" class=\"headerlink\" title=\"Metadata\"></a>Metadata</h3><p>你不可能靠着所有人的源码来建立索引，而且源码中的无用信息太多了。<br>实际上，确定符号链接只需要这些信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CatMetadata</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassDef classDefinition = <span class=\"keyword\">new</span> ClassDef();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String,CatMetadata&gt; cachedUsings = <span class=\"keyword\">new</span> HashMap&lt;&gt;(); <span class=\"comment\">// 这是对于被解析对象才有的</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt; MethodSign&gt; methods = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, VariableDef&gt; fields = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关于 <code>ClassDef</code>, <code>MethodSign</code>, <code>VariableDef</code> 等信息本文不贴出，因为并不会影响观看体验。<br>如果有兴趣，可以在<a href=\"https://github.com/iceBear67/NullCatLang/tree/master/src/main/java/io/ib67/ast/decl\">这里</a>找到他们相对应的具体代码  </p>\n</blockquote>\n<p>以及一个编译器全局索引，用 FQDN 确定唯一性的 Map:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Global</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String,CatMetadata&gt; GLOBAL_METADATAS = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> CatMetadata <span class=\"title\">forClass</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          * Scan compiler classPaths</span></span><br><span class=\"line\"><span class=\"comment\">          */</span></span><br><span class=\"line\">         <span class=\"keyword\">var</span> meta = NullCatCompiler.solveMeta(str);</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(meta!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             GLOBAL_METADATAS.put(str, meta);</span><br><span class=\"line\">         &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">             meta = NullCatCompiler.solveMeta(<span class=\"string\">&quot;java.lang.&quot;</span> + str);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> meta;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>准备就绪，我们来单独拿出一个类作为 <code>MetadataGenerator</code> 状态机  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequiredArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MetadataGenerator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String fileName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Token&gt; tokens;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> CatMetadata cm = <span class=\"keyword\">new</span> CatMetadata();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着，是提取数据的部分:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CatMetadata <span class=\"title\">gen</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tokens.size(); i++) &#123;</span><br><span class=\"line\">        Token now = tokens.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> end = (i==tokens.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">        Token next = end?<span class=\"keyword\">null</span>:tokens.get(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(now.getType())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> USING:</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!end)&#123;</span><br><span class=\"line\">                    i=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> clazz = readAsStringUntilLB();</span><br><span class=\"line\">                    cm.getCachedUsings().put(clazz, Optional.ofNullable(CatMetadata.Global.forClass(clazz)).orElseThrow(()-&gt;<span class=\"keyword\">new</span> ParseException(<span class=\"string\">&quot;Can&#x27;t find clazz &quot;</span>+clazz)));</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    throwEOF();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> FUNCTION:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (end) &#123;</span><br><span class=\"line\">                    throwEOF();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// fn main()&#123;&#125;</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(next.getType() != Token.Type.IDENTIFIER)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ParseException(fileName+<span class=\"string\">&quot;: Unexcepted &quot;</span>+next.getType()+<span class=\"string\">&quot; at line &quot;</span>+now.getLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                String methodName = next.getContent();</span><br><span class=\"line\">                i=i+<span class=\"number\">1</span>; <span class=\"comment\">// Move Pointer to (</span></span><br><span class=\"line\">                MethodSign sign = readMethodSign(methodName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode()))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ParseException(fileName+<span class=\"string\">&quot;: Duplicated method: &quot;</span>+sign+<span class=\"string\">&quot; at line &quot;</span>+now.getLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cm.getMethods().add(sign);</span><br><span class=\"line\">                skipCodeBlocks();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cm;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在这个循环当中，我们通过获取到 Token 的类型来判定需要做的操作，这是基于语言设计定义来做的—— 例如 <code>fn</code> 的后面必然是一个方法签名，而不可以是别的。最终 <code>MetadataGenerator</code> 将会返回一个 CatMetadata 以供后续操作。</p>\n<p>因此，这一阶段我们也可以发掘出类型错误和大的语法错误。</p>\n<h3 id=\"与-Java-的世界\"><a href=\"#与-Java-的世界\" class=\"headerlink\" title=\"与 Java 的世界\"></a>与 Java 的世界</h3><p>我们需要和 Java 交互，因此我们需要给 <code>Class</code> 建立 <code>CatMetadata</code> 。好在这很简单，因为 CatMetadata 需要的所有数据都可以通过反射获取，这里提供一段参考代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassMetaPathImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">MetaPath</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassLoader classLoader;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CatMetadata <span class=\"title\">findClass</span><span class=\"params\">(String clazz)</span> </span>&#123;</span><br><span class=\"line\">        CatMetadata cm = <span class=\"keyword\">new</span> CatMetadata();</span><br><span class=\"line\">        Class&lt;?&gt; claz = Util.runCatching(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Class.forName(clazz,<span class=\"keyword\">false</span>,classLoader);</span><br><span class=\"line\">        &#125;).getResult();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(claz==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Field declaredField : claz.getDeclaredFields()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Modifier.isPublic(declaredField.getModifiers())) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            VariableDef def = <span class=\"keyword\">new</span> VariableDef(declaredField.getType().getCanonicalName(),declaredField.getName());</span><br><span class=\"line\">            cm.getFields().put(declaredField.getName(),def);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Method declaredMethod: claz.getDeclaredMethods())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Modifier.isPublic(declaredMethod.getModifiers()))<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            MethodSign sign = <span class=\"keyword\">new</span> MethodSign(declaredMethod.getName(), (ArrayList&lt;String&gt;) Arrays.stream(declaredMethod.getParameterTypes()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList()));</span><br><span class=\"line\">            cm.getMethods().add(sign);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ClassDef cdf = <span class=\"keyword\">new</span> ClassDef();</span><br><span class=\"line\">        cdf.setClassName(clazz);</span><br><span class=\"line\">        cdf.setSuperclass(claz.getSuperclass()==<span class=\"keyword\">null</span>?<span class=\"keyword\">null</span>:claz.getSuperclass().getCanonicalName());</span><br><span class=\"line\">        cdf.setInterfaces(Arrays.stream(claz.getInterfaces()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList()));</span><br><span class=\"line\">        cm.setClassDefinition(cdf);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>静态分析结束后，我们就要准备开始生成 AST 了。</p>\n<blockquote>\n<p>附<br>我们从 token 流中获取数据，并且根据类型进行匹配——但我们其实没有用到状态<br>仔细看，你会发现这个东西：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        i=i+1; // Move Pointer to (</span><br><span class=\"line\"><span class=\"addition\">+        MethodSign sign = readMethodSign(methodName);</span></span><br><span class=\"line\">        if(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode()))&#123;</span><br><span class=\"line\">            throw new ParseException(fileName+&quot;: Duplicated method: &quot;+sign+&quot; at line &quot;+now.getLine());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cm.getMethods().add(sign);</span><br><span class=\"line\"><span class=\"addition\">+        skipCodeBlocks();</span></span><br><span class=\"line\">        continue;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>是不是有些象是 DSL？<br>这其实归咎于类字段中那个不起眼的 <code>int i = 0</code>，它使得 for 循环的指针可以被整个类里的方法所共享。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String <span class=\"title\">readAsStringUntilLB</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 一只读，读到一个换行为止并且收集成字符串</span></span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> a = i; tokens.get(a).getType()!= Token.Type.BREAK_LINE;a++)&#123;</span><br><span class=\"line\">        sb.append(tokens.get(a).getContent());</span><br><span class=\"line\">        b=a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在经过更加详细的 tokenize 之后，代码实际上变得更加可观了，</p>\n</blockquote>\n<h2 id=\"Parser-1\"><a href=\"#Parser-1\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p>先占个坑位～</p>\n",
            "tags": [
                "tech"
            ]
        },
        {
            "id": "https://nstd.sfclub.cc/2021/03/13/%E4%BD%BF%E7%94%A8-cproxy-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/",
            "url": "https://nstd.sfclub.cc/2021/03/13/%E4%BD%BF%E7%94%A8-cproxy-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/",
            "title": "使用 cproxy 对程序进行透明代理",
            "date_published": "2021-03-13T14:57:30.000Z",
            "content_html": "<p>在 Windows 下，说到 <code>透明代理</code> ，你可能会想到 <code>Proxifier</code> , <code>SSTap</code>, <code>Mellow</code><br>但在 Linux 下，你可能会想到 <code>proxychains</code> 然后再想到 <code>proxychains</code> 不能代理 static-linked 的程序。  </p>\n<span id=\"more\"></span>\n<h1 id=\"为什么-ProxyChains-NG-不能代理静态连接的程序\"><a href=\"#为什么-ProxyChains-NG-不能代理静态连接的程序\" class=\"headerlink\" title=\"为什么 ProxyChains(NG) 不能代理静态连接的程序\"></a>为什么 ProxyChains(NG) 不能代理静态连接的程序</h1><p>ProxyChains NG 通过一个预加载的共享库来hook到网络相关的函数(比如: connect,getaddrinfo)上，接着他就可以转发这些流量。<br>缺点似乎显而易见，如果只是通过 <a href=\"https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick\">LD_PRELOAD</a> 来进行透明代理，那么这招对于静态连接的程序是无用的（比如说 Go 程序..)<br>其次，ProxyChains 只支持 TCP，这可能导致无法转发 DNS 流量 -&gt; DNS 流量泄漏。  </p>\n<h1 id=\"cproxy-是什么\"><a href=\"#cproxy-是什么\" class=\"headerlink\" title=\"cproxy 是什么\"></a>cproxy 是什么</h1><p><a href=\"https://github.com/NOBLES5E/cproxy\">cproxy</a> 也是透明代理，作用和 proxychains 类似。<br>原理上与 proxychains 不同，它使用 <code>cgroup</code> 进行对程序的代理 <del>，不过配置起来还有点麻烦</del><br>本文将会教您在您的Linux PC上使用 cproxy，截至本文发布之前，cproxy似乎只支持 Linux。  </p>\n<h2 id=\"下载-cproxy\"><a href=\"#下载-cproxy\" class=\"headerlink\" title=\"下载 cproxy\"></a>下载 cproxy</h2><p>官方推荐的方法是: 直接用 <code>cargo</code>    </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo install cproxy</span><br></pre></td></tr></table></figure>\n\n<p>如果没有 cargo 可以在 <a href=\"https://github.com/NOBLES5E/cproxy/releases\">Release</a> 上下载压缩包。<br>解压压缩包，可能会发现有两个可执行文件，不过似乎只留一个就好了。  </p>\n<h2 id=\"安装-cproxy\"><a href=\"#安装-cproxy\" class=\"headerlink\" title=\"安装 cproxy\"></a>安装 cproxy</h2><p>先来试一试 cproxy！  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cproxy --port &lt;本地代理端口&gt; -- curl ip.sb</span><br></pre></td></tr></table></figure>\n\n<p>( ｀д′) 失败了<br>如果你和我一样，在port上写了 socks5 的代理端口，那么你就被坑了。<br>笔者填入 geph 的 HTTP 代理端口时是可以成功的，但是使用 v2ray 的s5/http端口都无法使用。<br>这是因为 cproxy 需要<a href=\"https://github.com/NOBLES5E/cproxy/wiki/Example-setup-with-V2Ray\">修改 v2ray 的配置</a>进行兼容，<a href=\"https://github.com/zfl9/ipt2socks\">如果你不想去改配置</a>  </p>\n<p>在确保可以使用 cproxy 后，我们来配置 <code>alias</code>。<br>将以下内容写到 <code>~/.bashrc</code>，记得自己修改一些部分。  </p>\n<pre><code class=\"bash\">alias &quot;px&quot;=&quot;/path/to/cproxy --port &lt;your-local-proxy-port&gt; --&quot;\n</code></pre>\n<p>例如我的配置：</p>\n<pre><code class=\"bash\">alias &quot;px&quot;=&quot;/bin/cproxy --port 60080 --use-tproxy -- &quot; # 60080 是ipt2socks的默认监听端口。\n</code></pre>\n<p>保存后，使用 <code>source ~/.bashrc</code> 载入，试试 <code>px curl ip.sb</code>，看看是否成功。  </p>\n<h2 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h2><p>每次使用都要 sudo ，还是挺烦人的吧…<br>对于这种情况，也可以考虑使用有后台常驻的 <a href=\"https://github.com/springzfx/cgproxy\">cgproxy</a>，但本文不做介绍，有兴趣可以自己了解。  </p>\n",
            "tags": [
                "tech",
                "linux"
            ]
        }
    ]
}