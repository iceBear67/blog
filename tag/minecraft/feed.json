{
    "version": "https://jsonfeed.org/version/1",
    "title": "nstd::out • All posts by \"minecraft\" tag",
    "description": "iceBear 的博客",
    "home_page_url": "https://ib67.io",
    "items": [
        {
            "id": "https://ib67.io/2022/12/19/Getting-Started-With-Minestom/",
            "url": "https://ib67.io/2022/12/19/Getting-Started-With-Minestom/",
            "title": "上手 Minestom: 新时代 Minecraft 服务端实现",
            "date_published": "2022-12-19T13:20:35.000Z",
            "content_html": "<p>笔者观望 <a href=\"https://github.com/Minestom/Minestom\">Minestom</a> 已经有一段时间了. 以前他的线程模型还不够成熟, 曾经联系 @TheMode 想帮他翻译那块的文档结果鸽了.<br>正好, 今天摸鱼的时候看了一眼 Minestom 官方, 发觉现在或许是时候上手尝试一下了.</p>\n<p>简中圈子里吹 Minestom 的很多, 然而真正上手 / 普及 Minestom 开发的很少. 官方文档已经足够详尽, 因此本篇博文只作引路贴, 希望对 Minestom 感兴趣的你自己上手尝试.</p>\n<span id=\"more\"></span>\n\n<h1 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a>配置环境</h1><p>Minestom 主要托管在 <a href=\"https://jitpack.io/\">JitPack</a> 上.</p>\n<p><code>build.gradle:</code></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    maven &#123;</span><br><span class=\"line\">        name <span class=\"string\">&#x27;JitPack&#x27;</span></span><br><span class=\"line\">        url <span class=\"string\">&#x27;https://jitpack.io&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.github.Minestom:Minestom:VERSION&#x27;</span> <span class=\"comment\">// 版本号自己去 JitPack 上面找</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>静静等待依赖图下载完成, 下载的过程中, 我们不难发现一些老熟人.</p>\n<h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><p>Minestom 启动<code>实现</code>很简单, 只需要两行就搞定了.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mc = MinecraftServer.init();</span><br><span class=\"line\">    mc.start(<span class=\"string\">&quot;0.0.0.0&quot;</span>, <span class=\"number\">25565</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个空的 Minestom <code>实现</code>在一秒钟内就能初始化完毕.<br>打开 Minecraft, 添加一个 <code>localhost</code> 到服务器列表中就能看到你的新 Minestom 服务器.</p>\n<p><img src=\"https://i.ibb.co/m0j5BN8/image.png?80\" alt=\"Minestom in ServerList\"></p>\n<blockquote>\n<p>注意: Minestom 语境下的 <code>实例</code> 和 <code>实现</code> 可能和你想象中的不一样<br>例如: <code>实现/Implementation</code> 是基于 Minestom 开发的服务端软件, 而 <code>实例/Instance</code> 不只指对象.</p>\n</blockquote>\n<p>你很快就会发现你卡在登入中. 先别急着去 Issues 找骂, 看看日志怎么说:</p>\n<p><img src=\"https://i.ibb.co/q9xcpxY/image.png\" alt=\"Logs\"></p>\n<p><code>You need to specify a spawning instance in the PlayerLoginEvent</code> 嗯… 有意思.<br>如果想加入我们刚刚创建的新鲜 Minestom 实现, 我们首先要设置玩家加入的 <code>实例</code>. 那么, 实例是什么?</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><blockquote>\n<p>Instances are what replace “worlds” from Minecraft vanilla, those are lightweight and should offer similar properties. There are multiple instances implementation, currently InstanceContainer and SharedInstance (both are explained below)</p>\n<p>–<a href=\"https://wiki.minestom.net/world/instances\"><em>The Minestom Wiki</em></a></p>\n</blockquote>\n<p>简单的说, 在 Minestom 的世界里, <code>实例</code> 和我们先前在 Bukkit / Forge 上开发时的 <code>世界</code> 是相同的概念. 不同的是, 比起世界来说, 一个 <code>实例</code> 通常更加轻量一些.</p>\n<p>那么怎么创建实例呢? 你可能会发现你刚刚得到的 <code>MinecraftServer</code> 对象除了能监听端口什么都不会干, 这是因为 Minestom 的大部分功能…</p>\n<p><img src=\"https://i.ibb.co/kX4C16G/image.png\" alt=\"Method Complements\"></p>\n<p>都被 <code>MinecraftServer</code> 的静态方法包装起来了. 我觉得这样做的意图可能是模拟其他 JVM 语言上 “<code>object</code>“ 的做法, <code>object</code> 类型的 “类” 默认就是单例, 因此这种类的静态方法不复存, 所有的方法和字段实际上都直接指向那个单例.<br>虽然在 Java 的语境下这样的做法难免令人<del>我</del>感觉奇怪, 但是这毕竟不是重点.</p>\n<p>我们拿到 <code>InstanceManager</code>, 然后创建一个新的实例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> manager = MinecraftServer.getInstanceManager();</span><br><span class=\"line\"><span class=\"keyword\">var</span> instanceContainer = manager.createInstanceContainer();</span><br></pre></td></tr></table></figure>\n\n<p>噢! 不要忘记设置默认的 <code>世界生成器</code>, 不然你会一直掉下去虚空的.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instanceContainer.setGenerator(unit -&gt;</span><br><span class=\"line\">    unit.modifier().fillHeight(<span class=\"number\">0</span>,<span class=\"number\">1</span>, Block.GRASS_BLOCK));</span><br></pre></td></tr></table></figure>\n\n<p>然后要注册一个事件监听器, 用于告诉 Minestom 我们想让玩家出生在什么地方.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MinecraftServer.getGlobalEventHandler().addListener(PlayerLoginEvent.class, evt -&gt;&#123;</span><br><span class=\"line\">    evt.setSpawningInstance(instanceContainer);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>但是! 虽然现在已经可以进入服务器了, 我们会出生在 <code>(0,0,0)</code>, 然后无尽掉虚空.<br>所以, 还需要额外补几行防止这种情况.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MinecraftServer.getGlobalEventHandler().addListener(PlayerSpawnEvent.class, evt -&gt;&#123;</span><br><span class=\"line\">    evt.getPlayer().teleport(<span class=\"keyword\">new</span> Pos(<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>启动服务器, 进去将会发现一大片草方块.</p>\n<p>或者, 你也可以稍微更换一些参数…</p>\n<p><img src=\"https://i.ibb.co/8cBNXBT/image.png\" alt=\"莫名其妙的压迫感\"></p>\n<p>Minestom 生成世界的速度很快(可能是懒加载而已), 你几乎感受不到平时在 Notchian 服上最常见的世界生成卡顿. (可能是因为空 Minestom 处理的数据比较少, Minestom 就算直接加载 Minecraft 地图速度也是远超 Notchian.)<br>虽然 Minestom 支持直接加载 Anvil 格式的存档, 但是官方文档没有提到要怎么做.</p>\n<h3 id=\"加载-Anvil-格式的地图\"><a href=\"#加载-Anvil-格式的地图\" class=\"headerlink\" title=\"加载 Anvil 格式的地图\"></a>加载 Anvil 格式的地图</h3><blockquote>\n<p>注: 以下使用的主要 API 被官方标记为不稳定</p>\n</blockquote>\n<p>不难发现, <code>createInstanceContainer</code> 其实有支持传入 <code>IChunkLoader</code> 的重载方法. 只需要搜索片刻…</p>\n<p>你就能找到 <code>AnvilLoader</code>.</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    var manager = MinecraftServer.getInstanceManager();</span><br><span class=\"line\"><span class=\"deletion\">-   var instanceContainer = manager.createInstanceContainer();</span></span><br><span class=\"line\"><span class=\"addition\">+   var instanceContainer = manager.createInstanceContainer(new AnvilLoader(&quot;/path/to/A New World&quot;));</span></span><br><span class=\"line\"></span><br><span class=\"line\">    instanceContainer.setGenerator(unit -&gt;</span><br></pre></td></tr></table></figure>\n\n<p>只需要这样, 就可以加载你的 Minecraft 地图了.</p>\n<p><img src=\"https://i.ibb.co/5BR9Mtv/image.png\" alt=\"半秒以内就齐刷刷闪出来了!!\"></p>\n<h1 id=\"聊天与命令\"><a href=\"#聊天与命令\" class=\"headerlink\" title=\"聊天与命令\"></a>聊天与命令</h1><p>Minestom 似乎内置一个简单的聊天功能实现 (连聊天格式都和原版一样), 处理信息的方法应该和在 Bukkit 上的相差不大, 只不过 Minestom <strong>大量</strong>运用了 Kyori 的 <a href=\"https://docs.adventure.kyori.net/\">Adventure API</a><del>我有点反胃</del>. 写代码时最好留个心眼在返回值上.</p>\n<p><img src=\"https://i.ibb.co/VBkX8Xk/image.png\" alt=\"`getUsername` 才是正解\"></p>\n<p>所以比较想提一嘴的是命令, 毕竟其他教程也有<del>自古以来</del>从命令入手写功能的习俗.</p>\n<p>注册一个新的命令很简单:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> commandNew = <span class=\"keyword\">new</span> Command(<span class=\"string\">&quot;new&quot;</span>);</span><br><span class=\"line\">commandNew.setDefaultExecutor((sender, context)-&gt;&#123;</span><br><span class=\"line\">    <span class=\"comment\">// your business logic...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">MinecraftServer.getCommandManager().register(commandNew);</span><br></pre></td></tr></table></figure>\n<p>接着你就可以在你的实现里用 <code>/new</code> 了, 正如你想象的那样运行. 这个命令框架看起来并不新奇, 笔者甚至觉得有些奇怪.</p>\n<p>不过, 上面给的例子只是为了你三行快速上手, 官方推崇的写法是这样的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo.commands;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> net.minestom.server.command.builder.Command;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCommand</span> <span class=\"keyword\">extends</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestCommand</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">&quot;my-command&quot;</span>, <span class=\"string\">&quot;hey&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// &quot;my-command&quot; 是这个命令的主要名字.</span></span><br><span class=\"line\">        <span class=\"comment\">// &quot;hey&quot; 是命令的别名, 使用 /hey 和 /my-command 是一样的.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后一样的套路: <code>MinecraftServer.getCommandManager().register(new TestCommand())</code><br>接着是, 有参数的情况:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo.commands;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> net.minestom.server.command.builder.Command;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.minestom.server.command.builder.arguments.ArgumentType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCommand</span> <span class=\"keyword\">extends</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestCommand</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">&quot;command&quot;</span>, <span class=\"string\">&quot;alias&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果没有匹配到其他 Executor 就回落到这上面.</span></span><br><span class=\"line\">        setDefaultExecutor((sender, context) -&gt; &#123;</span><br><span class=\"line\">            sender.sendMessage(<span class=\"string\">&quot;You executed the command&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 全部的默认参数类型都在 ArgumentType 类里</span></span><br><span class=\"line\">        <span class=\"comment\">// 这些静态工厂的参数是一些 `标识符`, 用于让程序分辨参数 (并且在 Minestom 内部用于创建节点)</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> numberArgument = ArgumentType.Integer(<span class=\"string\">&quot;my-number&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 最后, 定义指令的 语法. (Syntax)</span></span><br><span class=\"line\">        addSyntax((sender, context) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> number = context.get(numberArgument);</span><br><span class=\"line\">            sender.sendMessage(<span class=\"string\">&quot;You typed the number &quot;</span> + number);</span><br><span class=\"line\">        &#125;, numberArgument, ...more);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在埋头苦读上方源码之前, 不如看看官方文档是怎么解释的.</p>\n<blockquote>\n<p>All auto-completable commands should extend Command, each command is composed of zero or multiple syntaxes, and each syntax is composed of arguments</p>\n<p>If you find it confusing, here are a few examples:</p>\n<p><code>/health</code> 一条指令<br><code>/health set 50;</code> 一条指令和他的语法<br><code>set</code> 一小段字面量型的参数<br><code>~ ~ ~</code> 一<strong>个</strong>坐标参数</p>\n</blockquote>\n<p>一条命令由零个或多个 <code>语法</code> 构成, 每个 <code>语法</code> 又由一个或多个参数构成. 如果感到无法理解, 不如这样想:</p>\n<ul>\n<li>所谓的 <code>语法</code> 就是命令的一个基本样子.<br>比如: <code>/effect xxx give xxx</code> 是一条语法, 而 <code>/effect xxx give xxx 30 24</code> 因为后面多了两个参数就是一个新的语法.</li>\n<li>所以语法就规定了应该有哪些参数, 以及它们对应的类型.</li>\n</ul>\n<p> <img src=\"https://i.ibb.co/6bcw38v/image.png\" alt=\"上面命令补全回调触发的效果\"></p>\n<p>更多内容, 请转向 <a href=\"https://wiki.minestom.net/feature/commands\">官方文档 / Minestom Wiki</a></p>\n<h1 id=\"一些别的\"><a href=\"#一些别的\" class=\"headerlink\" title=\"一些别的\"></a>一些别的</h1><p>虽然它还是高度实验性的服务端, 但是它很有潜力一举代替 Spigot 成为支撑 RPG, 小游戏服务器的主流服务端, <del>这也说明这真的不怪Java, 别再说什么 C++ 重写性能翻3000%了</del> 因此, 现在开始学习如何使用是完全可取的, 因为本文所述的, 官方 Wiki 中包含的, 以及本身 API 架构不太可能再发生巨大变更.</p>\n<p>Minestom 不仅提供了一个更加模块化的 Minecraft 服务端事件, 而且也兼顾了性能和 API 的良好设计, 开放程度<a href=\"https://wiki.minestom.net/feature/map-rendering/glfwmaprendering\">远超 Spigot</a>. 但是在使用 Minestom 开发你的实现之前, 你要花更多精力在维持好程序的良好架构上, 不然就会 go die.<br><del>有人今天用minestom写东西写的一团糟我不说是谁</del> 所以, 我觉得如果不是很必要, 可以使用 Minestom 的 <a href=\"https://wiki.minestom.net/expansion/extensions\">扩展(插件)</a> API 和 <a href=\"https://wiki.minestom.net/expansion/scripting\">高度实验性的脚本</a> API.<br>这样做或许更加有利于 Minestom 的生态发展, 而最坏的情况就是大家都喜欢自己 hold 一个 Minestom, 谁也不服谁, 就好像那帮 Mod Loader 一样.<br>但是 Mod Loader 也各自多多少少有一些 Mod, 要是世界上光有 Mod Loader 没有 Mod 就真的成灾难了…</p>\n<h1 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h1><p>感谢你的观看, 欢迎在评论区留言.</p>\n",
            "tags": [
                "minecraft",
                "minestom",
                "guide"
            ]
        }
    ]
}