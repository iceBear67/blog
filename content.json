{"pages":[{"title":"关于 nstd::out","text":"Non-STandard Output 是 iceBear 的破事水博客。你可以在这里了解到 iceBear","link":"about/index.html"},{"title":"Lnks","text":"本博客名称： 非标准输出 HikariLan’s Blog贺兰星辰的博客 一实无言伏太的博客 一叶知秋 - 秋是悲欢离合，雨是一生错过 秋雨落的博客 LxNetLxns的博客LxnsNB czm的博客 - 记想记的东西 EvanLuo42’s Blog Zoyn’s Blog - 金融民工 冰星姐姐~ Cysime Moflu - 再不会遇见第二个时光","link":"links/index.html"},{"title":"空调房","text":"我们在此处安装了空调，您可以在此自由休憩。","link":"%E7%A9%BA%E8%B0%83%E6%88%BF/index.html"}],"posts":[{"title":"「9+」 Java 编译器插件教程 101","text":"写了上万行 Java 代码，相比你已经对 Java “木纳呆板”的语法恨之入骨了。 那么，有没有一种可能，我是说可能，我们可以给 Java 编译器写插件？ 如果你要在面包店里买面包，你最好跟店员说你要买哪块面包。本文所指的 Java 编译器 均为 OpenJDK 自带的那个 javac，而不是其他的前端编译器实现。 前言自从 Java 8 起，Oracle 就将插件系统引入了 javac 中，因此是可以写 Javac 插件的。 虽然写一个 Javac 插件并且修改代码是可能的，但是这方面的资料很少（国内就更少了），并且大多内容重复（教你写个 HelloWorld 然后就结束），其次 javac 的东西也不是很好摸，毕竟不是公开 API（ JDK 9+ 开始已经不暴露在外了）。 恰逢今年还没写技术类的博客，就拿来磨磨刀吧。 先从插件说起上文刚刚提到了一个词，插件。它其实正是 com.sun.source.util.Plugin。通过这个类，我们可以让 Javac 在编译时加载我们的代码。 加载了代码，那么做什么呢？所以我们立一个目标：给所有 @Jsonized 标注过的类都生成一个可以输出 json 的 toString() 方法。 什么意思呢？就比如说这样一个类： 12345678public class MyResponse { private final String message; private final boolean success; public MyResponse(String message, boolean success){ this.message = message; this.success = success; }} 然后你想把它序列化成 Json。 1234var response = new MyResponse(&quot;\\&quot;Success!\\&quot; Took me 114514 yr 1919810 m&quot;,false).toString();response.equals(&quot;&quot;&quot; {&quot;message&quot;: &quot;\\&quot;Success!\\&quot; Took me 114514 yr 1919810 m&quot;, &quot;success&quot;: false}&quot;&quot;&quot;); 又快又便捷，还不需要第三方类库，这就是我们的目标。 那么先把这个注解写出来吧！ 12345678910111213package org.inlambda.kiwi.magic;import java.lang.annotation.*;/** * Classes with this type can be serialized to json by their {@link #toString()} method. */@Retention(RetentionPolicy.RUNTIME)@Documented@Target(ElementType.TYPE)public @interface Jsonized { } 值得提一点就是这些编译器注解的 Retention 用 RetentionPolicy.SOURCE 也是可以的，但是以后可能运行期间我们需要识别到这些被修改过的类，所以设置为 RUNTIME。 接着是，实现 Javac 的 Plugin 接口！ 12345678910111213141516package org.inlambda.kiwi.magic.plugin;import com.sun.source.util.Plugin;public class KiwiJavacPlugin implements Plugin { @Override public String getName() { return &quot;Kiwi&quot;; // 插件的名字 } @Override public void init(JavacTask task, String... args) { // 插件初始化回调 System.out.println(&quot;Hello Kiwi&quot;); }} 但是它不让你过编译。 打通模块的穴位这怎么能忍！在默认包目录下创建一个 module-info.java。 然后我们写点东西进去。 12345module kiwi.magic.main { // module 后跟模块名，下文要用 requires jdk.internal.vm.compiler; requires jdk.compiler; requires java.naming;} 加入这些之后，还要配置一下构建工具的编译参数。 （本教程使用 Gradle, Maven/SBT 用户请自行摸索….） 1234567compileJava { options.compilerArgs &lt;&lt; &quot;--add-exports=jdk.compiler/com.sun.tools.javac.tree=kiwi.magic.main&quot; &lt;&lt; &quot;--add-exports=jdk.compiler/com.sun.tools.javac.code=kiwi.magic.main&quot; &lt;&lt; &quot;--add-exports=jdk.compiler/com.sun.tools.javac.util=kiwi.magic.main&quot; &lt;&lt; &quot;--add-exports=jdk.compiler/com.sun.tools.javac.api=kiwi.magic.main&quot; &lt;&lt; &quot;--add-exports=jdk.compiler/com.sun.tools.javac.processing=kiwi.magic.main&quot;} 这样就能过编译了！虽然 IDEA 仍然会划出红线，但是只要接受他的解决方案就好（形如 add XX to compiler option） 由于 IDEA 可能不会自动补全没有确定模块关系的类，教程可能会大量使用完整的类名或是指向 Java SE 8 Documentation 的引用链接。 配置 ServiceJavac 通过 Java SPI 发现插件，因此你需要写一个 Service 文件让他能够发现你。 在 src/main/resource/META-INF/services/com.source.util.Plugin 中写出： 12# 填写你的插件主类名，这是教程的例子。org.inlambda.kiwi.magic.plugin.KiwiJavacPlugin 但是还差一步。 加载插件Javac 也是一个 Java 程序，他是在他的运行时 classpath 里面寻找插件的。 而在 Gradle 中，annotationProcessor 就会被加入到编译器的 classpath 中。但我们不能用 annotationProcessor this ，因为 gradle 不允许，所以我们需要另外新建一个模块专门测试插件。 为了加载插件，应当确保 build.gradle 中有如下内容： 123456789dependencies { testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1' testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1' compileOnly(project(&quot;:magic&quot;)) annotationProcessor(project(&quot;:magic&quot;)) // 就是这个！}compileJava { options.compilerArgs &lt;&lt; '-Xplugin:Kiwi' } // Kiwi 是插件的名字 万事具备，开 assemble ！ 现在，我们已经让 Javac 加载了我们的代码，但这仅仅是个开始。为了实现 @Jsonized 的目标，我们还需要注入代码。 得到编译单元对 AST 下手，首先要拿到 CompilationUnit 而 Javac 通过 TaskEvent 将它传递给我们，因此我们要注册一个 com.sun.source.util.TaskListener 来收 TaskEvent。 123456@Overridepublic void init(JavacTask task, String... args) { // 插件初始化回调 System.out.println(&quot;Hello Kiwi&quot;); task.addTaskListener(new KiwiTaskListener(((BasicJavacTask) task).getContext()); // this!} KiwiTaskListener: 1234567891011121314151617181920212223242526package org.inlambda.kiwi.magic.plugin.jc;import com.sun.source.util.TaskEvent;import com.sun.source.util.TaskListener;import com.sun.tools.javac.util.Context;public class KiwiTaskListener implements TaskListener { private final Context context; public KiwiTaskListener(Context context) { this.context = context; } @Override public void started(TaskEvent e) { } @Override public void finished(TaskEvent e) { if (e.getKind() != TaskEvent.Kind.PARSE) { // 注意此处 return; } var compUnit = e.getCompilationUnit(); }} 编译流程:Java 编译器的几个阶段: COMPILATION PARSE – 构造抽象语法树 (AST) ENTER – 源码里的引用均已被解析 ANALYZE – 生成 AST 并用于分析错误 GENERATE – 为源码生成输出 (.class) ANNOTATION_PROCESSING - 注解处理器被唤起 ANNOTATION_PROCESSING_ROUND COMPILATION 因为我们的目标是修改代码（对编译器来说，也就是对抽象语法树下手），所以只需要关心 PARSE 阶段就好了。如果你对 “AST” 和 “PARSE” 的概念还不太了解，那么你可以先看看我的另一篇博客 获取 AST得到 CompilationUnit 后，我们便可以“访问”到对应的 class 了。 12345678910111213141516171819202122232425262728293031323334353637383940package org.inlambda.kiwi.magic.plugin.jc;import com.sun.source.tree.ClassTree;import com.sun.source.util.TreeScanner;import com.sun.tools.javac.tree.JCTree; //注意这些完整类名，如果你的 IDEA 补全不了尝试复制这些到 IDEA 里面去。import com.sun.tools.javac.tree.TreeMaker; import com.sun.tools.javac.util.Context;import com.sun.tools.javac.util.Names;import org.inlambda.kiwi.magic.plugin.gens.GenJsonToString;public class JsonizedTreeScanner extends TreeScanner&lt;Void, Context&gt; { @Override public Void visitClass(ClassTree node, Context ctx) { // 此处 Context 是类型参数里规定的 try { var maker = TreeMaker.instance(ctx); // 1 var name = Names.instance(ctx); // 2 var claz = (JCTree.JCClassDecl) node; // 3 if (node.getModifiers() .getAnnotations() .stream() .anyMatch(e -&gt; e.getAnnotationType() .toString() .equals(&quot;Jsonized&quot;))) { // 判断是否有 Jsonized System.out.println(&quot;Jsonized class found: &quot; + node.getSimpleName()); super.visitClass(node, ctx); } } catch (Throwable t) { System.err.println(t.getMessage()); for (StackTraceElement stackTraceElement : t.getStackTrace()) { System.out.println(stackTraceElement); // Javac 会屏蔽掉正常的报错输出，因此需要手动打印出来。 } } super.visitClass(node, ctx); return null; }} 接下来逐个讲解这些代码。 TreeMaker 是一个非常重要的组件，通过 TreeMaker 我们可以创建语法树的组件然后把它们插入到现有的语法树里，也就是修改代码。 Names 也是一个重要组件，因为它几乎就是符号表，虽然其本身是 Identifier ….。 JCTree.JCClassDecl 就是类在AST中的定义，我们接下来会讲解到它以及更多 JCTree 子类的应用。 同时，我们在 magic-test 模块中创建一个类用于测试 @Jsonized，但为了节约篇幅，类的代码不列出。 让我们的访客访问 CompilationUnit: 12345678@Overridepublic void finished(TaskEvent e) { if (e.getKind() != TaskEvent.Kind.PARSE) { // 注意此处 return; } var compUnit = e.getCompilationUnit(); compUnit.accept(new JsonizedTreeScanner(), context); // 此处 context 是上文类构造器依赖注入进来的} 尝试编译 magic-test，你应当能在 compileJava 阶段看到 Jsonized class found: XXX。 对 AST 动手动脚哎呀，你怎么动手动脚的！ 拿到了类定义，我们就可以访问类里的所有元素了！另外，JCTree 的子类通常是可以直接 toString() 出来的，你可以利用这一点查看编译的输出。 但在修改之前，得先了解一下 Javac 内部的 List 实现。 List in JavacJavac 不知道出于什么缘故，他自己有一个链表（com.sun.tools.javac.util.List&lt;A&gt;）的实现，而且他是不可变的。 这个链表不对外公开（因为 Oracle 官方网站也没有 Javadoc），所以不提供引用链接了。 此处介绍几个常用的方法。 List.nil()静态方法。顾名思义，空集。 List.of(A x1, A x2, A x3, A… rest)一个静态工厂，用于创建一个定长的 List. 一些类似 prepend 和 append 这样对元素操作的方法…他们都返回新的实例，因为 List&lt;A&gt; 是不可变的，小心别被坑了。 等等，那不定长的呢？于是我们还有一个类，他就是 com.sun.tools.javac.util.ListBuffer&lt;A&gt;。 ListBuffer&lt;A&gt; 是 List&lt;A&gt; 某种类似 Builder 的工具，他的 append 等方法始终返回他自己，用完之后可以 toList() 转换成 List&lt;A&gt;。 做好这些基础知识的准备工作，我们终于，终于，终于可以开始动工了。 访问类里的元素 JCClassDecl 并没有严格区分开来方法和字段，他们都是 member。然而 getMembers() 是只读的（因为 List&lt;A&gt; 不可变），所以我们要绕开 getMembers() 直接访问到后面的字段。 绕也很简单… 没想到吧，Javac 里面就是这么乱。 接下来往 defs 里面插入方法即可。 构造方法然后插进去！这里我们就要请出刚刚提到过的大名鼎鼎的 TreeMaker 了！ 方法定义在 Javac 中就是 com.sun.tools.javac.tree.JCTree.MethodDecl，可以通过 TreeMaker#MethodDef 构造。 1234567891011121314// 建议把生成方法单独放起来public static JCTree.JCMethodDecl genMethod(TreeMaker maker, Names symbolTable, JCTree.JCClassDecl claz) { var method = maker.at(claz.pos).MethodDef( // 1 maker.Modifiers(Flags.PUBLIC | Flags.FINAL), // 方法的修饰符 symbolTable.fromString(&quot;toString&quot;), // 2 方法的名称 maker.Ident(symbolTable.fromString(&quot;String&quot;)), // 3 返回值类型 List.nil(), List.nil(), // 这三个先忽略再说 List.nil(), maker.Block(0, makeReturnJsonExpress(maker, symbolTable, claz)) // 方法体 , null ); return method;} 是不是有些迷糊？我们”娓娓道来”… at(claz.pos).MethodDef( 这句的意思是把 TreeMaker 当前的位置调整到目标类上然后再创建一个方法定义，不然可能会把方法生成到别的地方。（不过我没试过，其实方法和类关系是比较确定的，所以这个 pos 可能是给语句用的，因为语句有顺序。） symbolTable.fromString(&quot;toString&quot;) Names 提供了 fromString 方法用来创建对应的标识符/名字（Identifier）。 maker.Ident Ident 是一个很常用的方法，他可以接受一个 Names 然后输出一个 JCIdent。 而 JCIdent 恰好是 JCExpression，也就是 JCTree 的子类。 注意，从符号表拿类型并不需要把命名写完整（就好像上文写的不是 java.lang.String），如果要引入外部的类型只需要 maker.Import 即可 例如：maker.Import(maker.Ident(names.fromString(&quot;java.util.Objects&quot;)).getTree(), false); 这还只是方法的基本信息，接下来是方法体，也就是最关键的那部分。 但在写输出 Json 之前，我们不妨先写个 HelloWorld 试试。 123private static List&lt;JCTree.JCStatement&gt; makeReturnJsonExpress(TreeMaker maker, Names name, JCTree.JCClassDecl claz) { return List.of(maker.Return(maker.Literal(&quot;Hello Jsonized!&quot;)));} 然后我们回到上文，把新的方法体插入到类里。 123456789 var claz = (JCTree.JCClassDecl) node; if (node.getModifiers().getAnnotations().stream().anyMatch(e -&gt; e.getAnnotationType().toString().equals(&quot;Jsonized&quot;))) { System.out.println(&quot;Jsonized class found: &quot; + node.getSimpleName()); claz.def = claz.def.append(genMethod(maker,name,claz)); // THIS super.visitClass(node, ctx); }} catch (Throwable t) { System.err.println(t.getMessage()); 尝试编译 magic-test 模块并且查看编译输出，如果你没有干坏事的话应该能看到 @Jsonized 标注过的类里多出来一个 public final String toString()，并且代码体正是 return &quot;Hello Jsonized!&quot;;。 (由于我的 Jsonized 用的是 RetentionPolicy.SOURCE，所以注解编译后就被抹除掉了) AST 的常用姿势到上一节，你已经成功的： 让 Javac 加载你的代码 对特定注解标志过的类添加代码 那么这一节，我们着重讲解一些常用的操作以及更多基础知识。 从获取字段开始为了序列化出所有字段，我们首先需要知道我们的类里有哪些字段。 幸好，使用 Stream 就可以很轻松地做到这件事: 12345var nameToVar = claz.getMembers().stream() .filter(e -&gt; e.getKind() == Tree.Kind.VARIABLE) // 其实这个可能可以省略 .filter(e -&gt; e instanceof JCTree.JCVariableDecl) .map(e -&gt; (JCTree.JCVariableDecl) e) .collect(Collectors.toMap(e -&gt; e.getName(), e -&gt; e.getType())); 产出一个 Map&lt;Names, JCTree&gt;。JCTree 就是类定义，此处为 JCVariableDecl 有了这样一个 nameToVar 之后，我们就可以构造 Json 了。 拼接字符串与二元表达式哪个男孩不想体验一下二元运算符呢？ “+” 是一个二元运算符，它接受两个参数: a 和 b 并且产出一个结果。 在 Java 里，我们是这样写的：a + b 那么如果更多参数呢？ 以此类推，可以构造出一个很长很长的二元树，而这正好是我们今天要做的事情。 先从拼接字符串开始，举个例子：a + &quot;literal&quot; 如果我们要让一个命名 a 和一个字面量（&quot;literal&quot;）相加，要怎么做呢？其实很简单： 1234JCTree.JCBinary binary = maker.Binary( JCTree.Tag.PLUS, maker.Ident(names.fromString(&quot;a&quot;)), maker.Literal(&quot;literal&quot;)); // 此处 PLUS 为运算符 &quot;+&quot; 回过头来，我们拼接 Json 的代码应该是这样的： 1&quot;{\\&quot;success\\&quot;:&quot;+ success +&quot;,\\&quot;response\\&quot;:+&quot; response &quot;+}&quot; 也就是: 不难看出，到最后这些拼接代码都会被聚合成一个 JCBinary。通过这个性质，我们可以使用 Stream#reduce 来把众多元素聚合成一个 JCBinary。 此处贴出完整的 makeReturnJsonExpress 以供参考。 12345678910111213141516171819202122232425262728private static List&lt;JCTree.JCStatement&gt; makeReturnJsonExpress(TreeMaker maker, Names name, JCTree.JCClassDecl claz) { var json = claz.getMembers().stream() .filter(e -&gt; e.getKind() == Tree.Kind.VARIABLE) .filter(e -&gt; e instanceof JCTree.JCVariableDecl) .map(e -&gt; (JCTree.JCVariableDecl) e) .collect(Collectors.toMap(e -&gt; e.getName(), e -&gt; e.getType())); var list = json.entrySet().stream() .map(e -&gt; maker.Binary(JCTree.Tag.PLUS, maker.Literal(&quot;\\&quot;&quot; + e.getKey() + &quot;\\&quot;:&quot;), maker.Ident(e.getKey()) // 引用字段名 ) ).reduce((e1, e2) -&gt; maker.Binary( JCTree.Tag.PLUS, e1, maker.Binary( JCTree.Tag.PLUS, maker.Literal(&quot;,&quot;), e2) )) .orElseThrow(); list = maker.Binary(JCTree.Tag.PLUS, maker.Literal(&quot;{&quot;), list); list = maker.Binary(JCTree.Tag.PLUS, list, maker.Literal(&quot;}&quot;)); return List.of(maker.Return( list ));} 至此，我们的 @Jsonized 生成的 toString 已经可以处理简单情况了。 调用方法但是游戏还没结束，你很快会发现一个问题…. 如果数据里存有特殊字符，例如 &quot; 那就出事了！因此，要给字符串加一些特殊处理。 1&quot;{\\&quot;success\\&quot;:&quot;+ success +&quot;,\\&quot;response\\&quot;:+&quot; response.replaceAll(&quot;\\\\\\&quot;&quot;,&quot;\\\\\\\\\\&quot;&quot;) &quot;+}&quot; // 拼接的时候把 &quot; 替换为 \\&quot; 也就是说，我们要对 response 进行方法调用。那么，先引入一个新方法吧！ 12345678910111213141516171819202122232425262728293031323334private static JCTree.JCExpression processValue(JCTree value, Name name, TreeMaker maker, Names names) { var typeName = value.toString(); switch (typeName) { case &quot;String&quot;: case &quot;CharSequence&quot;: case &quot;StringBuilder&quot;: case &quot;StringBuffer&quot;: // 一切可以 toString 的... var toS = maker.Exec(maker.Apply( List.nil(), maker.Select( maker.Ident(name), names.fromString(&quot;toString&quot;) ), List.nil() )); // toS: name.toString() var replaced = maker.Exec( // 1 maker.Apply( // 2 List.nil(), // 类型参数，就是方法的泛型，不多过关心 maker.Select( // 3 toS.expr, names.fromString(&quot;replaceAll&quot;) ), List.of( // 方法参数 maker.Literal(&quot;\\\\\\&quot;&quot;), maker.Literal(&quot;\\\\\\\\\\&quot;&quot;) ) ) ); // replaced: name.toString().replaceAll(...) return maker.Binary(JCTree.Tag.PLUS, maker.Literal(&quot;\\&quot;&quot;), maker.Binary(JCTree.Tag.PLUS, replaced.expr, maker.Literal(&quot;\\&quot;&quot;))); default: return maker.Ident(name); }} 写这篇博文的时候我还没有去深究具体要怎么获取到 JCVariable 的类型关系，所以只有这么蠢的方法。 还是老样子，逐步解释代码： Exec 执行的意思，这里可以传入一个 JCExpression Apply 返回一个 JCMethodInvocation，正是我们要的东西 Select 返回一个 JCFieldAccess，而参数是发起操作的对象和他对应的方法/字段（瞎猜的）当然这里你也可以用 maker.Ident(name) 来代替 Select，也就是直接对 name 对应的对象发起动作。 之后再修改一下之前的代码： 1234567 .map(e -&gt; maker.Binary(JCTree.Tag.PLUS, maker.Literal(&quot;\\&quot;&quot; + e.getKey() + &quot;\\&quot;:&quot;),- maker.Ident(e.getKey()) // 引用字段名+ processValue(e.getValue(), e.getKey(), maker, name) ) ).reduce((e1, e2) -&gt; 大功告成。现在你已经得到了一个可以处理 String/CharSequence/StringBuilder/StringBuffer 里的转义问题（当然，只限于双引号）的编译期序列化 Json 的编译器插件了！ 一种更好的做法: 委托与其这样大费周章的在编译器完成这些工作，倒不如再带几个类进去然后委托到类上的静态方法进行转换。这样做的好处有很多，例如无需重新编译这些 class , 例如可以通过代码编写更灵活的转换机制… 等等。实际上，Java 14+ 中 Record 的 equals 正是通过 INVOKEDYNAMIC 委托到别处比较实现的，并且高版本 Java 中 String 类型的拼接也使用了委托。 附：使用注解处理器除了直接编写 Javac 插件，我们还有另外一种做法，就是 Annotation Processor，注解处理器。 比起 Javac 插件，它的局限较高，但是用起来会方便一点因为不用加那个”-Xplugin”的编译器 参数 所以这里简单介绍一下如何使用注解处理器访问 AST。类似 Plugin，你需要先继承一个 AbstractProcessor: 1234567891011121314151617181920212223242526272829303132333435363738394041package org.inlambda.kiwi.magic.plugin;import com.sun.source.util.Trees;import com.sun.tools.javac.tree.JCTree;import com.sun.tools.javac.tree.TreeMaker;import com.sun.tools.javac.util.Context;import com.sun.tools.javac.util.Names;import org.inlambda.kiwi.magic.Jsonized;import org.inlambda.kiwi.magic.NoNullExcepted;import org.inlambda.kiwi.magic.plugin.gens.GenJsonToString;import org.inlambda.kiwi.magic.plugin.gens.GenNoNull;import javax.annotation.processing.*;import javax.lang.model.SourceVersion;import javax.lang.model.element.Element;import javax.lang.model.element.TypeElement;import java.util.Set;@SupportedAnnotationTypes(&quot;*&quot;) // 表示处理任意元素@SupportedSourceVersion(SourceVersion.RELEASE_11)public class KiwiAnnotationProcessor extends AbstractProcessor { private Context context; private Trees trees; // 注意这里还有个 Trees private TreeMaker maker; private Names names; @Override public void init(ProcessingEnvironment processingEnv) { super.init(processingEnv); trees = Trees.instance(processingEnv); try { var f = processingEnv.getClass().getDeclaredField(&quot;context&quot;); // 得到 context f.setAccessible(true); context = (Context) f.get(processingEnv); maker = TreeMaker.instance(context); names = Names.instance(context); } catch (NoSuchFieldException | IllegalAccessException e) { throw new RuntimeException(e); } }} 然后一样在 META-INF/services/javax.annotation.processing.Processor 里写上你的类名，注意是 Processor 而不是 AbstractProcessor … 拿到 TreeMaker, Context，Trees 和 Names 之后就好办很多了，接下来的问题是怎么获取到 AST。 好在 Annotation Processor API 允许我们处理所有元素而不只是规定的几个注解标注过的元素，我们可以在 boolean process(...) 方法中访问到所有我们要的元素（前提是 @SupportedAnnotationTypes(&quot;*&quot;) ）： 123456789101112131415161718@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) { for (TypeElement annotation : annotations) { if (annotation.getQualifiedName().contentEquals(Jsonized.class.getName())) { // 先判断这个注解是不是我们的 for (Element element : roundEnv.getElementsAnnotatedWith(annotation)) { //接着可以拿到注解标注过的所有元素 // 因为我们的注解 Target 是 TYPE，所以只能在类上。这里直接强转成 JCClassDecl 即可。 // 通过 Trees 得到它对应的 AST 元素。这里的 element 实际上是个 ClassSymbol var jtree = (JCTree.JCClassDecl) trees.getTree(element); var method = GenJsonToString.genMethod(maker, names, jtree); // 似曾相似的套路，这就是我什么推荐你单独放.... jtree.defs = jtree.defs.append(method); } } } return true;} That’s it! 其实这种需求用注解处理器的话似乎比直接写 Javac 插件还要简单一些？ 注意: 注解处理器不能和 javac 插件混着用，而且在 gradle 中，他们似乎是在不同的环境里被加载的。（也就是你无法通过静态字段传递加载信息来判断用户想用的是插件还是注解处理器） End / 结语本文简要介绍了 javac 闭包 API 的基本使用以及一种使用注解处理器访问 javac AST 的方法。 不过需要注意的是，虽然这些 API 自从 1.8 加入以来就没怎么变过（应该？），他们仍然是不稳定，不安全，无保障的。因此，若要使用，请总是进行单元测试并且尝试检查版本兼容性。 本篇博客的所有代码均为 Kiwi 项目的一部分，Kiwi 以 MIT 协议开源，如果你想 Star 但是没有 Codeberg 帐号的话可以去 GitHub 上的镜像 (疯狂暗示) 文章可能有偏差，可以在评论区指正。 End. Credits: StackoverFlow - Accessing com.sun.tools.javac.util from Java 9Baeldung - Java Annotation Processing and create a builderBaeldung - Creating a Java Compiler Plugin … and many random StackoverFlow Answers. Thanks for them.","link":"2022/07/06/Extending-Java-Compiler/"},{"title":"浅谈 Java 虚拟机是如何标识垃圾的","text":"Java 作为一门 VM 语言，它的垃圾回收机制确实帮我们省了很多事情，我们不再需要去”手动管理内存的分配和释放”，只需要交给 VM 来做就好了。 然而，真的是这样吗？即使有神一般高性能的垃圾回收器，我们写代码时仍然需要注意它是如何标记垃圾对象的，因为垃圾回收器并不是万能的，仍然有一些工作需要程序员自己完成。 本文试图通俗易懂的讲解 JVM 上标记垃圾的方法，如有错误请在评论区指正。 两种标记垃圾的方式或许你曾听闻过 引用计数法，也就是 一个对象被引用时计数器 + 1 ，解除引用时计数器 - 1，当计数器为 0 时将会被 GC，看起来非常可行。 但是这种方法没有被 Java 采用，因为他有两个显而易见的问题： 循环引用问题 如果一个对象内部引用了另一个 引用这个对象的 对象，那么计数器将永远不会为 0 计数器的维护问题 引用计数器的值会以极快的速度更新，更新任务变得繁重 或许因此，Java 采用了 可达性分析 的方法对垃圾进行标记。 可达性分析可达性分析的思路很简单。 他从一组叫 GC Root 的引用出发，递归搜索出所有能被到达的节点作为存活的对象，而此外那些没有被搜索到的对象就会被标记 将被清理。 途中，被蓝色尖头指向的对象将不会被清除，因为他们间接或者直接的被 GC Root 引用。而旁边没有被 GC Root 引用的两个对象将会被清除，无论他们之间有什么关系。 不久，因为 Garbage F 和他的朋友 Garbage E 没有来自 GC Root 的直接/间接引用，他们就会被 gc 回收掉了。 想想看，如果在这个图中 Object C 建立了到 Garbage F 的一个引用，会发生什么？ 引用在聊 GC Root 是什么之前，你可能需要知道引用是什么。 举个例子: 1234Object a = new Object();var b = a;var c = b;assert a == c; 以上代码运行不会报错，因为他们是在内存中是同一个对象。这是如何做到的呢？ JVM 并没有把这个对象拷贝很多次，因为他赋值并不是赋一个对象，而是引用。 这是因为对象是分配在堆里的，new Object() 返回的实际上是一个引用。引用就是指向对象的钥匙。 打个比方说， 网盘链接 可以指向一个资源，你把链接给了别人并不是直接把资源发送给了别人，只是给了一个指向资源的钥匙，它可以通过这个钥匙获取到资源。 再来看一个例子 123List&lt;Object&gt; someObject = new ArrayList();someObject.add(objectA);someObject.add(objectB); 显然，以上的代码将两个对象塞到了一个容器里，看起来是这样的： 当然，不只是塞到容器才有引用 1234567class A{ A anotherA;}A a = new A();A b = new A();a.anotherA = b; 另外，Java 还有多种引用类型来帮助你实现更加灵活的对象生命周期管理。本文主要讨论的是强引用的情况，并不考虑弱引用类型，有兴趣的读者可以自行了解( WeakReference , PhantomReference , SoftReference )。 如果你无法理解引用也没有问题，只需要理解成一个对象存了另一个对象之间建立的关系就好了。 GC RootGC Root 是垃圾收集器进行分析的起点，不会被回收，而且类型有很多种但是基本上不用特地记，主要就注意这几个。 局部变量，参数之类的 就是指方法里面声明的那些变量，不过出了方法就没了 类静态字段或常量 比如 private static final XX xx = new XX() 虚拟机内部引用 被同步锁持有的对象 来个例子12345private static final List&lt;OOMObject&gt; oomObjects = new ArrayList();for (int i = 0; i &lt;114514 ; i++) { oomObjects.add(new OOMObject());} 试图说明程序内存溢出的原因。 End总之，写代码的时候要注意一些潜在的，未消除的引用，虽然一般碰不到。","link":"2021/11/05/How-Does-Java-Tag-Garbages/"},{"title":"关于提问与回答","text":"在「如何请求到他人的帮助来解决问题」上已经有许多优秀的指导文章，但在如何有效的帮助他人上似乎还是少了那么点东西。 授人予鱼不如…?「帮助他人」自然算不上是什么难事，至少相比如何高效的提问来说是非常简单的了。但能够并不就代表着高效，很多时间我试着去帮助其他人解答他们的问题——无论难易或是问题给予的信息有多少，我总是将答案说的尽可能详细，想着以这样的方式来解决问题。 不得不承认这种方法有时相当有效，只需要告诉对方「啊，先这样，然后那样」他们的问题就被解决掉了。但是随着时间推移，我在社区里解答过的问题越来越多，渐渐的我感到疲倦。这种手把手的解答方式当然非常有效，但对方能得到什么，我们持续的输出知识又能得到什么？带着这样的想法，我开始不把话说的那么详细。 举个例子。 以下是在另一个群内发生的，相同的问题不同的答案： 我觉得我成功让对方思考了一番，而不只是我在唱独角戏。所以说，有时候解决问题应当是引导提问的人寻找思考的方向，而不只是告诉他答案。正所谓 授人以魚不如授人以漁 问句应使用问号而不是句号如果提问者的态度令人发指，自然应该拒绝它。就我所在的圈子里而言，我经常能见到一些人是这样问问题的: 遇到这样的提问者，我通常会猜测两种人。 语音输入用户 日常聊天说什么话末尾都要用个句号，连问句和感叹句都不放过的人 当然，语音输入用户没有做错任何事情。我无法理解的是第二种人，为什么日常聊天什么都得带个句号呢？对句号的执念是如此的深… 当然，以上是我的个人吐槽，若有冒犯请多见谅。本段的重点不在于用问号还是句号，而是提问的态度。没有任何人有义务在社区里为了各自的问题来逐一解答，大家的时间都很有限，所以正确的提问方式（而不只是态度）尤其重要。试想一下如果遇到了这样的问题： 那么如何解决？一不知道用的是什么权限组插件，二不知道他是要干什么，这样的问题必须要有人来进一步引导才能解决，然而他甚至可能已经在群发这种问题，根本看不到你的反问。 由此，纠正错误的提问方式尤其重要，每个人都应该学会如何正确的提一个问题来尽可能快的得到帮助，对你好也对我好。 正如上文所说，*在「如何请求到他人的帮助来解决问题」上已经有许多优秀的指导文章*，但直接把这玩意扔出去多半也没有什么人会看。 但我们有别的做法。 还有一种是“问题类型收费表”，把最差的问法放最贵，最好的问法放免费，这也不失为一种巧妙的做法。 唯有问问题的人学着去问问题，解决问题的人才能把时间花在真正有用的地方上。 不要太多厨师这句话其实出自英语里的 too many cooks in the kitchen，意思是这里有太多的人工作在同一件事情上，而这样会导致不好的结果。 正如上文的一个反例： 各抒己见自然有利于自由讨论，但不适用于解决问题上，其实也很可能会演化成情绪倾泻的垃圾桶，每个人都在坚持自己的意见，甚至可能还会出现人身攻击。 当然，这种极端情况是后话而且并不多见。但一个问题确实不应该有太多的人上去解答，尤其是比较泛的问题。如果你已经看到有别的”厨师”正在解决这个问题，那么你只要纠正他的说法就好，而不是他说一套你也要跟着说一套，那样只会让提问的人更加混乱 「我 TM 到底听谁的」 找出真正的问题有一种问题，我们管它叫做 Y 问题，为什么呢？因为 Y 问题是 X 问题的一个分支，解决了 Y 问题自然可以解决 X 问题，但不代表必须解决 Y 问题才能解决 X 问题。 这就是 XY-Problem ，大家都经常犯的错误。如果你遇到了一些比较不合理的需求，不妨问一问提问者「你的原始需求是啥啊」，或许你会得到一个新的看问题的视野。 举个例子: 「Q：有没有什么插件可以替换任意 GUI 里面的文本啊，我只找到替换聊天信息的」「A: 你要替换什么文本？」「Q：XX 插件的菜单里面都是英文的，我想通过替换来翻译一下」「A: 直接在 plugins\\XXX\\gui.yml 里面改就好了，用不着找那种插件，况且也没有。」 除了 X-Y 问题，也可能是提问者表述不清，适当引导即可。 说了这么多，其实核心只有两件事情： 引导——有时我们要引导提问者而不只是给他答案，但不代表所有的问题都需要引导。 态度——如果提问者的态度令人发指，你应该恰当的指出他的错误。 就此抛砖引玉，欢迎在评论区留下评论。","link":"2022/02/10/How-to-help-Others/"},{"title":"大风天","text":"深夜了，大家早早的闭上了眼睛，期待着黎明的光芒把他们重新唤醒。 窗外，大风呼啸着。我躺在床上，静静地聆听风的呼声，冬天来了。 闭上了双眼，就仿佛置身于世界之外，只有风的护声。仿佛想到在几千年前……更久以前风也是这么呼的，于是又觉着和过去的人有某种声息相通的联系。 像是凄凉的呼唤，又像是愤怒的咆哮——不过只是人主观给他添加上的情绪。风大抵是没有感情的，只是咆哮，从地球之初到现世皆是如此，毫无忌惮的咆哮着。想着，风又是一屑不顾地刮过窗外的小河，引起阵阵波浪，也刮的树叶动燥不安。 它试图撞进窗来，但是终究还是被挡住了，便在窗外向天公申冤。 我听着他们的声音安稳的睡了一觉。 … 一觉醒来，世界又好像被大风改造成一番新景色。可能是拜前几天的台风所赐，夏日的痕迹荡然无存。大风划过我睡的迷迷糊糊的脸颊，让我打了一哆嗦。 大风天！每当到了这样的大风天，我总是能亢奋起来。大风吹过我的身体，就好像给我换了新的血，换了新的气。 我敞开胸怀，让大风使劲地吹。与夏日那股闷燥的气息不同，冬天的大风清爽怡人，它不仅能卷走一切，也能让我打一喷嚏。 吹着大风，往事爬上我的背脊。它们不断的提醒我，似乎，我喜欢大风天，不只是为了凉爽。 … 曾经，可能是很久以前吧，也是同样的大风天里，我给我的猫洗了个澡。 别人家的小奶猫，放个手就过来蹭，使劲的蹭，就怕你下一刻要离开，巴不得让你把它端在手里，放在心里。但我的猫从来不是，它知道自己是只有个性的猫，所以也有个性的活着。 它的个性也体现在洗澡里。跳出澡盆，大喊大叫，扒拉门把手… 我们费了好大劲才把它洗干净。大风在窗外呼啸，它冷的发抖，大抵是身上的水还没有沥干。正好明天还要上学，于是我抱着它到被窝里，头对着头睡了一觉。 猫没有逃跑，只是依偎着，暖暖的，房间里黑漆漆的，就好像世界上只剩下我和猫，以及窗外的大风。 … 曾经的一个没有寄宿的大风天，我走在回家的路上。 大风肆意穿过校园，视树们为标耙，刮的它们好不安分，就连太阳也慢慢的被压了下去。我悠闲自在的走在小路上，想着今晚吃什么，回家之后先做点什么。 有时，还能在路边发现流浪猫。我总是忘记带上水和猫粮——偶尔会带一些水，不过不知道猫愿不愿意喝，它也不出来，便放在它可能出现的地方许个愿就走了。 可怜的猫啊，我希望它能找到住所。 睡觉的时候，我躲在被窝里，任凭窗外大风呼啸也找不着我。 … 也是曾经，在一个大风天里，我淋着大雨回到了家，锁上门，瘫坐着只是哭出来。 还没哭一小会，角落某堆衣服里悉悉索索的冒出点声音。是猫吗？它听闻到我的声音，从它熟睡的地方跳出来，用身体贴着我走来走去，像是哭一样叫了起来。 我看着它忧心仲仲的样子，感觉傻傻的，又笑了起来。虽然阴云密布，但我有小太阳。 … 再后来，又是新年，又是一番喜庆的景象。追着人家的小牛在院子里绕着圈跑，在院子里玩玩具枪，在乡下体验”探险”，那时候还没有抖音，快手。 我坐在院子里，享受着晚风悄悄地吹过。 … 时光飞逝。 再后来，我上了初中，又上了高中，还住了宿，再也没有看夕阳和闲情雅致的时间，陪伴猫的时间也越来越少。 后来，家姐把它领了回去，再后来见他时已然过了两三年，但它仍然记得我，不禁让我万分感动。然而猫还是活不过人，只好在他现存的时候尽可能陪陪它，也算是让我不留缺憾了。 大风天卷走一切，也卷不走回忆和温暖。我吹着大风，听着大风，然而我却不觉得冷，就好像幸福的事情即将发生，就好像我还是曾经在床头旁哭的我。 大风天。每当想起这些事情，我就仿佛有了屏障，有了一个小太阳，不仅仅是挡住了大风，也烧掉了我的痛苦，我的惆怅。 2021.10.12 回忆。","link":"2021/10/12/Windy-Day/"},{"title":"从零开始的编译器生涯","text":"近日一屑高二学生无聊动手写起了编译器….这是他的珍贵作战记录 0x01 理论基础我摊牌，我没有看任何编译原理相关的书籍，因此这篇文章并不能作为严格的参考资料，甚至很多地方可能是错误的。 编译器，编译器，就是把高级语言的代码编译成另一种形式（class，asm，二进制，IR），而他在编译成另一种形式之前大概需要过这么个流程: Lex -&gt; Parse -&gt; Compile 接下来逐步讲解这个过程。 Lexer就是分词器，输入用户提供的代码接着把他分成 tokens，也就是 tokenstream。你肯定看不懂上面那句话的意思，让我们来点实例：a.value 里的那个 ArrayList 就是一个 token stream，str 是被解析的代码。不难发现，语句被 Lexer 按顺序进行了分类以及数据的分割，如 a 被识别为了一个 Identify (标记)。 因此也可以归纳出来 Token 大致的代码长啥样： 1234567@AllArgsConstructor@Getterpublic class Token { private int line; private Type type; private String content;} ParserLexer 从源码中提取出 token stream 后将会交给 Parser 处理，它负责对 token stream 进行解析，生成一个 AST (Abstract Syntax Tree)，也就是 抽象语法树。 这张图直观的描述了这一过程，你可以看到它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。 接着，AST 将会丢给代码生成器用于生成代码，但是一般会先对 AST 进行优化，例如 常量折叠 Static Analyzing但在这之前，我们还有一些问题要解决。其实这玩意我是和 Parser 写一块的试想一下，如果有这样一行代码： 1var i = love + cats 代码生成器如何知道 love 和 cats 是什么？ 在 Parser 的眼里，他们只是 Identifier，然而它们之间不能相加减。 在这种时候，Parser 需要预先建立一个符号表，这样他才能找出 love 和 cats 究竟是什么以及是否能够编译。 同理，下面的代码也一样需要这一过程： 123456import java.util.Listvoid main(List&lt;String&gt; args){ // 此处 Parser 将会分析出 java.lang.String 和 java.util.List NullCat nc = new SBNC(); // 按照 Java 的逻辑，此处没有导入（或同包）于是会产生错误，因为Parser找不到 SBNC / NullCat} Code Generation接着是生成代码！一般编译器都会输出一种 IR (Intermediate Representation) 码，而他的作用则是一种中间表示。例如，如果你输出 LLVM 的 IR 码，那么接下来你的编译工作（win,x64,linux,…jvm）就可以交给 LLVM 来完成，而像 LLVM 这样负责最后这一步骤的我们称之为 编译器的后端 使用这一种方法有几个好处： 它可以使得开发者更专注于 语言设计 而不用过多的考虑 优化，因为大多数编译器后端会帮你完成这件事情 ，除非你直接输出汇编那就得你自己负责优化了。 IR 是中间表示，它可以按照相同的语义编译出不同平台，不同架构的代码，大大节省了开发者时间 … 处于个人习惯，我选择了 Java 的字节码作为 “IR”，他将会被 JVM 加载并在运行过程中收集数据被更好的优化以及可以享受和 Java 互操作，跨平台的优势。 0x02 实践知道了这些理论，我们立即可以开始编写我们的第一个 Lexer 了。 这是我们这一大章节的目标代码： 12345using java.util.Listfn main(args: List&lt;String&gt;){ println &quot;hello world!&quot;} 那么，让我们开始吧！下文将会有大量代码，为了可读性，我会删掉一些无关紧要的部分。 Lexer我的 Lexer 分为两步：fuzzyTokenize 和 tokenize。实际上这是取决于做法的，有正则转 DFA（状态机）的，也有直接 charStream 的。 我选择了第二种，因为我认为使用正则的代码可读性比较糟糕，不易于维护。那么，让我们开始做一些准备工作… 123456789public class Lexer { private final String fileName; private final String rawContent; public Lexer(String content,String fileName) { rawContent = content.replaceAll(&quot;//.*|(\\&quot;(?:\\\\\\\\[^\\&quot;]|\\\\\\\\\\&quot;|.)*?\\&quot;)|(?s)/\\\\*.*?\\\\*/&quot;, &quot;$1 &quot;); // remove comments. this.fileName=fileName; }} 从构造方法接受源代码和文件名并且删除注释。你可能会问文件名用来干啥，那当然是用来报错的～接着，还有一个 LexedNode 用来表示 fuzzyTokenize 后的产物。 1234567891011121314public class LexedNode { private NodeType type; private String content; // 初始化和getter... public enum NodeType { IDENTIFIER,SYMBOL,KEYWORD,OPERATOR, LINE_SEPERATOR, LITERAL_STRING,LITERAL_NUMBER }} 这就是一个最基本的 token! 在后文，我们将会进行第二次 tokenize 使它变得更详细。 准备好了，开始写吧！首先是一个状态机： 1234567891011121314public List&lt;LexedNode&gt; fuzzyTokenize() { char[] charStream = rawContent.toCharArray(); List&lt;LexedNode&gt; nodes = new ArrayList&lt;&gt;(); int line = 1; for (int i = 0; i &lt; charStream.length; i++) { // 使用 fori 是为了循环时移动指针 char now = charStream[i]; switch (now) { case '\\n': nodes.add(new LexedNode(NodeType.LINE_SEPERATOR,&quot;\\n&quot;)) continue; // 此处使用 continue 立即跳到下一次循环 } } return nodes;} 这就是你的第一个 Lexer，可以先输出一下看看结果： 123456789LINE_SEPERATORLINE_SEPERATORLINE_SEPERATORLINE_SEPERATORLINE_SEPERATOR 因为代码有五行，因此是五个 LINE_SEPERATOR。只有换行符可不够，我们还要识别 KEYWORD ，也就是关键词。然而关键词使用空格分割，因此我们可以这样做： 123456789101112131415161718192021switch(...){ //... case ' ': inIdOrLiteral = !inIdOrLiteral; if (inIdOrLiteral) { // start collecting continue; } // end! String str = buffer.toString(); identifierParse(str, nodes); buffer = new StringBuilder(); // compose continue; // 此处换行同理}//.../* Collect String or Identifier */ if (inIdOrLiteral) { buffer.append(now); continue; } 你可以看到，我们引入了两个新的变量和一个方法，它们分别是 inIdOrLiteral 和 buffer 以及 identifierParse。 inIdOrLiteral 表示当前是否正在遍历一个 Identifier 或者一个字面量buffer 用于收集这个字面量，当然你也可以使用 substring 和 charAt 的方法identifierParse 是一个方法，他用于分类 Identifier。对于 11，他会分类成一个 LITERAL_NUMBER，对于 not_a_keyword，他会分类成一个 identifier，对于 fn，他会分类成一个 Keyword。 还没完，天资聪颖的你肯定已经注意到了这里少了一样东西——我要怎么匹配最开头的一个 using ？ using 的前头可没有一个空格。这时你可以回忆一下，在各种编程语言中作为 Identifier 的符号应该符合什么规则….是的，他们通常不会以运算符作为开头，以及他们不是一个关键字，因此我们还可以利用这个特性写出这样的代码: 1234567891011121314151617181920212223242526 /* Other Symbols */ if (SYMBOL_OR_OPERATORS.contains(now）) { if (inIdOrLiteral) { // keyword // now == a symbol,we should end this. identifierParse(buffer.toString(), nodes); buffer = new StringBuilder(); inIdOrLiteral = false; } if (SYMBOLS.contains(now)) { nodes.add(new LexedNode(now, LexedNode.NodeType.SYMBOL)); continue; } else if (OPERATORS.contains(now)) { nodes.add(new LexedNode(now, LexedNode.NodeType.OPERATOR)); continue; } else { throw new LexerException(fileName+&quot;: Unknown char: &quot; + now+&quot; line: &quot;+line); } } else { inIdOrLiteral = true; // not symbol &amp; not identifier }/* Collect String or Identifier */ if (inIdOrLiteral) { buffer.append(now); continue; } 这一段代码将会在匹配第一个字符没有遇到语言规定的操作符或者特殊符号的时候把 inIdOrLiteral 设置为 true。配合上面的代码，在遇到一个空格的时候他会结束收集并且尝试判断是什么。 实际上应该是 switch 的任务但是写成 if 更加直观一些。 那么到现在，我们可以开始尝试代码了！这是 Lexer 的输出： 12345678910111213141516171819202122232425262728KEYWORD usingIDENTIFIER javaOPERATOR .IDENTIFIER utilOPERATOR .IDENTIFIER ListLINE_SEPERATOR LINE_SEPERATOR KEYWORD fnIDENTIFIER mainSYMBOL (IDENTIFIER argsOPERATOR :IDENTIFIER List&lt;String&gt;SYMBOL )SYMBOL {LINE_SEPERATOR KEYWORD println- LITERAL_STRING hello world!+ IDENTIFIER &quot;hello+ IDENTIFIER world!&quot;LINE_SEPERATOR SYMBOL }5: RIGHT_BRACKET } 相比你已经注意到了，理应出现的 LITERAL_STRING 被两个 IDENTIFIER 代替了，这显然不是我们想要的结果。因此，我们要给 String 加入特 殊 支 持 1234567891011121314151617switch(now){ case '&quot;': if (i != 0 &amp;&amp; charStream[i - 1] != '\\\\') { // string starts or end inIdOrLiteral = !inIdOrLiteral; stringMode = true; if (!inIdOrLiteral) { stringMode = false; // a new string! nodes.add(new LexedNode(buffer.toString(), LexedNode.NodeType.LITERAL_STRING)); buffer = new StringBuilder(); continue; } } continue; //...} 以及 1234 case ' ':+ if (stringMode) {+ break;+ } 12- if (SYMBOL_OR_OPERATORS.contains(now)) {+ if (SYMBOL_OR_OPERATORS.contains(now) &amp;&amp; !stringMode) { 这样我们就躲开了这个陷阱，完成了对于 String 的支持后，我们的 fuzzyTokenize 就做好了！ 关于 OPERATORS 和 SYMBOLS一门语言里的符号很多，你绝对不会想把他们一个个 add 到 list 里面的，但你可以写一个 loader 来解决这个问题 然后，是 tokenizer。fuzzyTokenize 输出的结果显然不足以交给 Parser 做解析，我们需要使i结果更加详细。 好在经过 fuzzyTokenize 后代码已经被格式化成了比较模糊的 Token Stream，这一点使我们写第二次 tokenize 的时候会轻松很多，因为你不会再见到 inIdOrLiteral 和 stringMode 这种让人抓狂的东西了。 首先，让我们从一个新的 Token 开始（你不会想和 LexedNode 混一块的）: 1234567891011121314151617181920212223242526272829@AllArgsConstructor@Getterpublic class Token { private int line; private Type type; private String content; public enum Type{ IDENTIFIER(&quot;&quot;), CLASS(&quot;class&quot;),FUNCTION(&quot;fn&quot;),ANNOTATION(&quot;annotation&quot;),FOR(&quot;for&quot;),WHILE(&quot;while&quot;),IF(&quot;if&quot;),USING(&quot;using&quot;) ,THIS(&quot;this&quot;),TRUE(&quot;true&quot;),FALSE(&quot;false&quot;),ELSE(&quot;else&quot;),VAR(&quot;var&quot;),NULL(&quot;null&quot;),PRINTLN(&quot;println&quot;), // KEYWORDS VAL(&quot;val&quot;), LEFT_BRACE(&quot;(&quot;),RIGHT_BRACE(&quot;)&quot;), LEFT_BRACKET(&quot;{&quot;),RIGHT_BRACKET(&quot;}&quot;), LEFT_MID_BRACE(&quot;[&quot;),RIGHT_MID_BRACE(&quot;]&quot;), COMMA(&quot;,&quot;),DOT(&quot;.&quot;),MINUS(&quot;-&quot;),PLUS(&quot;+&quot;),STAR(&quot;*&quot;),SLASH(&quot;/&quot;), // operators BREAK_LINE(&quot;\\n&quot;),ASSIGNMENT(&quot;=&quot;),EQUALS(&quot;==&quot;),SEMICOLON(&quot;;&quot;),AT(&quot;@&quot;),COLON(&quot;:&quot;), LITERAL_STRING(&quot;&quot;),LITERAL_NUMBER(&quot;&quot;); // literals @Getter private String def; Type(String def){ this.def=def; } }} 比上文的 LexedNode 详细了很多——比如他主动去分类 keyword 了。接着是一个 fori ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public Pair&lt;String,List&lt;Token&gt;&gt; tokenize() { var lexedNodes = fuzzyTokenize(); var tokens = new ArrayList&lt;Token&gt;(); var line = 1; for (int i = 0; i &lt; lexedNodes.size(); i++) { LexedNode lexedNode = lexedNodes.get(i); switch (lexedNode.getType()) { case LINE_SEPERATOR: tokens.add(new Token(line, Token.Type.BREAK_LINE,&quot;&quot;)); line++; break; case SYMBOL: case KEYWORD: var type = Arrays.stream(Token.Type.values()).filter(e -&gt; e.getDef().equals(lexedNode.getContent())).findFirst().orElseThrow(()-&gt;{ return new NullPointerException(lexedNode.toString()); }); tokens.add(new Token(line, type, type.getDef())); break; case LITERAL_STRING: tokens.add(new Token(line, Token.Type.LITERAL_STRING, lexedNode.getContent())); break; case LITERAL_NUMBER: tokens.add(new Token(line, Token.Type.LITERAL_NUMBER, lexedNode.getContent())); break; case OPERATOR: // = boolean isEnd = (i == lexedNodes.size() - 1); switch (lexedNode.getContent()) { case &quot;=&quot;: if (isEnd) { throw new LexerException(fileName+&quot;: Invalid syntax line &quot;+line); } if (lexedNodes.get(i + 1).getType() == LexedNode.NodeType.OPERATOR &amp;&amp; lexedNodes.get(i + 1).getContent().equals(&quot;=&quot;)) { // == tokens.add(new Token(line, Token.Type.EQUALS, &quot;==&quot;)); i = i + 1; // skip next break; } else { tokens.add(new Token(line, Token.Type.ASSIGNMENT, &quot;=&quot;)); } break; case &quot;.&quot;: tokens.add(new Token(line, Token.Type.DOT, &quot;.&quot;)); break; case &quot;,&quot;: tokens.add(new Token(line, Token.Type.COMMA, &quot;,&quot;)); break; case &quot;-&quot;: tokens.add(new Token(line, Token.Type.MINUS, &quot;-&quot;)); break; case &quot;+&quot;: tokens.add(new Token(line, Token.Type.PLUS, &quot;+&quot;)); break; case &quot;*&quot;: tokens.add(new Token(line, Token.Type.STAR,&quot;*&quot;)); break; case &quot;/&quot;: tokens.add(new Token(line, Token.Type.SLASH,&quot;/&quot;)); break; case &quot;;&quot;: tokens.add(new Token(line, Token.Type.SEMICOLON,&quot;;&quot;)); break; case &quot;:&quot;: tokens.add(new Token(line,Token.Type.COLON,&quot;:&quot;)); break; } break; case IDENTIFIER: tokens.add(new Token(line, Token.Type.IDENTIFIER, lexedNode.getContent())); break; } } return Pair.of(fileName,tokens);} 这段代码并不难懂。在这个例子中，我们遍历来自 fuzzyTokenizer 的数据并且通过 switch 分类枚举来处理把他们转化成 Token 来表达并且存储到 tokens。对于 symbol 和 keyword，我们通过直接搜索 enum 内值的方法避免写出了像 case OPERATOR 里更糟糕的代码。 case OPERATOR 里写成这样是为了双符号操作的支持，例如 == 回到原题，这次我们可以通过 tokenize 解析出这样的结果： 123456789101112131415161718192021221: USING using1: IDENTIFIER java1: DOT .1: IDENTIFIER util1: DOT .1: IDENTIFIER List1: BREAK_LINE 2: BREAK_LINE 3: FUNCTION fn3: IDENTIFIER main3: LEFT_BRACE (3: IDENTIFIER args3: COLON :3: IDENTIFIER List&lt;String&gt;3: RIGHT_BRACE )3: LEFT_BRACKET {3: BREAK_LINE 4: PRINTLN println4: LITERAL_STRING hello world!4: BREAK_LINE 5: RIGHT_BRACKET }5: RIGHT_BRACKET } 是不是详细了很多？接着我们就可以靠着这个写一个 Parser了 在 Parse 之前在 Parse 之前，我们需要先做一次 Static Analyzing。在这个阶段，Parser 会对文件里的类型和导入表作出关联，同时也是多文件编译的基础。 Metadata你不可能靠着所有人的源码来建立索引，而且源码中的无用信息太多了。实际上，确定符号链接只需要这些信息： 1234567@Datapublic class CatMetadata { private ClassDef classDefinition = new ClassDef(); private Map&lt;String,CatMetadata&gt; cachedUsings = new HashMap&lt;&gt;(); // 这是对于被解析对象才有的 private List&lt; MethodSign&gt; methods = new ArrayList&lt;&gt;(); private Map&lt;String, VariableDef&gt; fields = new HashMap&lt;&gt;();} 关于 ClassDef, MethodSign, VariableDef 等信息本文不贴出，因为并不会影响观看体验。如果有兴趣，可以在这里找到他们相对应的具体代码 以及一个编译器全局索引，用 FQDN 确定唯一性的 Map: 123456789101112131415public static class Global { private static final Map&lt;String,CatMetadata&gt; GLOBAL_METADATAS = new HashMap&lt;&gt;(); public static final CatMetadata forClass(String str){ /* * Scan compiler classPaths */ var meta = NullCatCompiler.solveMeta(str); if(meta!=null) { GLOBAL_METADATAS.put(str, meta); }else{ meta = NullCatCompiler.solveMeta(&quot;java.lang.&quot; + str); } return meta; } } 准备就绪，我们来单独拿出一个类作为 MetadataGenerator 状态机 1234567@RequiredArgsConstructorpublic class MetadataGenerator { private final String fileName; private final List&lt;Token&gt; tokens; private CatMetadata cm = new CatMetadata(); private int i=0;} 接着，是提取数据的部分: 1234567891011121314151617181920212223242526272829303132333435363738public CatMetadata gen(){ for (i = 0; i &lt; tokens.size(); i++) { Token now = tokens.get(i); boolean end = (i==tokens.size()-1); Token next = end?null:tokens.get(i+1); switch(now.getType()){ case USING: if(!end){ i=i+1; var clazz = readAsStringUntilLB(); cm.getCachedUsings().put(clazz, Optional.ofNullable(CatMetadata.Global.forClass(clazz)).orElseThrow(()-&gt;new ParseException(&quot;Can't find clazz &quot;+clazz))); }else{ throwEOF(); } continue; case FUNCTION: if (end) { throwEOF(); } // fn main(){} if(next.getType() != Token.Type.IDENTIFIER){ throw new ParseException(fileName+&quot;: Unexcepted &quot;+next.getType()+&quot; at line &quot;+now.getLine()); } String methodName = next.getContent(); i=i+1; // Move Pointer to ( MethodSign sign = readMethodSign(methodName); if(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode())){ throw new ParseException(fileName+&quot;: Duplicated method: &quot;+sign+&quot; at line &quot;+now.getLine()); } cm.getMethods().add(sign); skipCodeBlocks(); continue; // ... } } return cm;} 在这个循环当中，我们通过获取到 Token 的类型来判定需要做的操作，这是基于语言设计定义来做的—— 例如 fn 的后面必然是一个方法签名，而不可以是别的。最终 MetadataGenerator 将会返回一个 CatMetadata 以供后续操作。 因此，这一阶段我们也可以发掘出类型错误和大的语法错误。 与 Java 的世界我们需要和 Java 交互，因此我们需要给 Class 建立 CatMetadata 。好在这很简单，因为 CatMetadata 需要的所有数据都可以通过反射获取，这里提供一段参考代码： 123456789101112131415161718192021222324252627282930@AllArgsConstructorpublic class ClassMetaPathImpl implements MetaPath{ private ClassLoader classLoader; @Override public CatMetadata findClass(String clazz) { CatMetadata cm = new CatMetadata(); Class&lt;?&gt; claz = Util.runCatching(()-&gt;{ return Class.forName(clazz,false,classLoader); }).getResult(); if(claz==null){ return null; } for (Field declaredField : claz.getDeclaredFields()) { if(!Modifier.isPublic(declaredField.getModifiers())) continue; VariableDef def = new VariableDef(declaredField.getType().getCanonicalName(),declaredField.getName()); cm.getFields().put(declaredField.getName(),def); } for(Method declaredMethod: claz.getDeclaredMethods()){ if(!Modifier.isPublic(declaredMethod.getModifiers()))continue; MethodSign sign = new MethodSign(declaredMethod.getName(), (ArrayList&lt;String&gt;) Arrays.stream(declaredMethod.getParameterTypes()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList())); cm.getMethods().add(sign); } ClassDef cdf = new ClassDef(); cdf.setClassName(clazz); cdf.setSuperclass(claz.getSuperclass()==null?null:claz.getSuperclass().getCanonicalName()); cdf.setInterfaces(Arrays.stream(claz.getInterfaces()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList())); cm.setClassDefinition(cdf); return cm; }} 静态分析结束后，我们就要准备开始生成 AST 了。 附我们从 token 流中获取数据，并且根据类型进行匹配——但我们其实没有用到状态仔细看，你会发现这个东西： 123456789 i=i+1; // Move Pointer to (+ MethodSign sign = readMethodSign(methodName); if(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode())){ throw new ParseException(fileName+&quot;: Duplicated method: &quot;+sign+&quot; at line &quot;+now.getLine()); } cm.getMethods().add(sign);+ skipCodeBlocks(); continue; 是不是有些象是 DSL？这其实归咎于类字段中那个不起眼的 int i = 0，它使得 for 循环的指针可以被整个类里的方法所共享。 12345678910private final String readAsStringUntilLB(){ // 一只读，读到一个换行为止并且收集成字符串 StringBuilder sb = new StringBuilder(); int b=0; for(int a = i; tokens.get(a).getType()!= Token.Type.BREAK_LINE;a++){ sb.append(tokens.get(a).getContent()); b=a; } i = b; return sb.toString();} 在经过更加详细的 tokenize 之后，代码实际上变得更加可观了， Parser先占个坑位～","link":"2021/10/01/Writting-A-Compiler-1/"},{"title":"使用 cproxy 对程序进行透明代理","text":"在 Windows 下，说到 透明代理 ，你可能会想到 Proxifier , SSTap, Mellow但在 Linux 下，你可能会想到 proxychains 然后再想到 proxychains 不能代理 static-linked 的程序。 为什么 ProxyChains(NG) 不能代理静态连接的程序ProxyChains NG 通过一个预加载的共享库来hook到网络相关的函数(比如: connect,getaddrinfo)上，接着他就可以转发这些流量。缺点似乎显而易见，如果只是通过 LD_PRELOAD 来进行透明代理，那么这招对于静态连接的程序是无用的（比如说 Go 程序..)其次，ProxyChains 只支持 TCP，这可能导致无法转发 DNS 流量 -&gt; DNS 流量泄漏。 cproxy 是什么cproxy 也是透明代理，作用和 proxychains 类似。原理上与 proxychains 不同，它使用 cgroup 进行对程序的代理 ，不过配置起来还有点麻烦本文将会教您在您的Linux PC上使用 cproxy，截至本文发布之前，cproxy似乎只支持 Linux。 下载 cproxy官方推荐的方法是: 直接用 cargo 1cargo install cproxy 如果没有 cargo 可以在 Release 上下载压缩包。解压压缩包，可能会发现有两个可执行文件，不过似乎只留一个就好了。 安装 cproxy先来试一试 cproxy！ 1cproxy --port &lt;本地代理端口&gt; -- curl ip.sb ( ｀д′) 失败了如果你和我一样，在port上写了 socks5 的代理端口，那么你就被坑了。笔者填入 geph 的 HTTP 代理端口时是可以成功的，但是使用 v2ray 的s5/http端口都无法使用。这是因为 cproxy 需要修改 v2ray 的配置进行兼容，如果你不想去改配置 在确保可以使用 cproxy 后，我们来配置 alias。将以下内容写到 ~/.bashrc，记得自己修改一些部分。 alias &quot;px&quot;=&quot;/path/to/cproxy --port &lt;your-local-proxy-port&gt; --&quot; 例如我的配置： alias &quot;px&quot;=&quot;/bin/cproxy --port 60080 --use-tproxy -- &quot; # 60080 是ipt2socks的默认监听端口。 保存后，使用 source ~/.bashrc 载入，试试 px curl ip.sb，看看是否成功。 缺陷每次使用都要 sudo ，还是挺烦人的吧…对于这种情况，也可以考虑使用有后台常驻的 cgproxy，但本文不做介绍，有兴趣可以自己了解。","link":"2021/03/13/%E4%BD%BF%E7%94%A8-cproxy-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/"},{"title":"Hello World","text":"你好, Hexo！折腾了一个晚上，我终于还是回到 Hexo 的怀抱了。接下来会陆陆续续更新一些杂文，并且把我在 Lxnet 发布的那几篇文章搬一下，欢迎 Watch/订阅 我的博客。","link":"2021/03/12/hello-world/"},{"title":"2021 碎碎念","text":"2022 早就来了，但是我的年终总结推迟了好些时候才开始写。如果是在之前的话，我大概新年一到就很迫切的把去年发生了什么事通通写下来的。 说是年终总结，不如说是对于去年发生的事情碎碎念。真要说起来的话，其实我感觉去年好像也没fa发sheng生le什da么shi事qing情。开了不少坑，虽然后面也没有完成几个坑。一是没时间，二是大多时间都用在摸鱼上了。 技术力仍然在提高，除了认识到了新的人，也对以往认识的人有了更深的认知。 今年猫猫还是没有回来，想它。 抑郁后的那段时间貌似有开始写小说… 不过写了几天很快也暂停了，最终还是没有想好我要写一个什么样的故事啊～还是多加沉淀再下笔吧。虽然说从初中开始就总是想写点什么东西。但是写什么呢？ 透过窗外看到一些新鲜事物的时候，我总是能代入一个新鲜的故事环节里。如果细挖那些故事的设定肯定很不错的吧。 vape 还是没有破解掉。两年了，从初三到高二，但我已经把进度推进到了我暂时无法触及的领域，也算是比较骄傲的一件事情（也有朋友们的帮助），不过也没什么兴趣了 暑假结束之后分配到了新的班级，算是远离之前那一帮人了。新的班级里也表现的不太自在，然而我无法允许自己跟他们同流合污，我也有想坚守的行为底线。 心理变态，三观不正以貌取人的极端主义者难道不应该被教育淘汰或拯救吗？然而他竟在学校里成为一种典型。 更新的班级里是更旧的班主任。他不是童话书里的园丁，只不过有的老师是。 现实刺穿了我的后背，但我宁愿相信那里没有血迹。 又比去年浮躁了许多，可能是自从上了高中天天在学校留宿便也无处享清净以修身养性了。宿舍里是浮躁的人，班级里也是浮躁的声音，谈何学习？ … 年终总结，过去，现在，未来，亦如此。大概会是我最后一次写这东西了 感谢 4d3b2d63a26f50fd6eaa243921f37b459448fe91e9f86bb624eb084dacd895d6 。Powerful friendship 本来想更新几篇和泛型相关的文章的，还是看时间吧。写一篇年终碎碎念也得花不少时间呐","link":"2022/02/09/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"life","slug":"life","link":"tags/life/"},{"name":"memories","slug":"memories","link":"tags/memories/"},{"name":"compiler tech java","slug":"compiler-tech-java","link":"tags/compiler-tech-java/"},{"name":"tech","slug":"tech","link":"tags/tech/"},{"name":"misc","slug":"misc","link":"tags/misc/"},{"name":"linux","slug":"linux","link":"tags/linux/"},{"name":"summary","slug":"summary","link":"tags/summary/"}],"categories":[]}