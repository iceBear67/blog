{"posts":[{"title":"关于域名更改","text":"—–BEGIN PGP SIGNED MESSAGE—–Hash: SHA256 旧的域名（ib67.io）即将弃用，请使用新域名（blog.0w0.ing）访问本博客io好看拦不住他贵啊 我发布在 Central 的 Maven Artifact 也将会陆续使用此域名（0w0.ing）更换 group id，请悉知～ —–BEGIN PGP SIGNATURE—– iQGzBAEBCAAdFiEEwk7LXiHwWhkAu3cNJ6mjp6+Gu90FAmZnrYkACgkQJ6mjp6+Gu90c/gv9F2ZU+J1W38DZxH4xiLFAANfy2Wp5JdqOkMOfJUNRVx2xs9r8CofM5A6jUCGu8nquFf0OLCEW5FQDsqwMbYI314gC9cElcC4PIIx3rCrU8c/u2dXn+qWVmQTpSQ918ArW4r+dYcDPkEPDD2ia6rY2nxTWNiCGkpurFoOy3W0LGthKhW96PMT7a+7GKc5GAZ6++DWIh+FSp5Clp1fzb/3NqfbCojvxV6xAWNBBbKK4LAX8anv6BfflNDrbFk7igmqVrwssJBiwoSPTHcNhztQMul9va6qczgMOe9RJr3HCwI+H5eq43U9o39r37qF1KDckiQz4DD5psuuIfx0LChMtORA0+b88smlZygAXpBDK+BBnPWjyKa1/NFPSqGewuTC2+7qfukfW4hcjqH9KegVlcuLf2zsbHknmoDWSMmJKDLuHpI+2L/mUuAS7hizKvDswbO8RYUmgyY9Jg/XV7f7eNOnaP0gLfnOaCMsMB4sH/SQ5wYIwarYPU8LO4G8TIkb6=7v7D—–END PGP SIGNATURE—–","link":"2024/06/11/Domain-Migration/"},{"title":"「9+」 Java 编译器插件教程 101","text":"写了上万行 Java 代码，相比你已经对 Java “木纳呆板”的语法恨之入骨了。 那么，有没有一种可能，我是说可能，我们可以给 Java 编译器写插件？ 如果你要在面包店里买面包，你最好跟店员说你要买哪块面包。本文所指的 Java 编译器 均为 OpenJDK 自带的那个 javac，而不是其他的前端编译器实现。 前言自从 Java 8 起，Oracle 就将插件系统引入了 javac 中，因此是可以写 Javac 插件的。 虽然写一个 Javac 插件并且修改代码是可能的，但是这方面的资料很少（国内就更少了），并且大多内容重复（教你写个 HelloWorld 然后就结束），其次 javac 的东西也不是很好摸，毕竟不是公开 API（ JDK 9+ 开始已经不暴露在外了）。 恰逢今年还没写技术类的博客，就拿来磨磨刀吧。 先从插件说起上文刚刚提到了一个词，插件。它其实正是 com.sun.source.util.Plugin。通过这个类，我们可以让 Javac 在编译时加载我们的代码。 加载了代码，那么做什么呢？所以我们立一个目标：给所有 @Jsonized 标注过的类都生成一个可以输出 json 的 toString() 方法。 什么意思呢？就比如说这样一个类： 12345678public class MyResponse { private final String message; private final boolean success; public MyResponse(String message, boolean success){ this.message = message; this.success = success; }} 然后你想把它序列化成 Json。 1234var response = new MyResponse(&quot;\\&quot;Success!\\&quot; Took me 114514 yr 1919810 m&quot;,false).toString();response.equals(&quot;&quot;&quot; {&quot;message&quot;: &quot;\\&quot;Success!\\&quot; Took me 114514 yr 1919810 m&quot;, &quot;success&quot;: false}&quot;&quot;&quot;); 又快又便捷，还不需要第三方类库，这就是我们的目标。 那么先把这个注解写出来吧！ 12345678910111213package org.inlambda.kiwi.magic;import java.lang.annotation.*;/** * Classes with this type can be serialized to json by their {@link #toString()} method. */@Retention(RetentionPolicy.RUNTIME)@Documented@Target(ElementType.TYPE)public @interface Jsonized { } 值得提一点就是这些编译器注解的 Retention 用 RetentionPolicy.SOURCE 也是可以的，但是以后可能运行期间我们需要识别到这些被修改过的类，所以设置为 RUNTIME。 接着是，实现 Javac 的 Plugin 接口！ 12345678910111213141516package org.inlambda.kiwi.magic.plugin;import com.sun.source.util.Plugin;public class KiwiJavacPlugin implements Plugin { @Override public String getName() { return &quot;Kiwi&quot;; // 插件的名字 } @Override public void init(JavacTask task, String... args) { // 插件初始化回调 System.out.println(&quot;Hello Kiwi&quot;); }} 但是它不让你过编译。 打通模块的穴位这怎么能忍！在默认包目录下创建一个 module-info.java。 然后我们写点东西进去。 12345module kiwi.magic.main { // module 后跟模块名，下文要用 requires jdk.internal.vm.compiler; requires jdk.compiler; requires java.naming;} 加入这些之后，还要配置一下构建工具的编译参数。 （本教程使用 Gradle, Maven/SBT 用户请自行摸索….） 1234567compileJava { options.compilerArgs &lt;&lt; &quot;--add-exports=jdk.compiler/com.sun.tools.javac.tree=kiwi.magic.main&quot; &lt;&lt; &quot;--add-exports=jdk.compiler/com.sun.tools.javac.code=kiwi.magic.main&quot; &lt;&lt; &quot;--add-exports=jdk.compiler/com.sun.tools.javac.util=kiwi.magic.main&quot; &lt;&lt; &quot;--add-exports=jdk.compiler/com.sun.tools.javac.api=kiwi.magic.main&quot; &lt;&lt; &quot;--add-exports=jdk.compiler/com.sun.tools.javac.processing=kiwi.magic.main&quot;} 这样就能过编译了！虽然 IDEA 仍然会划出红线，但是只要接受他的解决方案就好（形如 add XX to compiler option） 由于 IDEA 可能不会自动补全没有确定模块关系的类，教程可能会大量使用完整的类名或是指向 Java SE 8 Documentation 的引用链接。 配置 ServiceJavac 通过 Java SPI 发现插件，因此你需要写一个 Service 文件让他能够发现你。 在 src/main/resource/META-INF/services/com.sun.source.util.Plugin 中写出： 12# 填写你的插件主类名，这是教程的例子。org.inlambda.kiwi.magic.plugin.KiwiJavacPlugin 但是还差一步。 加载插件Javac 也是一个 Java 程序，他是在他的运行时 classpath 里面寻找插件的。 而在 Gradle 中，annotationProcessor 就会被加入到编译器的 classpath 中。但我们不能用 annotationProcessor this ，因为 gradle 不允许，所以我们需要另外新建一个模块专门测试插件。 为了加载插件，应当确保 build.gradle 中有如下内容： 123456789dependencies { testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1' testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1' compileOnly(project(&quot;:magic&quot;)) annotationProcessor(project(&quot;:magic&quot;)) // 就是这个！}compileJava { options.compilerArgs &lt;&lt; '-Xplugin:Kiwi' } // Kiwi 是插件的名字 万事具备，开 assemble ！ 现在，我们已经让 Javac 加载了我们的代码，但这仅仅是个开始。为了实现 @Jsonized 的目标，我们还需要注入代码。 得到编译单元对 AST 下手，首先要拿到 CompilationUnit 而 Javac 通过 TaskEvent 将它传递给我们，因此我们要注册一个 com.sun.source.util.TaskListener 来收 TaskEvent。 123456@Overridepublic void init(JavacTask task, String... args) { // 插件初始化回调 System.out.println(&quot;Hello Kiwi&quot;); task.addTaskListener(new KiwiTaskListener(((BasicJavacTask) task).getContext()); // this!} KiwiTaskListener: 1234567891011121314151617181920212223242526package org.inlambda.kiwi.magic.plugin.jc;import com.sun.source.util.TaskEvent;import com.sun.source.util.TaskListener;import com.sun.tools.javac.util.Context;public class KiwiTaskListener implements TaskListener { private final Context context; public KiwiTaskListener(Context context) { this.context = context; } @Override public void started(TaskEvent e) { } @Override public void finished(TaskEvent e) { if (e.getKind() != TaskEvent.Kind.PARSE) { // 注意此处 return; } var compUnit = e.getCompilationUnit(); }} 编译流程:Java 编译器的几个阶段: COMPILATION PARSE – 构造抽象语法树 (AST) ENTER – 源码里的引用均已被解析 ANALYZE – 生成 AST 并用于分析错误 GENERATE – 为源码生成输出 (.class) ANNOTATION_PROCESSING - 注解处理器被唤起 ANNOTATION_PROCESSING_ROUND COMPILATION 因为我们的目标是修改代码（对编译器来说，也就是对抽象语法树下手），所以只需要关心 PARSE 阶段就好了。如果你对 “AST” 和 “PARSE” 的概念还不太了解，那么你可以先看看我的另一篇博客 获取 AST得到 CompilationUnit 后，我们便可以“访问”到对应的 class 了。 12345678910111213141516171819202122232425262728293031323334353637383940package org.inlambda.kiwi.magic.plugin.jc;import com.sun.source.tree.ClassTree;import com.sun.source.util.TreeScanner;import com.sun.tools.javac.tree.JCTree; //注意这些完整类名，如果你的 IDEA 补全不了尝试复制这些到 IDEA 里面去。import com.sun.tools.javac.tree.TreeMaker; import com.sun.tools.javac.util.Context;import com.sun.tools.javac.util.Names;import org.inlambda.kiwi.magic.plugin.gens.GenJsonToString;public class JsonizedTreeScanner extends TreeScanner&lt;Void, Context&gt; { @Override public Void visitClass(ClassTree node, Context ctx) { // 此处 Context 是类型参数里规定的 try { var maker = TreeMaker.instance(ctx); // 1 var name = Names.instance(ctx); // 2 var claz = (JCTree.JCClassDecl) node; // 3 if (node.getModifiers() .getAnnotations() .stream() .anyMatch(e -&gt; e.getAnnotationType() .toString() .equals(&quot;Jsonized&quot;))) { // 判断是否有 Jsonized System.out.println(&quot;Jsonized class found: &quot; + node.getSimpleName()); super.visitClass(node, ctx); } } catch (Throwable t) { System.err.println(t.getMessage()); for (StackTraceElement stackTraceElement : t.getStackTrace()) { System.out.println(stackTraceElement); // Javac 会屏蔽掉正常的报错输出，因此需要手动打印出来。 } } super.visitClass(node, ctx); return null; }} 接下来逐个讲解这些代码。 TreeMaker 是一个非常重要的组件，通过 TreeMaker 我们可以创建语法树的组件然后把它们插入到现有的语法树里，也就是修改代码。 Names 也是一个重要组件，因为它几乎就是符号表，虽然其本身是 Identifier ….。 JCTree.JCClassDecl 就是类在AST中的定义，我们接下来会讲解到它以及更多 JCTree 子类的应用。 同时，我们在 magic-test 模块中创建一个类用于测试 @Jsonized，但为了节约篇幅，类的代码不列出。 让我们的访客访问 CompilationUnit: 12345678@Overridepublic void finished(TaskEvent e) { if (e.getKind() != TaskEvent.Kind.PARSE) { // 注意此处 return; } var compUnit = e.getCompilationUnit(); compUnit.accept(new JsonizedTreeScanner(), context); // 此处 context 是上文类构造器依赖注入进来的} 尝试编译 magic-test，你应当能在 compileJava 阶段看到 Jsonized class found: XXX。 对 AST 动手动脚哎呀，你怎么动手动脚的！ 拿到了类定义，我们就可以访问类里的所有元素了！另外，JCTree 的子类通常是可以直接 toString() 出来的，你可以利用这一点查看编译的输出。 但在修改之前，得先了解一下 Javac 内部的 List 实现。 List in JavacJavac 不知道出于什么缘故，他自己有一个链表（com.sun.tools.javac.util.List&lt;A&gt;）的实现，而且他是不可变的。 这个链表不对外公开（因为 Oracle 官方网站也没有 Javadoc），所以不提供引用链接了。 此处介绍几个常用的方法。 List.nil()静态方法。顾名思义，空集。 List.of(A x1, A x2, A x3, A… rest)一个静态工厂，用于创建一个定长的 List. 一些类似 prepend 和 append 这样对元素操作的方法…他们都返回新的实例，因为 List&lt;A&gt; 是不可变的，小心别被坑了。 等等，那不定长的呢？于是我们还有一个类，他就是 com.sun.tools.javac.util.ListBuffer&lt;A&gt;。 ListBuffer&lt;A&gt; 是 List&lt;A&gt; 某种类似 Builder 的工具，他的 append 等方法始终返回他自己，用完之后可以 toList() 转换成 List&lt;A&gt;。 做好这些基础知识的准备工作，我们终于，终于，终于可以开始动工了。 访问类里的元素 JCClassDecl 并没有严格区分开来方法和字段，他们都是 member。然而 getMembers() 是只读的（因为 List&lt;A&gt; 不可变），所以我们要绕开 getMembers() 直接访问到后面的字段。 绕也很简单… 没想到吧，Javac 里面就是这么乱。 接下来往 defs 里面插入方法即可。 构造方法然后插进去！这里我们就要请出刚刚提到过的大名鼎鼎的 TreeMaker 了！ 方法定义在 Javac 中就是 com.sun.tools.javac.tree.JCTree.MethodDecl，可以通过 TreeMaker#MethodDef 构造。 1234567891011121314// 建议把生成方法单独放起来public static JCTree.JCMethodDecl genMethod(TreeMaker maker, Names symbolTable, JCTree.JCClassDecl claz) { var method = maker.at(claz.pos).MethodDef( // 1 maker.Modifiers(Flags.PUBLIC | Flags.FINAL), // 方法的修饰符 symbolTable.fromString(&quot;toString&quot;), // 2 方法的名称 maker.Ident(symbolTable.fromString(&quot;String&quot;)), // 3 返回值类型 List.nil(), List.nil(), // 这三个先忽略再说 List.nil(), maker.Block(0, makeReturnJsonExpress(maker, symbolTable, claz)) // 方法体 , null ); return method;} 是不是有些迷糊？我们”娓娓道来”… at(claz.pos).MethodDef( 这句的意思是把 TreeMaker 当前的位置调整到目标类上然后再创建一个方法定义，不然可能会把方法生成到别的地方。（不过我没试过，其实方法和类关系是比较确定的，所以这个 pos 可能是给语句用的，因为语句有顺序。） symbolTable.fromString(&quot;toString&quot;) Names 提供了 fromString 方法用来创建对应的标识符/名字（Identifier）。 maker.Ident Ident 是一个很常用的方法，他可以接受一个 Names 然后输出一个 JCIdent。 而 JCIdent 恰好是 JCExpression，也就是 JCTree 的子类。 注意，从符号表拿类型并不需要把命名写完整（就好像上文写的不是 java.lang.String），如果要引入外部的类型只需要 maker.Import 即可 例如：maker.Import(maker.Ident(names.fromString(&quot;java.util.Objects&quot;)).getTree(), false); 这还只是方法的基本信息，接下来是方法体，也就是最关键的那部分。 但在写输出 Json 之前，我们不妨先写个 HelloWorld 试试。 123private static List&lt;JCTree.JCStatement&gt; makeReturnJsonExpress(TreeMaker maker, Names name, JCTree.JCClassDecl claz) { return List.of(maker.Return(maker.Literal(&quot;Hello Jsonized!&quot;)));} 然后我们回到上文，把新的方法体插入到类里。 123456789 var claz = (JCTree.JCClassDecl) node; if (node.getModifiers().getAnnotations().stream().anyMatch(e -&gt; e.getAnnotationType().toString().equals(&quot;Jsonized&quot;))) { System.out.println(&quot;Jsonized class found: &quot; + node.getSimpleName()); claz.def = claz.def.append(genMethod(maker,name,claz)); // THIS super.visitClass(node, ctx); }} catch (Throwable t) { System.err.println(t.getMessage()); 尝试编译 magic-test 模块并且查看编译输出，如果你没有干坏事的话应该能看到 @Jsonized 标注过的类里多出来一个 public final String toString()，并且代码体正是 return &quot;Hello Jsonized!&quot;;。 (由于我的 Jsonized 用的是 RetentionPolicy.SOURCE，所以注解编译后就被抹除掉了) AST 的常用姿势到上一节，你已经成功的： 让 Javac 加载你的代码 对特定注解标志过的类添加代码 那么这一节，我们着重讲解一些常用的操作以及更多基础知识。 从获取字段开始为了序列化出所有字段，我们首先需要知道我们的类里有哪些字段。 幸好，使用 Stream 就可以很轻松地做到这件事: 12345var nameToVar = claz.getMembers().stream() .filter(e -&gt; e.getKind() == Tree.Kind.VARIABLE) // 其实这个可能可以省略 .filter(e -&gt; e instanceof JCTree.JCVariableDecl) .map(e -&gt; (JCTree.JCVariableDecl) e) .collect(Collectors.toMap(e -&gt; e.getName(), e -&gt; e.getType())); 产出一个 Map&lt;Names, JCTree&gt;。JCTree 就是类定义，此处为 JCVariableDecl 有了这样一个 nameToVar 之后，我们就可以构造 Json 了。 拼接字符串与二元表达式哪个男孩不想体验一下二元运算符呢？ “+” 是一个二元运算符，它接受两个参数: a 和 b 并且产出一个结果。 在 Java 里，我们是这样写的：a + b 那么如果更多参数呢？ 以此类推，可以构造出一个很长很长的二元树，而这正好是我们今天要做的事情。 先从拼接字符串开始，举个例子：a + &quot;literal&quot; 如果我们要让一个命名 a 和一个字面量（&quot;literal&quot;）相加，要怎么做呢？其实很简单： 1234JCTree.JCBinary binary = maker.Binary( JCTree.Tag.PLUS, maker.Ident(names.fromString(&quot;a&quot;)), maker.Literal(&quot;literal&quot;)); // 此处 PLUS 为运算符 &quot;+&quot; 回过头来，我们拼接 Json 的代码应该是这样的： 1&quot;{\\&quot;success\\&quot;:&quot;+ success +&quot;,\\&quot;response\\&quot;:+&quot; response &quot;+}&quot; 也就是: 不难看出，到最后这些拼接代码都会被聚合成一个 JCBinary。通过这个性质，我们可以使用 Stream#reduce 来把众多元素聚合成一个 JCBinary。 此处贴出完整的 makeReturnJsonExpress 以供参考。 12345678910111213141516171819202122232425262728private static List&lt;JCTree.JCStatement&gt; makeReturnJsonExpress(TreeMaker maker, Names name, JCTree.JCClassDecl claz) { var json = claz.getMembers().stream() .filter(e -&gt; e.getKind() == Tree.Kind.VARIABLE) .filter(e -&gt; e instanceof JCTree.JCVariableDecl) .map(e -&gt; (JCTree.JCVariableDecl) e) .collect(Collectors.toMap(e -&gt; e.getName(), e -&gt; e.getType())); var list = json.entrySet().stream() .map(e -&gt; maker.Binary(JCTree.Tag.PLUS, maker.Literal(&quot;\\&quot;&quot; + e.getKey() + &quot;\\&quot;:&quot;), maker.Ident(e.getKey()) // 引用字段名 ) ).reduce((e1, e2) -&gt; maker.Binary( JCTree.Tag.PLUS, e1, maker.Binary( JCTree.Tag.PLUS, maker.Literal(&quot;,&quot;), e2) )) .orElseThrow(); list = maker.Binary(JCTree.Tag.PLUS, maker.Literal(&quot;{&quot;), list); list = maker.Binary(JCTree.Tag.PLUS, list, maker.Literal(&quot;}&quot;)); return List.of(maker.Return( list ));} 至此，我们的 @Jsonized 生成的 toString 已经可以处理简单情况了。 调用方法但是游戏还没结束，你很快会发现一个问题…. 如果数据里存有特殊字符，例如 &quot; 那就出事了！因此，要给字符串加一些特殊处理。 1&quot;{\\&quot;success\\&quot;:&quot;+ success +&quot;,\\&quot;response\\&quot;:+&quot; response.replaceAll(&quot;\\\\\\&quot;&quot;,&quot;\\\\\\\\\\&quot;&quot;) &quot;+}&quot; // 拼接的时候把 &quot; 替换为 \\&quot; 也就是说，我们要对 response 进行方法调用。那么，先引入一个新方法吧！ 12345678910111213141516171819202122232425262728293031323334private static JCTree.JCExpression processValue(JCTree value, Name name, TreeMaker maker, Names names) { var typeName = value.toString(); switch (typeName) { case &quot;String&quot;: case &quot;CharSequence&quot;: case &quot;StringBuilder&quot;: case &quot;StringBuffer&quot;: // 一切可以 toString 的... var toS = maker.Exec(maker.Apply( List.nil(), maker.Select( maker.Ident(name), names.fromString(&quot;toString&quot;) ), List.nil() )); // toS: name.toString() var replaced = maker.Exec( // 1 maker.Apply( // 2 List.nil(), // 类型参数，就是方法的泛型，不多过关心 maker.Select( // 3 toS.expr, names.fromString(&quot;replaceAll&quot;) ), List.of( // 方法参数 maker.Literal(&quot;\\\\\\&quot;&quot;), maker.Literal(&quot;\\\\\\\\\\&quot;&quot;) ) ) ); // replaced: name.toString().replaceAll(...) return maker.Binary(JCTree.Tag.PLUS, maker.Literal(&quot;\\&quot;&quot;), maker.Binary(JCTree.Tag.PLUS, replaced.expr, maker.Literal(&quot;\\&quot;&quot;))); default: return maker.Ident(name); }} 写这篇博文的时候我还没有去深究具体要怎么获取到 JCVariable 的类型关系，所以只有这么蠢的方法。 还是老样子，逐步解释代码： Exec 执行的意思，这里可以传入一个 JCExpression Apply 返回一个 JCMethodInvocation，正是我们要的东西 Select 返回一个 JCFieldAccess，而参数是发起操作的对象和他对应的方法/字段（瞎猜的）当然这里你也可以用 maker.Ident(name) 来代替 Select，也就是直接对 name 对应的对象发起动作。 之后再修改一下之前的代码： 1234567 .map(e -&gt; maker.Binary(JCTree.Tag.PLUS, maker.Literal(&quot;\\&quot;&quot; + e.getKey() + &quot;\\&quot;:&quot;),- maker.Ident(e.getKey()) // 引用字段名+ processValue(e.getValue(), e.getKey(), maker, name) ) ).reduce((e1, e2) -&gt; 大功告成。现在你已经得到了一个可以处理 String/CharSequence/StringBuilder/StringBuffer 里的转义问题（当然，只限于双引号）的编译期序列化 Json 的编译器插件了！ 一种更好的做法: 委托与其这样大费周章的在编译器完成这些工作，倒不如再带几个类进去然后委托到类上的静态方法进行转换。这样做的好处有很多，例如无需重新编译这些 class , 例如可以通过代码编写更灵活的转换机制… 等等。实际上，Java 14+ 中 Record 的 equals 正是通过 INVOKEDYNAMIC 委托到别处比较实现的，并且高版本 Java 中 String 类型的拼接也使用了委托。 附：使用注解处理器除了直接编写 Javac 插件，我们还有另外一种做法，就是 Annotation Processor，注解处理器。 比起 Javac 插件，它的局限较高，但是用起来会方便一点因为不用加那个”-Xplugin”的编译器 参数 所以这里简单介绍一下如何使用注解处理器访问 AST。类似 Plugin，你需要先继承一个 AbstractProcessor: 1234567891011121314151617181920212223242526272829303132333435363738394041package org.inlambda.kiwi.magic.plugin;import com.sun.source.util.Trees;import com.sun.tools.javac.tree.JCTree;import com.sun.tools.javac.tree.TreeMaker;import com.sun.tools.javac.util.Context;import com.sun.tools.javac.util.Names;import org.inlambda.kiwi.magic.Jsonized;import org.inlambda.kiwi.magic.NoNullExcepted;import org.inlambda.kiwi.magic.plugin.gens.GenJsonToString;import org.inlambda.kiwi.magic.plugin.gens.GenNoNull;import javax.annotation.processing.*;import javax.lang.model.SourceVersion;import javax.lang.model.element.Element;import javax.lang.model.element.TypeElement;import java.util.Set;@SupportedAnnotationTypes(&quot;*&quot;) // 表示处理任意元素@SupportedSourceVersion(SourceVersion.RELEASE_11)public class KiwiAnnotationProcessor extends AbstractProcessor { private Context context; private Trees trees; // 注意这里还有个 Trees private TreeMaker maker; private Names names; @Override public void init(ProcessingEnvironment processingEnv) { super.init(processingEnv); trees = Trees.instance(processingEnv); try { var f = processingEnv.getClass().getDeclaredField(&quot;context&quot;); // 得到 context f.setAccessible(true); context = (Context) f.get(processingEnv); maker = TreeMaker.instance(context); names = Names.instance(context); } catch (NoSuchFieldException | IllegalAccessException e) { throw new RuntimeException(e); } }} 然后一样在 META-INF/services/javax.annotation.processing.Processor 里写上你的类名，注意是 Processor 而不是 AbstractProcessor … 拿到 TreeMaker, Context，Trees 和 Names 之后就好办很多了，接下来的问题是怎么获取到 AST。 好在 Annotation Processor API 允许我们处理所有元素而不只是规定的几个注解标注过的元素，我们可以在 boolean process(...) 方法中访问到所有我们要的元素（前提是 @SupportedAnnotationTypes(&quot;*&quot;) ）： 123456789101112131415161718@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) { for (TypeElement annotation : annotations) { if (annotation.getQualifiedName().contentEquals(Jsonized.class.getName())) { // 先判断这个注解是不是我们的 for (Element element : roundEnv.getElementsAnnotatedWith(annotation)) { //接着可以拿到注解标注过的所有元素 // 因为我们的注解 Target 是 TYPE，所以只能在类上。这里直接强转成 JCClassDecl 即可。 // 通过 Trees 得到它对应的 AST 元素。这里的 element 实际上是个 ClassSymbol var jtree = (JCTree.JCClassDecl) trees.getTree(element); var method = GenJsonToString.genMethod(maker, names, jtree); // 似曾相似的套路，这就是我什么推荐你单独放.... jtree.defs = jtree.defs.append(method); } } } return true;} That’s it! 其实这种需求用注解处理器的话似乎比直接写 Javac 插件还要简单一些？ 注意: 注解处理器不能和 javac 插件混着用，而且在 gradle 中，他们似乎是在不同的环境里被加载的。（也就是你无法通过静态字段传递加载信息来判断用户想用的是插件还是注解处理器） End / 结语本文简要介绍了 javac 闭包 API 的基本使用以及一种使用注解处理器访问 javac AST 的方法。 不过需要注意的是，虽然这些 API 自从 1.8 加入以来就没怎么变过（应该？），他们仍然是不稳定，不安全，无保障的。因此，若要使用，请总是进行单元测试并且尝试检查版本兼容性。 本篇博客的所有代码均为 Kiwi 项目的一部分，Kiwi 以 MIT 协议开源，如果你想 Star 但是没有 Codeberg 帐号的话可以去 GitHub 上的镜像 (疯狂暗示) 文章可能有偏差，可以在评论区指正。 End. Credits: StackoverFlow - Accessing com.sun.tools.javac.util from Java 9Baeldung - Java Annotation Processing and create a builderBaeldung - Creating a Java Compiler Plugin … and many random StackoverFlow Answers. Thanks for them.","link":"2022/07/06/Extending-Java-Compiler/"},{"title":"尝鲜 CodeBerg : &quot;非主流&quot; Git 服务现状","text":"在今年六月的时候，SCF 发了一篇关于放弃 GitHub 的长文，把人煽的热血沸腾的。 正好，这篇文章提供了一些 GitHub 的 “代替品”，我打算试一试。 SCF 推荐了两个服务： CodeBerg – 公开的 Gitea 实例，前身是 Teapod. SourceHut – 貌似很久以前就有了，但是成为 Maintainer 要花钱订阅，Collaborator 不用。 因为只是尝鲜，就没有去看 SourceHut 了，所以用的是 CodeBerg. 登陆估计是因为 Gitea 的原因，Codeberg 很多地方都和 GitHub 相似。此外，他们还提供了类似 GitHub Pages 的 CodeBerg Pages 服务，这点要点个赞！ CodeBerg 访问起来快很多，大概是因为还没受到 GFW 的恩爱吧。不过 Pages 服务对比起绑定了域名的 GitHub Pages 就有点不够意思了。 还支持暗色主题！ … 整体来说体验和自建 Gitea 其实差不多，自己建的 Gitea 也有 WebAuthn 支持这些有意思的东西，无非 SLA 问题。 官方还提供了一些文档，貌似写得很详细，而且还考虑到了不会使用 Git 的人群。虽然 GitHub 也有，不过我还没去看过，就不做比较了。 项目迁移登陆后做的第一件事情就是迁移项目到 CodeBerg 上。支持的迁移来源很多，其中也包括 GitHub。 但是没有那么简单，由于项目体量稍微大了一点点，很快就触发了 Rate-Limit 导致无法顺利迁移。用多几个 UserToken 也无济于事 那怎么办？只能自己手动迁移了呗… 迁移代码不算什么难事，直接往新的仓库 push 即可，问题是仓库的元数据们——issues，pull requests 和 webhooks Issues 和 PRs在 GitHub 上的仓库已经一百多个 Issue 了，无论是 Open 还是 Closed 都有必要迁移。虽然 Codeberg 提供了把 issues 页面重定向的设置，但是我觉得还是放在 CodeBerg 上比较好，毕竟我没有 Jira。 一个一个迁移显然不太可能，还好我搜索一会儿就找到了 Gitea 官方早些年放出来的工具 https://gitea.com/gitea/migrator Migrator Migrator is a library and a command line tool, which allow to migrate all repositories data from github/gitlab/gitea/bitbucket to gitea 虽然已经很老旧了，但是完全可以用，比较可惜的是时间信息全部丢失了.. WebHooksCodeBerg 支持若干 WebHook，类型多的有点让人出乎意料。 最出乎意料的是，它的 Gitea 钩子竟然和我专门为 GitHub 设计的 WebHook Bot 完美兼容… 总的来说，这块支持真的比 GitHub 要好很多了。 集成现在稍大一点的项目都已经用 CI 做检查和自动构建了，要是没有 CI 支持就太难受了。 在以前 GitHub 还没推出 Actions 的时代，可以用 Circle CI, Travis CI, Appyevor 接入 GitHub 来达到目的。然而，这些供应商没有一个支持 Gitea 的，Appyevor 也只不过自建的实例支持。 很好理解，但是 CodeBerg 也在其中，也就是说这些服务统统与 CodeBerg 用户无缘… 如果你是那类喜欢使用自动 Code Review 的人，想必会非常痛苦。不过还好，我摸索着找到了两个支持配合 Gitea 用的 CI： BuildKite – 虽然是免费，但是 Agent 要自己出，平台只是聚合结果做处理之类的。此外，不能直接接入，需要自己写点胶水。 CodeBerg CI – 只支持 CodeBerg BuildKite 虽然用着也不错，但是跑构建的机器还是要自己出的。这似乎也和自建 Jenkins 没有什么区别，不过理论上来说更加安全了，而且 CI 文件之类的是平台在提供支持，让你跑的 Agent 本质上就是一个 Remote Shell。 而 CodeBerg CI 则是 Codeberg 平台提供支持，免费。但仍在内测。能够满足基本的 CI 需求，但是总体用起来远不如 GitHub Action，用起来给人一种和项目割裂开的感觉。 生态在使用一周 CodeBerg 后我就有了放弃的念头。虽然它很优秀，但是世界的中心是 GitHub，要不是 SCF 的长文我现在还不知道 CodeBerg呢。 就比如说，我的博客托管在 Vercel 上，而 Vercel 的 Git 接入恰好就只支持 GitHub.或者说，我的项目在 Circle CI 上构建，而 Circle CI 只支持 Github/BitBucket/GitLab.又或者说，我的一些 Bot 在 GitHub 上，而且没法很好的迁移到 CodeBerg 上。 END总的来说，我觉得 CodeBerg 还是蛮不错的，只是我最后还是回归到了 GitHub 上。 对于单纯想托管一个项目，或者喜欢数据隐私安全感的人来说，CodeBerg 确实是一个不错的选择，并且因为 SCF 的那篇长文，最近还挺多人涌进去的，没准就有你熟悉的某些开源项目。 除了 CodeBerg 之外，还有很多公开 Gitea 实例也和 CodeBerg 面临着几乎是一模一样的问题。虽然他们都可以满足代码协作的需求，但是还是差那么一点意思。 end. 明年就高考了，之后应该很少出文了，反正出了也没人看。 这篇虽然没什么内容，不过就当作水文凑且看看吧。","link":"2022/08/19/From-GitHub-To-Github/"},{"title":"上手 Minestom: 新时代 Minecraft 服务端实现","text":"笔者观望 Minestom 已经有一段时间了. 以前他的线程模型还不够成熟, 曾经联系 @TheMode 想帮他翻译那块的文档结果鸽了.正好, 今天摸鱼的时候看了一眼 Minestom 官方, 发觉现在或许是时候上手尝试一下了. 简中圈子里吹 Minestom 的很多, 然而真正上手 / 普及 Minestom 开发的很少. 官方文档已经足够详尽, 因此本篇博文只作引路贴, 希望对 Minestom 感兴趣的你自己上手尝试. 配置环境Minestom 主要托管在 JitPack 上. build.gradle: 12345678910repositories { maven { name 'JitPack' url 'https://jitpack.io' }}dependencies { implementation 'com.github.Minestom:Minestom:VERSION' // 版本号自己去 JitPack 上面找} 静静等待依赖图下载完成, 下载的过程中, 我们不难发现一些老熟人. 启动Minestom 启动实现很简单, 只需要两行就搞定了. 1234public static void main(String[] args) { var mc = MinecraftServer.init(); mc.start(&quot;0.0.0.0&quot;, 25565);} 一个空的 Minestom 实现在一秒钟内就能初始化完毕.打开 Minecraft, 添加一个 localhost 到服务器列表中就能看到你的新 Minestom 服务器. 注意: Minestom 语境下的 实例 和 实现 可能和你想象中的不一样例如: 实现/Implementation 是基于 Minestom 开发的服务端软件, 而 实例/Instance 不只指对象. 你很快就会发现你卡在登入中. 先别急着去 Issues 找骂, 看看日志怎么说: You need to specify a spawning instance in the PlayerLoginEvent 嗯… 有意思.如果想加入我们刚刚创建的新鲜 Minestom 实现, 我们首先要设置玩家加入的 实例. 那么, 实例是什么? 实例 Instances are what replace “worlds” from Minecraft vanilla, those are lightweight and should offer similar properties. There are multiple instances implementation, currently InstanceContainer and SharedInstance (both are explained below) –The Minestom Wiki 简单的说, 在 Minestom 的世界里, 实例 和我们先前在 Bukkit / Forge 上开发时的 世界 是相同的概念. 不同的是, 比起世界来说, 一个 实例 通常更加轻量一些. 那么怎么创建实例呢? 你可能会发现你刚刚得到的 MinecraftServer 对象除了能监听端口什么都不会干, 这是因为 Minestom 的大部分功能… 都被 MinecraftServer 的静态方法包装起来了. 我觉得这样做的意图可能是模拟其他 JVM 语言上 “object“ 的做法, object 类型的 “类” 默认就是单例, 因此这种类的静态方法不复存, 所有的方法和字段实际上都直接指向那个单例.虽然在 Java 的语境下这样的做法难免令人我感觉奇怪, 但是这毕竟不是重点. 我们拿到 InstanceManager, 然后创建一个新的实例: 12var manager = MinecraftServer.getInstanceManager();var instanceContainer = manager.createInstanceContainer(); 噢! 不要忘记设置默认的 世界生成器, 不然你会一直掉下去虚空的. 12instanceContainer.setGenerator(unit -&gt; unit.modifier().fillHeight(0,1, Block.GRASS_BLOCK)); 然后要注册一个事件监听器, 用于告诉 Minestom 我们想让玩家出生在什么地方. 123MinecraftServer.getGlobalEventHandler().addListener(PlayerLoginEvent.class, evt -&gt;{ evt.setSpawningInstance(instanceContainer);}); 但是! 虽然现在已经可以进入服务器了, 我们会出生在 (0,0,0), 然后无尽掉虚空.所以, 还需要额外补几行防止这种情况. 123MinecraftServer.getGlobalEventHandler().addListener(PlayerSpawnEvent.class, evt -&gt;{ evt.getPlayer().teleport(new Pos(0,3,0));}); 启动服务器, 进去将会发现一大片草方块. 或者, 你也可以稍微更换一些参数… Minestom 生成世界的速度很快(可能是懒加载而已), 你几乎感受不到平时在 Notchian 服上最常见的世界生成卡顿. (可能是因为空 Minestom 处理的数据比较少, Minestom 就算直接加载 Minecraft 地图速度也是远超 Notchian.)虽然 Minestom 支持直接加载 Anvil 格式的存档, 但是官方文档没有提到要怎么做. 加载 Anvil 格式的地图 注: 以下使用的主要 API 被官方标记为不稳定 不难发现, createInstanceContainer 其实有支持传入 IChunkLoader 的重载方法. 只需要搜索片刻… 你就能找到 AnvilLoader. 12345 var manager = MinecraftServer.getInstanceManager();- var instanceContainer = manager.createInstanceContainer();+ var instanceContainer = manager.createInstanceContainer(new AnvilLoader(&quot;/path/to/A New World&quot;)); instanceContainer.setGenerator(unit -&gt; 只需要这样, 就可以加载你的 Minecraft 地图了. 聊天与命令Minestom 似乎内置一个简单的聊天功能实现 (连聊天格式都和原版一样), 处理信息的方法应该和在 Bukkit 上的相差不大, 只不过 Minestom 大量运用了 Kyori 的 Adventure API我有点反胃. 写代码时最好留个心眼在返回值上. 所以比较想提一嘴的是命令, 毕竟其他教程也有自古以来从命令入手写功能的习俗. 注册一个新的命令很简单: 12345var commandNew = new Command(&quot;new&quot;);commandNew.setDefaultExecutor((sender, context)-&gt;{ // your business logic...});MinecraftServer.getCommandManager().register(commandNew); 接着你就可以在你的实现里用 /new 了, 正如你想象的那样运行. 这个命令框架看起来并不新奇, 笔者甚至觉得有些奇怪. 不过, 上面给的例子只是为了你三行快速上手, 官方推崇的写法是这样的: 123456789101112package demo.commands;import net.minestom.server.command.builder.Command;public class TestCommand extends Command { public TestCommand() { super(&quot;my-command&quot;, &quot;hey&quot;); // &quot;my-command&quot; 是这个命令的主要名字. // &quot;hey&quot; 是命令的别名, 使用 /hey 和 /my-command 是一样的. }} 之后一样的套路: MinecraftServer.getCommandManager().register(new TestCommand())接着是, 有参数的情况: 123456789101112131415161718192021222324252627package demo.commands;import net.minestom.server.command.builder.Command;import net.minestom.server.command.builder.arguments.ArgumentType;public class TestCommand extends Command { public TestCommand() { super(&quot;command&quot;, &quot;alias&quot;); // 如果没有匹配到其他 Executor 就回落到这上面. setDefaultExecutor((sender, context) -&gt; { sender.sendMessage(&quot;You executed the command&quot;); }); // 全部的默认参数类型都在 ArgumentType 类里 // 这些静态工厂的参数是一些 `标识符`, 用于让程序分辨参数 (并且在 Minestom 内部用于创建节点) var numberArgument = ArgumentType.Integer(&quot;my-number&quot;); // 最后, 定义指令的 语法. (Syntax) addSyntax((sender, context) -&gt; { final int number = context.get(numberArgument); sender.sendMessage(&quot;You typed the number &quot; + number); }, numberArgument, ...more); }} 在埋头苦读上方源码之前, 不如看看官方文档是怎么解释的. All auto-completable commands should extend Command, each command is composed of zero or multiple syntaxes, and each syntax is composed of arguments If you find it confusing, here are a few examples: /health 一条指令/health set 50; 一条指令和他的语法set 一小段字面量型的参数~ ~ ~ 一个坐标参数 一条命令由零个或多个 语法 构成, 每个 语法 又由一个或多个参数构成. 如果感到无法理解, 不如这样想: 所谓的 语法 就是命令的一个基本样子.比如: /effect xxx give xxx 是一条语法, 而 /effect xxx give xxx 30 24 因为后面多了两个参数就是一个新的语法. 所以语法就规定了应该有哪些参数, 以及它们对应的类型. 更多内容, 请转向 官方文档 / Minestom Wiki 一些别的虽然它还是高度实验性的服务端, 但是它很有潜力一举代替 Spigot 成为支撑 RPG, 小游戏服务器的主流服务端, 这也说明这真的不怪Java, 别再说什么 C++ 重写性能翻3000%了 因此, 现在开始学习如何使用是完全可取的, 因为本文所述的, 官方 Wiki 中包含的, 以及本身 API 架构不太可能再发生巨大变更. Minestom 不仅提供了一个更加模块化的 Minecraft 服务端事件, 而且也兼顾了性能和 API 的良好设计, 开放程度远超 Spigot. 但是在使用 Minestom 开发你的实现之前, 你要花更多精力在维持好程序的良好架构上, 不然就会 go die.有人今天用minestom写东西写的一团糟我不说是谁 所以, 我觉得如果不是很必要, 可以使用 Minestom 的 扩展(插件) API 和 高度实验性的脚本 API.这样做或许更加有利于 Minestom 的生态发展, 而最坏的情况就是大家都喜欢自己 hold 一个 Minestom, 谁也不服谁, 就好像那帮 Mod Loader 一样.但是 Mod Loader 也各自多多少少有一些 Mod, 要是世界上光有 Mod Loader 没有 Mod 就真的成灾难了… End感谢你的观看, 欢迎在评论区留言.","link":"2022/12/19/Getting-Started-With-Minestom/"},{"title":"浅谈 Java 虚拟机是如何标识垃圾的","text":"Java 作为一门 VM 语言，它的垃圾回收机制确实帮我们省了很多事情，我们不再需要去”手动管理内存的分配和释放”，只需要交给 VM 来做就好了。 然而，真的是这样吗？即使有神一般高性能的垃圾回收器，我们写代码时仍然需要注意它是如何标记垃圾对象的，因为垃圾回收器并不是万能的，仍然有一些工作需要程序员自己完成。 本文试图通俗易懂的讲解 JVM 上标记垃圾的方法，如有错误请在评论区指正。 两种标记垃圾的方式或许你曾听闻过 引用计数法，也就是 一个对象被引用时计数器 + 1 ，解除引用时计数器 - 1，当计数器为 0 时将会被 GC，看起来非常可行。 但是这种方法没有被 Java 采用，因为他有两个显而易见的问题： 循环引用问题 如果一个对象内部引用了另一个 引用这个对象的 对象，那么计数器将永远不会为 0 计数器的维护问题 引用计数器的值会以极快的速度更新，更新任务变得繁重 或许因此，Java 采用了 可达性分析 的方法对垃圾进行标记。 可达性分析可达性分析的思路很简单。 他从一组叫 GC Root 的引用出发，递归搜索出所有能被到达的节点作为存活的对象，而此外那些没有被搜索到的对象就会被标记 将被清理。 途中，被蓝色尖头指向的对象将不会被清除，因为他们间接或者直接的被 GC Root 引用。而旁边没有被 GC Root 引用的两个对象将会被清除，无论他们之间有什么关系。 不久，因为 Garbage F 和他的朋友 Garbage E 没有来自 GC Root 的直接/间接引用，他们就会被 gc 回收掉了。 想想看，如果在这个图中 Object C 建立了到 Garbage F 的一个引用，会发生什么？ 引用在聊 GC Root 是什么之前，你可能需要知道引用是什么。 举个例子: 1234Object a = new Object();var b = a;var c = b;assert a == c; 以上代码运行不会报错，因为他们是在内存中是同一个对象。这是如何做到的呢？ JVM 并没有把这个对象拷贝很多次，因为他赋值并不是赋一个对象，而是引用。 这是因为对象是分配在堆里的，new Object() 返回的实际上是一个引用。引用就是指向对象的钥匙。 打个比方说， 网盘链接 可以指向一个资源，你把链接给了别人并不是直接把资源发送给了别人，只是给了一个指向资源的钥匙，它可以通过这个钥匙获取到资源。 再来看一个例子 123List&lt;Object&gt; someObject = new ArrayList();someObject.add(objectA);someObject.add(objectB); 显然，以上的代码将两个对象塞到了一个容器里，看起来是这样的： 当然，不只是塞到容器才有引用 1234567class A{ A anotherA;}A a = new A();A b = new A();a.anotherA = b; 另外，Java 还有多种引用类型来帮助你实现更加灵活的对象生命周期管理。本文主要讨论的是强引用的情况，并不考虑弱引用类型，有兴趣的读者可以自行了解( WeakReference , PhantomReference , SoftReference )。 如果你无法理解引用也没有问题，只需要理解成一个对象存了另一个对象之间建立的关系就好了。 GC RootGC Root 是垃圾收集器进行分析的起点，不会被回收，而且类型有很多种但是基本上不用特地记，主要就注意这几个。 局部变量，参数之类的 就是指方法里面声明的那些变量，不过出了方法就没了 类静态字段或常量 比如 private static final XX xx = new XX() 虚拟机内部引用 被同步锁持有的对象 来个例子12345private static final List&lt;OOMObject&gt; oomObjects = new ArrayList();for (int i = 0; i &lt;114514 ; i++) { oomObjects.add(new OOMObject());} 试图说明程序内存溢出的原因。 End总之，写代码的时候要注意一些潜在的，未消除的引用，虽然一般碰不到。","link":"2021/11/05/How-Does-Java-Tag-Garbages/"},{"title":"关于提问与回答","text":"在「如何请求到他人的帮助来解决问题」上已经有许多优秀的指导文章，但在如何有效的帮助他人上似乎还是少了那么点东西。 授人予鱼不如…?「帮助他人」自然算不上是什么难事，至少相比如何高效的提问来说是非常简单的了。但能够并不就代表着高效，很多时间我试着去帮助其他人解答他们的问题——无论难易或是问题给予的信息有多少，我总是将答案说的尽可能详细，想着以这样的方式来解决问题。 不得不承认这种方法有时相当有效，只需要告诉对方「啊，先这样，然后那样」他们的问题就被解决掉了。但是随着时间推移，我在社区里解答过的问题越来越多，渐渐的我感到疲倦。这种手把手的解答方式当然非常有效，但对方能得到什么，我们持续的输出知识又能得到什么？带着这样的想法，我开始不把话说的那么详细。 举个例子。 以下是在另一个群内发生的，相同的问题不同的答案： 我觉得我成功让对方思考了一番，而不只是我在唱独角戏。所以说，有时候解决问题应当是引导提问的人寻找思考的方向，而不只是告诉他答案。正所谓 授人以魚不如授人以漁 问句应使用问号而不是句号如果提问者的态度令人发指，自然应该拒绝它。就我所在的圈子里而言，我经常能见到一些人是这样问问题的: 遇到这样的提问者，我通常会猜测两种人。 语音输入用户 日常聊天说什么话末尾都要用个句号，连问句和感叹句都不放过的人 当然，语音输入用户没有做错任何事情。我无法理解的是第二种人，为什么日常聊天什么都得带个句号呢？对句号的执念是如此的深… 当然，以上是我的个人吐槽，若有冒犯请多见谅。本段的重点不在于用问号还是句号，而是提问的态度。没有任何人有义务在社区里为了各自的问题来逐一解答，大家的时间都很有限，所以正确的提问方式（而不只是态度）尤其重要。试想一下如果遇到了这样的问题： 那么如何解决？一不知道用的是什么权限组插件，二不知道他是要干什么，这样的问题必须要有人来进一步引导才能解决，然而他甚至可能已经在群发这种问题，根本看不到你的反问。 由此，纠正错误的提问方式尤其重要，每个人都应该学会如何正确的提一个问题来尽可能快的得到帮助，对你好也对我好。 正如上文所说，*在「如何请求到他人的帮助来解决问题」上已经有许多优秀的指导文章*，但直接把这玩意扔出去多半也没有什么人会看。 但我们有别的做法。 还有一种是“问题类型收费表”，把最差的问法放最贵，最好的问法放免费，这也不失为一种巧妙的做法。 唯有问问题的人学着去问问题，解决问题的人才能把时间花在真正有用的地方上。 不要太多厨师这句话其实出自英语里的 too many cooks in the kitchen，意思是这里有太多的人工作在同一件事情上，而这样会导致不好的结果。 正如上文的一个反例： 自由讨论当然好，但不适用于解决问题上，其实也很可能会演化成情绪倾泻的垃圾桶，每个人都在坚持自己的意见，甚至可能还会出现人身攻击。 当然，这种极端情况是后话而且并不多见。但一个问题确实不应该有太多的人上去解答，尤其是比较泛的问题。如果你已经看到有别的”厨师”正在解决这个问题，那么你只要纠正他的说法就好，而不是他说一套你也要跟着说一套，那样只会让提问的人更加混乱 「我 TM 到底听谁的」 找出真正的问题有一种问题，我们管它叫做 Y 问题，为什么呢？因为 Y 问题是 X 问题的一个分支，解决了 Y 问题自然可以解决 X 问题，但不代表必须解决 Y 问题才能解决 X 问题。 这就是 XY-Problem ，大家都经常犯的错误。如果你遇到了一些比较不合理的需求，不妨问一问提问者「你的原始需求是啥啊」，或许你会得到一个新的看问题的视野。 举个例子: 「Q：有没有什么插件可以替换任意 GUI 里面的文本啊，我只找到替换聊天信息的」「A: 你要替换什么文本？」「Q：XX 插件的菜单里面都是英文的，我想通过替换来翻译一下」「A: 直接在 plugins\\XXX\\gui.yml 里面改就好了，用不着找那种插件，况且也没有。」 除了 X-Y 问题，也可能是提问者表述不清，适当引导即可。 说了这么多，其实核心只有两件事情： 引导——有时我们要引导提问者而不只是给他答案，但不代表所有的问题都需要引导。 态度——如果提问者的态度令人发指，你应该恰当的指出他的错误。 End.","link":"2022/02/10/How-to-help-Others/"},{"title":"那些忘在学校里的东西","text":"放眼大海，望过对岸楼宇林立的城市，望到高中生活的尾声。 … 我好像落了些什么在学校里。 开完毕业典礼之后，回到教室，大家收拾东西，呼道「有缘再见」就各自拉着行李箱走了。再见，又会是什么时候呢？缘分，未来还会再聚一堂吗？ 再聚一堂，「他」最终会放下成见吗？「我们」又将成为什么样的人，做着什么样的事情？ 这些曾经遥不可及的未来的憧憬，正在越来越近。我有些惶恐。 即使走之前再怎么慢慢的收拾，一遍一遍的检查，或者是给高一高二在黑板上留言，我们的脚步仍然朝向校门。办公室里面不知道什么时候已经收拾的干干净净的，只有几台电脑还留在那里，似乎这间办公室本来就是这个样子。教室里狼藉不堪，地上，走廊里，桌上都是曾经灌注了心血的书籍和文具。 我在黑板上写了个大大的「快跑」，简单收拾一下就走了。本来想把之前打印的几篇论文放到学校图书馆的，奈何图书馆锁了，就只能放在楼道里的某个柜子上了。 期待下一个人得到那份资料，看到背后写着的入群地址，把这些知识传下去。 走出校门，我没有回头。 … 好像是太阳撞上了这个省，那天下午很热，我披着汗水走到家里一样样的清点行李里的东西。行李里的东西很多，但是漏了点什么。 书… 似乎落了一本知识全解。别的东西… 似乎之前某人送我的 3D 打印狐狸忘记带回来了，之前买的一本 Arduino 入门也不见踪迹。 …还有一张毕业照，好像我没带回来。 虽然很可惜，但我没有带回来毕业照。 这三年以来，这所学校从未给予我任何归属感。每当有人盘问起我的学习状况，考到了什么学校，我总是会糊糊涂涂的搪塞过去。我以在这所学校里为耻，更别提毕业照了。但即使我怎么惋惜那些落在学校里的东西，我也没法做什么了。因为学校的规定是今天就要清理干净我们的所有东西，所以即使清点的这个时间回去也只能见到环卫阿姨们忙忙碌碌的身影和一干二净的教室了。 这所教室里每年都要重复上映着一样的场景，只不过没想到这么的快，令人想起来刚刚搬入这间教室的时候，墙上还画着学长给我们画的一幅画。 画里是学校的轮廓，上面题着几个字：「剩下的，你们来完成」 时光飞逝。 … 六月九日，多么美妙的日子。在下午最后一科收齐卷后，大家就已经是高中毕业生了。那些在漫漫长夜里偷偷许下的愿望，数不清的「考后我要做什么」在这个时候重新变得明亮起来。我们就像一群刚刚降生的雏鹰，终于破开蛋壳，贪婪的呼吸着这个世界的空气，感受到无限的可能性正在奔涌而来。 晚上，我们迫不及待地回到教室里，但不再为所谓的复习。大家拿起手机只在玩，似乎十八年来从未这么自由过。但比起自由，更让人感到舒适的是某种所属感。 即使在那一天，宿舍的阿姨还是要求我们八点半回宿舍，办公室的老师们还是让我们尽快回去。到十一点半了，宿舍的阿姨来央求我们回宿舍。 我和几个人点了一大份外卖，有人抱了一大箱啤酒回来，有人在教室里开黑，最后几个喝醉了痛快谈心，聊感情，炒粉又端了上来。我夹起来别人的吃了几口，似乎还留着一股锅气。 形而上的「班级荣誉感」和「集体主义」早已被这样热情洋溢的一群人化为碎骨，即便只是昙花一现。楼道里的其他房间早就熄了火，唯独我们班灯火通明。我喝了两杯酒，头晕晕的，那时候已经是凌晨两点了，遂回宿舍睡觉。只不过宿舍里也是灯火通明的，从前被「分班」分离开的同学们又重新聚集了起来。 这里没有所谓的一二三四五六七八九班，只有一群刚刚毕业的学生。 但是，我的行李箱落下的不只是这点。 高考前一天晚上，大家已经弹尽粮绝了，可能没几个吃饱饭的。想到饭堂里抠搜的大叔，想到那些冰箱里的文物，总是让人不禁有些可惜自己的钱包被宰。 于是大家都在省着度过最后几天，生怕抠门的学校食堂不给我们退饭卡钱。但我还是忍不了了，偷偷的溜到了食堂买夜宵。夜宵？夜宵只是把泡面往牛腩汤的卤水里面洗一遍，加点咖喱汁便乘在碗里。没有人会说自己喜欢这样的东西，但是饥不择食。 等我到了食堂门口的时候，夜宵还没开始卖。两个阿姨坐在椅子上。我坐在另一边，静候开卖。过了一会儿又来了几个初中生。 坐着坐着，有一位阿姨注意到我，便跟我聊起来。 「你是高三的学生吗？」 … 「既然是高三的学生，就提前给你打一碗面吧。」 说着，她走到窗口后面，拿起一碗面递给我，又往里面加了点鱼蛋，沉甸甸的。 我接过那份沉甸甸的面，连忙应了几句谢谢之类的话，在一旁吃起来。面还是以前的面，没有因为是高三的原因分量多起来。 「阿姨，能给我们也来一份吗？」旁边的初中生问。我当着他们的面刷的卡，自然是咽口水了。「你们明天也要去考试吗？」阿姨问着。 「我们明天要周测」其中的一位初中生说。 「周测是什么？」阿姨好奇的问着。 「周测..周测就是每周都会有一次的考试」 阿姨似乎有些困惑。「噢…那是高考吗？」她说。或许在她的 18 岁里也曾经憧憬过成为高中生，但在那个年代，人们总是为饥饿所困扰。 放下勺子，呆呆的，她似乎在等待着什么，又好像在想曾经的时光。 … 吃完面后，已经流进来一些人了。我连忙去跟阿姨说了一句谢谢，阿姨一怔，叫我把碗递过去。 「阿姨祝你明天考试顺利啊…」 更早一些，我又想到了曾经的语重心长的班任，又想到了那些不在学校的吹着空调的夏天。想到了这三年来刮过学校的暖暖的晚风，这三年来蓝紫色的天空和红黄相间的夕阳，还有总是停在宿舍水渠对岸的那只白鹤。 我恍然大悟。 我终于想起来，我三年的青春留在了这所学校，永远地留在了那里。它不会因为我厌恶这所学校而遗弃它，它站在过去的暖洋洋的晚风之中，倒映在蓝紫色的天空和红黄相间的夕阳下。它是我的背影，我留在学校的背影。 我的背影啊！它一直默默的注视着我。三年里，我与他形影不离，但在这一天，背着行李回家的这一天，我却忘了与他告别。 即使这些记忆最终会被蒙上尘埃，但这才是我高中三年来，真正宝贵的东西——不是课本上的知识，不是我投入进去的经历，而是这三年里我经历的一切，人与物，与自己。 渠水如泣如诉。 暖洋洋的晚风依旧地在校园里奔跑，也必然还会有人去追寻它们。我的背影，或许正坐在某个我曾经坐过的位置，回忆着美好的事物，期待着我再一次走进校门。 但在再一次跨入校门之前，我的帆必将要往更远的地方驶去。","link":"2023/06/11/Things-that-left-in-school/"},{"title":"大风天","text":"深夜了。 大家早早的闭上了眼睛，期待着黎明的光芒把他们重新唤醒。 窗外，大风呼啸着。我躺在床上静静地聆听风的呼声，应该是冬天来了。 闭上了双眼，就仿佛置身于世界之外，只有风的声还在耳边回荡。想到在几千年前风也是这么呼的，于是又觉着和过去的人有某种声息相通的联系。 像是凄凉的呼唤，又像是愤怒的咆哮——不过只是人主观给他添加上的情绪。风大抵是没有感情的，只是咆哮，从地球之初到现世皆是如此，毫无忌惮的咆哮着。想着，风又是一屑不顾地刮过窗外的小河，引起阵阵波浪，也刮的树叶动燥不安。 它试图撞进窗来，但是终究还是被挡住了，便在窗外向天公申冤。 我听着他们的声音安稳的睡了一觉. … 一觉醒来，世界又好像被大风改造成一番新景色。可能是拜前几天的台风所赐，夏日的痕迹荡然无存。大风划过我睡的迷迷糊糊的脸颊，让我打了一哆嗦。 大风天！每当到了这样的大风天，我总是能亢奋起来。大风吹过我的身体，就好像给我换了新的血，换了新的气。 我敞开胸怀，让大风使劲地吹。与夏日那股闷燥的气息不同，冬天的大风清爽怡人，它不仅能卷走一切，也能让我打一喷嚏。 吹着大风，往事爬上我的背脊。它们不断的提醒我，似乎，我喜欢大风天，不只是为了凉爽。 … 曾经，可能是很久以前吧，也是同样的大风天里，我给我的猫洗了个澡。 别人家的小奶猫，放个手就过来蹭，使劲的蹭，就怕你下一刻要离开，巴不得让你把它端在手里，放在心里。但我的猫从来不是，它知道自己是只有个性的猫，所以也有个性的活着。 它的个性也体现在洗澡里。跳出澡盆，大喊大叫，扒拉门把手… 我们费了好大劲才把它洗干净。大风在窗外呼啸，它冷的发抖，大抵是身上的水还没有沥干。正好明天还要上学，于是我抱着它到被窝里，头对着头睡了一觉。 猫没有逃跑，只是依偎着，暖暖的，房间里黑漆漆的，就好像世界上只剩下我和猫，以及窗外的大风。 … 曾经的一个没有寄宿的大风天，我走在回家的路上。 大风肆意穿过校园，视树们为标耙，刮的它们好不安分，就连太阳也慢慢的被压了下去。我悠闲自在的走在小路上，想着今晚吃什么，回家之后先做点什么。 有时，还能在路边发现流浪猫。我总是忘记带上水和猫粮——偶尔会带一些水，不过不知道猫愿不愿意喝，它也不出来，便放在它可能出现的地方许个愿就走了。 可怜的猫啊，我希望它能找到住所。 睡觉的时候，我躲在被窝里，任凭窗外大风呼啸也找不着我。 … 也是曾经，在一个大风天里，我淋着大雨回到了家，锁上门，瘫坐着只是哭出来。 还没哭一小会，角落某堆衣服里悉悉索索的冒出点声音。是猫吗？它听闻到我的声音，从它熟睡的地方跳出来，用身体贴着我走来走去，像是哭一样叫了起来。 我看着它忧心仲仲的样子，感觉傻傻的，又笑了起来。虽然阴云密布，但我有小太阳。 … 再后来，又是新年，又是一番喜庆的景象。追着人家的小牛在院子里绕着圈跑，在院子里玩玩具枪，在乡下体验”探险”，那时候还没有抖音，快手。 我坐在院子里，享受着晚风悄悄地吹过。 … 时光飞逝。 再后来，我上了初中，又上了高中，还住了宿，再也没有看夕阳和闲情雅致的时间，陪伴猫的时间也越来越少。 后来，家姐把它领了回去，再后来见他时已然过了两三年，但它仍然记得我，不禁让我万分感动。然而猫还是活不过人，只好在他现存的时候尽可能陪陪它，也算是让我不留缺憾了。 大风天卷走一切，也卷不走回忆和温暖。我吹着大风，听着大风，然而我却不觉得冷，就好像幸福的事情即将发生，就好像我还是曾经在床头旁哭的我。 大风天。每当想起这些事情，我就仿佛有了屏障，有了一个小太阳，不仅仅是挡住了大风，也烧掉了我的痛苦，我的惆怅。 2021.10.12 回忆。","link":"2021/10/12/Windy-Day/"},{"title":"从零开始的编译器生涯","text":"近日一屑高二学生无聊动手写起了编译器….这是他的珍贵作战记录 0x01 理论基础我摊牌，我没有看任何编译原理相关的书籍，因此这篇文章并不能作为严格的参考资料，甚至很多地方可能是错误的。 编译器，编译器，就是把高级语言的代码编译成另一种形式（class，asm，二进制，IR），而他在编译成另一种形式之前大概需要过这么个流程: Lex -&gt; Parse -&gt; Compile 接下来逐步讲解这个过程。 Lexer就是分词器，输入用户提供的代码接着把他分成 tokens，也就是 tokenstream。你肯定看不懂上面那句话的意思，让我们来点实例：a.value 里的那个 ArrayList 就是一个 token stream，str 是被解析的代码。不难发现，语句被 Lexer 按顺序进行了分类以及数据的分割，如 a 被识别为了一个 Identify (标记)。 因此也可以归纳出来 Token 大致的代码长啥样： 1234567@AllArgsConstructor@Getterpublic class Token { private int line; private Type type; private String content;} ParserLexer 从源码中提取出 token stream 后将会交给 Parser 处理，它负责对 token stream 进行解析，生成一个 AST (Abstract Syntax Tree)，也就是 抽象语法树。 这张图直观的描述了这一过程，你可以看到它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。 接着，AST 将会丢给代码生成器用于生成代码，但是一般会先对 AST 进行优化，例如 常量折叠 Static Analyzing但在这之前，我们还有一些问题要解决。其实这玩意我是和 Parser 写一块的试想一下，如果有这样一行代码： 1var i = love + cats 代码生成器如何知道 love 和 cats 是什么？ 在 Parser 的眼里，他们只是 Identifier，然而它们之间不能相加减。 在这种时候，Parser 需要预先建立一个符号表，这样他才能找出 love 和 cats 究竟是什么以及是否能够编译。 同理，下面的代码也一样需要这一过程： 123456import java.util.Listvoid main(List&lt;String&gt; args){ // 此处 Parser 将会分析出 java.lang.String 和 java.util.List NullCat nc = new SBNC(); // 按照 Java 的逻辑，此处没有导入（或同包）于是会产生错误，因为Parser找不到 SBNC / NullCat} Code Generation接着是生成代码！一般编译器都会输出一种 IR (Intermediate Representation) 码，而他的作用则是一种中间表示。例如，如果你输出 LLVM 的 IR 码，那么接下来你的编译工作（win,x64,linux,…jvm）就可以交给 LLVM 来完成，而像 LLVM 这样负责最后这一步骤的我们称之为 编译器的后端 使用这一种方法有几个好处： 它可以使得开发者更专注于 语言设计 而不用过多的考虑 优化，因为大多数编译器后端会帮你完成这件事情 ，除非你直接输出汇编那就得你自己负责优化了。 IR 是中间表示，它可以按照相同的语义编译出不同平台，不同架构的代码，大大节省了开发者时间 … 处于个人习惯，我选择了 Java 的字节码作为 “IR”，他将会被 JVM 加载并在运行过程中收集数据被更好的优化以及可以享受和 Java 互操作，跨平台的优势。 0x02 实践知道了这些理论，我们立即可以开始编写我们的第一个 Lexer 了。 这是我们这一大章节的目标代码： 12345using java.util.Listfn main(args: List&lt;String&gt;){ println &quot;hello world!&quot;} 那么，让我们开始吧！下文将会有大量代码，为了可读性，我会删掉一些无关紧要的部分。 Lexer我的 Lexer 分为两步：fuzzyTokenize 和 tokenize。实际上这是取决于做法的，有正则转 DFA（状态机）的，也有直接 charStream 的。 我选择了第二种，因为我认为使用正则的代码可读性比较糟糕，不易于维护。那么，让我们开始做一些准备工作… 123456789public class Lexer { private final String fileName; private final String rawContent; public Lexer(String content,String fileName) { rawContent = content.replaceAll(&quot;//.*|(\\&quot;(?:\\\\\\\\[^\\&quot;]|\\\\\\\\\\&quot;|.)*?\\&quot;)|(?s)/\\\\*.*?\\\\*/&quot;, &quot;$1 &quot;); // remove comments. this.fileName=fileName; }} 从构造方法接受源代码和文件名并且删除注释。你可能会问文件名用来干啥，那当然是用来报错的～接着，还有一个 LexedNode 用来表示 fuzzyTokenize 后的产物。 1234567891011121314public class LexedNode { private NodeType type; private String content; // 初始化和getter... public enum NodeType { IDENTIFIER,SYMBOL,KEYWORD,OPERATOR, LINE_SEPERATOR, LITERAL_STRING,LITERAL_NUMBER }} 这就是一个最基本的 token! 在后文，我们将会进行第二次 tokenize 使它变得更详细。 准备好了，开始写吧！首先是一个状态机： 1234567891011121314public List&lt;LexedNode&gt; fuzzyTokenize() { char[] charStream = rawContent.toCharArray(); List&lt;LexedNode&gt; nodes = new ArrayList&lt;&gt;(); int line = 1; for (int i = 0; i &lt; charStream.length; i++) { // 使用 fori 是为了循环时移动指针 char now = charStream[i]; switch (now) { case '\\n': nodes.add(new LexedNode(NodeType.LINE_SEPERATOR,&quot;\\n&quot;)) continue; // 此处使用 continue 立即跳到下一次循环 } } return nodes;} 这就是你的第一个 Lexer，可以先输出一下看看结果： 123456789LINE_SEPERATORLINE_SEPERATORLINE_SEPERATORLINE_SEPERATORLINE_SEPERATOR 因为代码有五行，因此是五个 LINE_SEPERATOR。只有换行符可不够，我们还要识别 KEYWORD ，也就是关键词。然而关键词使用空格分割，因此我们可以这样做： 123456789101112131415161718192021switch(...){ //... case ' ': inIdOrLiteral = !inIdOrLiteral; if (inIdOrLiteral) { // start collecting continue; } // end! String str = buffer.toString(); identifierParse(str, nodes); buffer = new StringBuilder(); // compose continue; // 此处换行同理}//.../* Collect String or Identifier */ if (inIdOrLiteral) { buffer.append(now); continue; } 你可以看到，我们引入了两个新的变量和一个方法，它们分别是 inIdOrLiteral 和 buffer 以及 identifierParse。 inIdOrLiteral 表示当前是否正在遍历一个 Identifier 或者一个字面量buffer 用于收集这个字面量，当然你也可以使用 substring 和 charAt 的方法identifierParse 是一个方法，他用于分类 Identifier。对于 11，他会分类成一个 LITERAL_NUMBER，对于 not_a_keyword，他会分类成一个 identifier，对于 fn，他会分类成一个 Keyword。 还没完，天资聪颖的你肯定已经注意到了这里少了一样东西——我要怎么匹配最开头的一个 using ？ using 的前头可没有一个空格。这时你可以回忆一下，在各种编程语言中作为 Identifier 的符号应该符合什么规则….是的，他们通常不会以运算符作为开头，以及他们不是一个关键字，因此我们还可以利用这个特性写出这样的代码: 1234567891011121314151617181920212223242526 /* Other Symbols */ if (SYMBOL_OR_OPERATORS.contains(now）) { if (inIdOrLiteral) { // keyword // now == a symbol,we should end this. identifierParse(buffer.toString(), nodes); buffer = new StringBuilder(); inIdOrLiteral = false; } if (SYMBOLS.contains(now)) { nodes.add(new LexedNode(now, LexedNode.NodeType.SYMBOL)); continue; } else if (OPERATORS.contains(now)) { nodes.add(new LexedNode(now, LexedNode.NodeType.OPERATOR)); continue; } else { throw new LexerException(fileName+&quot;: Unknown char: &quot; + now+&quot; line: &quot;+line); } } else { inIdOrLiteral = true; // not symbol &amp; not identifier }/* Collect String or Identifier */ if (inIdOrLiteral) { buffer.append(now); continue; } 这一段代码将会在匹配第一个字符没有遇到语言规定的操作符或者特殊符号的时候把 inIdOrLiteral 设置为 true。配合上面的代码，在遇到一个空格的时候他会结束收集并且尝试判断是什么。 实际上应该是 switch 的任务但是写成 if 更加直观一些。 那么到现在，我们可以开始尝试代码了！这是 Lexer 的输出： 12345678910111213141516171819202122232425262728KEYWORD usingIDENTIFIER javaOPERATOR .IDENTIFIER utilOPERATOR .IDENTIFIER ListLINE_SEPERATOR LINE_SEPERATOR KEYWORD fnIDENTIFIER mainSYMBOL (IDENTIFIER argsOPERATOR :IDENTIFIER List&lt;String&gt;SYMBOL )SYMBOL {LINE_SEPERATOR KEYWORD println- LITERAL_STRING hello world!+ IDENTIFIER &quot;hello+ IDENTIFIER world!&quot;LINE_SEPERATOR SYMBOL }5: RIGHT_BRACKET } 相比你已经注意到了，理应出现的 LITERAL_STRING 被两个 IDENTIFIER 代替了，这显然不是我们想要的结果。因此，我们要给 String 加入特 殊 支 持 1234567891011121314151617switch(now){ case '&quot;': if (i != 0 &amp;&amp; charStream[i - 1] != '\\\\') { // string starts or end inIdOrLiteral = !inIdOrLiteral; stringMode = true; if (!inIdOrLiteral) { stringMode = false; // a new string! nodes.add(new LexedNode(buffer.toString(), LexedNode.NodeType.LITERAL_STRING)); buffer = new StringBuilder(); continue; } } continue; //...} 以及 1234 case ' ':+ if (stringMode) {+ break;+ } 12- if (SYMBOL_OR_OPERATORS.contains(now)) {+ if (SYMBOL_OR_OPERATORS.contains(now) &amp;&amp; !stringMode) { 这样我们就躲开了这个陷阱，完成了对于 String 的支持后，我们的 fuzzyTokenize 就做好了！ 关于 OPERATORS 和 SYMBOLS一门语言里的符号很多，你绝对不会想把他们一个个 add 到 list 里面的，但你可以写一个 loader 来解决这个问题 然后，是 tokenizer。fuzzyTokenize 输出的结果显然不足以交给 Parser 做解析，我们需要使i结果更加详细。 好在经过 fuzzyTokenize 后代码已经被格式化成了比较模糊的 Token Stream，这一点使我们写第二次 tokenize 的时候会轻松很多，因为你不会再见到 inIdOrLiteral 和 stringMode 这种让人抓狂的东西了。 首先，让我们从一个新的 Token 开始（你不会想和 LexedNode 混一块的）: 1234567891011121314151617181920212223242526272829@AllArgsConstructor@Getterpublic class Token { private int line; private Type type; private String content; public enum Type{ IDENTIFIER(&quot;&quot;), CLASS(&quot;class&quot;),FUNCTION(&quot;fn&quot;),ANNOTATION(&quot;annotation&quot;),FOR(&quot;for&quot;),WHILE(&quot;while&quot;),IF(&quot;if&quot;),USING(&quot;using&quot;) ,THIS(&quot;this&quot;),TRUE(&quot;true&quot;),FALSE(&quot;false&quot;),ELSE(&quot;else&quot;),VAR(&quot;var&quot;),NULL(&quot;null&quot;),PRINTLN(&quot;println&quot;), // KEYWORDS VAL(&quot;val&quot;), LEFT_BRACE(&quot;(&quot;),RIGHT_BRACE(&quot;)&quot;), LEFT_BRACKET(&quot;{&quot;),RIGHT_BRACKET(&quot;}&quot;), LEFT_MID_BRACE(&quot;[&quot;),RIGHT_MID_BRACE(&quot;]&quot;), COMMA(&quot;,&quot;),DOT(&quot;.&quot;),MINUS(&quot;-&quot;),PLUS(&quot;+&quot;),STAR(&quot;*&quot;),SLASH(&quot;/&quot;), // operators BREAK_LINE(&quot;\\n&quot;),ASSIGNMENT(&quot;=&quot;),EQUALS(&quot;==&quot;),SEMICOLON(&quot;;&quot;),AT(&quot;@&quot;),COLON(&quot;:&quot;), LITERAL_STRING(&quot;&quot;),LITERAL_NUMBER(&quot;&quot;); // literals @Getter private String def; Type(String def){ this.def=def; } }} 比上文的 LexedNode 详细了很多——比如他主动去分类 keyword 了。接着是一个 fori ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public Pair&lt;String,List&lt;Token&gt;&gt; tokenize() { var lexedNodes = fuzzyTokenize(); var tokens = new ArrayList&lt;Token&gt;(); var line = 1; for (int i = 0; i &lt; lexedNodes.size(); i++) { LexedNode lexedNode = lexedNodes.get(i); switch (lexedNode.getType()) { case LINE_SEPERATOR: tokens.add(new Token(line, Token.Type.BREAK_LINE,&quot;&quot;)); line++; break; case SYMBOL: case KEYWORD: var type = Arrays.stream(Token.Type.values()).filter(e -&gt; e.getDef().equals(lexedNode.getContent())).findFirst().orElseThrow(()-&gt;{ return new NullPointerException(lexedNode.toString()); }); tokens.add(new Token(line, type, type.getDef())); break; case LITERAL_STRING: tokens.add(new Token(line, Token.Type.LITERAL_STRING, lexedNode.getContent())); break; case LITERAL_NUMBER: tokens.add(new Token(line, Token.Type.LITERAL_NUMBER, lexedNode.getContent())); break; case OPERATOR: // = boolean isEnd = (i == lexedNodes.size() - 1); switch (lexedNode.getContent()) { case &quot;=&quot;: if (isEnd) { throw new LexerException(fileName+&quot;: Invalid syntax line &quot;+line); } if (lexedNodes.get(i + 1).getType() == LexedNode.NodeType.OPERATOR &amp;&amp; lexedNodes.get(i + 1).getContent().equals(&quot;=&quot;)) { // == tokens.add(new Token(line, Token.Type.EQUALS, &quot;==&quot;)); i = i + 1; // skip next break; } else { tokens.add(new Token(line, Token.Type.ASSIGNMENT, &quot;=&quot;)); } break; case &quot;.&quot;: tokens.add(new Token(line, Token.Type.DOT, &quot;.&quot;)); break; case &quot;,&quot;: tokens.add(new Token(line, Token.Type.COMMA, &quot;,&quot;)); break; case &quot;-&quot;: tokens.add(new Token(line, Token.Type.MINUS, &quot;-&quot;)); break; case &quot;+&quot;: tokens.add(new Token(line, Token.Type.PLUS, &quot;+&quot;)); break; case &quot;*&quot;: tokens.add(new Token(line, Token.Type.STAR,&quot;*&quot;)); break; case &quot;/&quot;: tokens.add(new Token(line, Token.Type.SLASH,&quot;/&quot;)); break; case &quot;;&quot;: tokens.add(new Token(line, Token.Type.SEMICOLON,&quot;;&quot;)); break; case &quot;:&quot;: tokens.add(new Token(line,Token.Type.COLON,&quot;:&quot;)); break; } break; case IDENTIFIER: tokens.add(new Token(line, Token.Type.IDENTIFIER, lexedNode.getContent())); break; } } return Pair.of(fileName,tokens);} 这段代码并不难懂。在这个例子中，我们遍历来自 fuzzyTokenizer 的数据并且通过 switch 分类枚举来处理把他们转化成 Token 来表达并且存储到 tokens。对于 symbol 和 keyword，我们通过直接搜索 enum 内值的方法避免写出了像 case OPERATOR 里更糟糕的代码。 case OPERATOR 里写成这样是为了双符号操作的支持，例如 == 回到原题，这次我们可以通过 tokenize 解析出这样的结果： 123456789101112131415161718192021221: USING using1: IDENTIFIER java1: DOT .1: IDENTIFIER util1: DOT .1: IDENTIFIER List1: BREAK_LINE 2: BREAK_LINE 3: FUNCTION fn3: IDENTIFIER main3: LEFT_BRACE (3: IDENTIFIER args3: COLON :3: IDENTIFIER List&lt;String&gt;3: RIGHT_BRACE )3: LEFT_BRACKET {3: BREAK_LINE 4: PRINTLN println4: LITERAL_STRING hello world!4: BREAK_LINE 5: RIGHT_BRACKET }5: RIGHT_BRACKET } 是不是详细了很多？接着我们就可以靠着这个写一个 Parser了 在 Parse 之前在 Parse 之前，我们需要先做一次 Static Analyzing。在这个阶段，Parser 会对文件里的类型和导入表作出关联，同时也是多文件编译的基础。 Metadata你不可能靠着所有人的源码来建立索引，而且源码中的无用信息太多了。实际上，确定符号链接只需要这些信息： 1234567@Datapublic class CatMetadata { private ClassDef classDefinition = new ClassDef(); private Map&lt;String,CatMetadata&gt; cachedUsings = new HashMap&lt;&gt;(); // 这是对于被解析对象才有的 private List&lt; MethodSign&gt; methods = new ArrayList&lt;&gt;(); private Map&lt;String, VariableDef&gt; fields = new HashMap&lt;&gt;();} 关于 ClassDef, MethodSign, VariableDef 等信息本文不贴出，因为并不会影响观看体验。如果有兴趣，可以在这里找到他们相对应的具体代码 以及一个编译器全局索引，用 FQDN 确定唯一性的 Map: 123456789101112131415public static class Global { private static final Map&lt;String,CatMetadata&gt; GLOBAL_METADATAS = new HashMap&lt;&gt;(); public static final CatMetadata forClass(String str){ /* * Scan compiler classPaths */ var meta = NullCatCompiler.solveMeta(str); if(meta!=null) { GLOBAL_METADATAS.put(str, meta); }else{ meta = NullCatCompiler.solveMeta(&quot;java.lang.&quot; + str); } return meta; } } 准备就绪，我们来单独拿出一个类作为 MetadataGenerator 状态机 1234567@RequiredArgsConstructorpublic class MetadataGenerator { private final String fileName; private final List&lt;Token&gt; tokens; private CatMetadata cm = new CatMetadata(); private int i=0;} 接着，是提取数据的部分: 1234567891011121314151617181920212223242526272829303132333435363738public CatMetadata gen(){ for (i = 0; i &lt; tokens.size(); i++) { Token now = tokens.get(i); boolean end = (i==tokens.size()-1); Token next = end?null:tokens.get(i+1); switch(now.getType()){ case USING: if(!end){ i=i+1; var clazz = readAsStringUntilLB(); cm.getCachedUsings().put(clazz, Optional.ofNullable(CatMetadata.Global.forClass(clazz)).orElseThrow(()-&gt;new ParseException(&quot;Can't find clazz &quot;+clazz))); }else{ throwEOF(); } continue; case FUNCTION: if (end) { throwEOF(); } // fn main(){} if(next.getType() != Token.Type.IDENTIFIER){ throw new ParseException(fileName+&quot;: Unexcepted &quot;+next.getType()+&quot; at line &quot;+now.getLine()); } String methodName = next.getContent(); i=i+1; // Move Pointer to ( MethodSign sign = readMethodSign(methodName); if(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode())){ throw new ParseException(fileName+&quot;: Duplicated method: &quot;+sign+&quot; at line &quot;+now.getLine()); } cm.getMethods().add(sign); skipCodeBlocks(); continue; // ... } } return cm;} 在这个循环当中，我们通过获取到 Token 的类型来判定需要做的操作，这是基于语言设计定义来做的—— 例如 fn 的后面必然是一个方法签名，而不可以是别的。最终 MetadataGenerator 将会返回一个 CatMetadata 以供后续操作。 因此，这一阶段我们也可以发掘出类型错误和大的语法错误。 与 Java 的世界我们需要和 Java 交互，因此我们需要给 Class 建立 CatMetadata 。好在这很简单，因为 CatMetadata 需要的所有数据都可以通过反射获取，这里提供一段参考代码： 123456789101112131415161718192021222324252627282930@AllArgsConstructorpublic class ClassMetaPathImpl implements MetaPath{ private ClassLoader classLoader; @Override public CatMetadata findClass(String clazz) { CatMetadata cm = new CatMetadata(); Class&lt;?&gt; claz = Util.runCatching(()-&gt;{ return Class.forName(clazz,false,classLoader); }).getResult(); if(claz==null){ return null; } for (Field declaredField : claz.getDeclaredFields()) { if(!Modifier.isPublic(declaredField.getModifiers())) continue; VariableDef def = new VariableDef(declaredField.getType().getCanonicalName(),declaredField.getName()); cm.getFields().put(declaredField.getName(),def); } for(Method declaredMethod: claz.getDeclaredMethods()){ if(!Modifier.isPublic(declaredMethod.getModifiers()))continue; MethodSign sign = new MethodSign(declaredMethod.getName(), (ArrayList&lt;String&gt;) Arrays.stream(declaredMethod.getParameterTypes()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList())); cm.getMethods().add(sign); } ClassDef cdf = new ClassDef(); cdf.setClassName(clazz); cdf.setSuperclass(claz.getSuperclass()==null?null:claz.getSuperclass().getCanonicalName()); cdf.setInterfaces(Arrays.stream(claz.getInterfaces()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList())); cm.setClassDefinition(cdf); return cm; }} 静态分析结束后，我们就要准备开始生成 AST 了。 附我们从 token 流中获取数据，并且根据类型进行匹配——但我们其实没有用到状态仔细看，你会发现这个东西： 123456789 i=i+1; // Move Pointer to (+ MethodSign sign = readMethodSign(methodName); if(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode())){ throw new ParseException(fileName+&quot;: Duplicated method: &quot;+sign+&quot; at line &quot;+now.getLine()); } cm.getMethods().add(sign);+ skipCodeBlocks(); continue; 是不是有些象是 DSL？这其实归咎于类字段中那个不起眼的 int i = 0，它使得 for 循环的指针可以被整个类里的方法所共享。 12345678910private final String readAsStringUntilLB(){ // 一只读，读到一个换行为止并且收集成字符串 StringBuilder sb = new StringBuilder(); int b=0; for(int a = i; tokens.get(a).getType()!= Token.Type.BREAK_LINE;a++){ sb.append(tokens.get(a).getContent()); b=a; } i = b; return sb.toString();} 在经过更加详细的 tokenize 之后，代码实际上变得更加可观了， Parser先占个坑位～","link":"2021/10/01/Writting-A-Compiler-1/"},{"title":"使用 cproxy 对程序进行透明代理","text":"在 Windows 下，说到 透明代理 ，你可能会想到 Proxifier , SSTap, Mellow但在 Linux 下，你可能会想到 proxychains 然后再想到 proxychains 不能代理 static-linked 的程序。 为什么 ProxyChains(NG) 不能代理静态连接的程序ProxyChains NG 通过一个预加载的共享库来hook到网络相关的函数(比如: connect,getaddrinfo)上，接着他就可以转发这些流量。缺点似乎显而易见，如果只是通过 LD_PRELOAD 来进行透明代理，那么这招对于静态连接的程序是无用的（比如说 Go 程序..)其次，ProxyChains 只支持 TCP，这可能导致无法转发 DNS 流量 -&gt; DNS 流量泄漏。 cproxy 是什么cproxy 也是透明代理，作用和 proxychains 类似。原理上与 proxychains 不同，它使用 cgroup 进行对程序的代理 ，不过配置起来还有点麻烦本文将会教您在您的Linux PC上使用 cproxy，截至本文发布之前，cproxy似乎只支持 Linux。 下载 cproxy官方推荐的方法是: 直接用 cargo 1cargo install cproxy 如果没有 cargo 可以在 Release 上下载压缩包。解压压缩包，可能会发现有两个可执行文件，不过似乎只留一个就好了。 安装 cproxy先来试一试 cproxy！ 1cproxy --port &lt;本地代理端口&gt; -- curl ip.sb ( ｀д′) 失败了如果你和我一样，在port上写了 socks5 的代理端口，那么你就被坑了。笔者填入 geph 的 HTTP 代理端口时是可以成功的，但是使用 v2ray 的s5/http端口都无法使用。这是因为 cproxy 需要修改 v2ray 的配置进行兼容，如果你不想去改配置 在确保可以使用 cproxy 后，我们来配置 alias。将以下内容写到 ~/.bashrc，记得自己修改一些部分。 alias &quot;px&quot;=&quot;/path/to/cproxy --port &lt;your-local-proxy-port&gt; --&quot; 例如我的配置： alias &quot;px&quot;=&quot;/bin/cproxy --port 60080 --use-tproxy -- &quot; # 60080 是ipt2socks的默认监听端口。 保存后，使用 source ~/.bashrc 载入，试试 px curl ip.sb，看看是否成功。 缺陷每次使用都要 sudo ，还是挺烦人的吧…对于这种情况，也可以考虑使用有后台常驻的 cgproxy，但本文不做介绍，有兴趣可以自己了解。","link":"2021/03/13/%E4%BD%BF%E7%94%A8-cproxy-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/"},{"title":"2021 碎碎念","text":"2022 早就来了，但是我的年终总结推迟了好些时候才开始写。如果是在之前的话，我大概新年一到就很迫切的把去年发生了什么事通通写下来的。 说是年终总结，不如说是对于去年发生的事情碎碎念。真要说起来的话，其实我感觉去年好像也没fa发sheng生le什da么shi事qing情。开了不少坑，虽然后面也没有完成几个坑。一是没时间，二是大多时间都用在摸鱼上了。 技术力仍然在提高，除了认识到了新的人，也对以往认识的人有了更深的认知。 今年猫猫还是没有回来，想它。 抑郁后的那段时间貌似有开始写小说… 不过写了几天很快也暂停了，最终还是没有想好我要写一个什么样的故事啊～还是多加沉淀再下笔吧。虽然说从初中开始就总是想写点什么东西。但是写什么呢？ 透过窗外看到一些新鲜事物的时候，我总是能代入一个新鲜的故事环节里。如果细挖那些故事的设定肯定很不错的吧。 vape 还是没有破解掉。两年了，从初三到高二，但我已经把进度推进到了我暂时无法触及的领域，也算是比较骄傲的一件事情（也有朋友们的帮助），不过也没什么兴趣了 暑假结束之后分配到了新的班级，算是远离之前那一帮人了。新的班级里也表现的不太自在，然而我无法允许自己跟他们同流合污，我也有想坚守的行为底线。 心理变态，三观不正以貌取人的极端主义者难道不应该被教育淘汰或拯救吗？然而他竟在学校里成为一种典型。 更新的班级里是更旧的班主任。他不是童话书里的园丁，只不过有的老师是。 现实刺穿了我的后背，但我宁愿相信那里没有血迹。 又比去年浮躁了许多，可能是自从上了高中天天在学校留宿便也无处享清净以修身养性了。宿舍里是浮躁的人，班级里也是浮躁的声音，谈何学习？ … 年终总结，过去，现在，未来，亦如此。大概会是我最后一次写这东西了 感谢 4d3b2d63a26f50fd6eaa243921f37b459448fe91e9f86bb624eb084dacd895d6 。Powerful friendship 本来想更新几篇和泛型相关的文章的，还是看时间吧。写一篇年终碎碎念也得花不少时间呐","link":"2022/02/09/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"title":"一种使用 &#x2F;transfer 的轻量化子服方案","text":"李华是一个生电服的玩家，他总是在想，要是服务器里面有创造实验室就好了。 小叶是一个喜欢 PvP 的玩家，他总是在想，要是服务器里面有一个能干脆利落开启决斗的地方就好了。 作为这个服务器的 OP，这些场景对你来说不陌生。如果把这两个问题抛在 Minecraft 服务器社区里，相信绝大多数的回答都是「开一个新的子服务器并且建立跨服群组」，但是，这真的值得吗？ info这篇文章在 blog stash 上有着更好的阅读体验 显然，这不值得。如果只是为了这两样功能启动一个跨服群组，你将会面临以下问题： 额外的维护成本： 使用群组服则基本排除了面板服务器部署方案的可能性，并且一个没有适当配置过的群组服务器会引起诸多问题，例如：玩家使用 /server 跳过验证关卡，子服务器的端口意外的暴露在外网等等。 资源需求上升： 启动额外的子服 + 代理程序则意味着你需要更多的资源。Java 主流 GC 的策略通常都会为了速度而将堆所占的空间悉数预分配，这导致即使程序使用的内存并没有那么多也会造成较高的 RSS. 资源分配不灵活：上一个问题并不能简单的通过减少堆的大小解决。就以创造实验室为例，平时服务器内的人并不多，但一旦到了演示/大型机器实验时，较小的堆空间将会给 GC 带来相当的压力，并且无法利用到分配到其他（类似情况的，比如 PvP 竞技场）子服的空闲资源。 …… 光是想到从单端变群组，大多数服主就已经汗流浃背了。那么，本文所述的基于 transfer 机制的方案是如何规避这些问题的呢，他与其他类似方案又有何优劣之分呢？ 基于世界的子服划分方式这个情境中使用群组方案，归根结底是为了做服务器区域之间的划分。而 Minecraft 自带的多世界机制就已经很好的解决了活动空间的划分问题：没有传送门的情况下，玩家并不能随意大小跨。 早在 2013 年，PerWorldPlugins 就已经实现了将插件的生效范围降级到世界层次。通过切割插件在整个服务器中的作用域，这些世界得以模拟「服务器的子服」，使用此插件的用户可以通过限定不同世界里启用的插件来模拟多服务器的效果。而在约 2020 年，Valorin 的 DuelTime / Dantiao (付费) 将这个概念进一步推进，完全实现了本文引入部分时提到的「干脆利落开启决斗的地方」的设想。 然而，这样实现引入了许多需要额外维护的状态：生存服的玩家不能将物品带到创造服，他们也不希望在 PvP 服丢掉自己一身的好装备。插件需要小心翼翼的维护好这些状态，在跨世界转移的时候将他们的背包数据暂存起来，甚至有必要储存到硬盘上以防 崩服/断电/插件自身异常 导致数据丢失（数据无价！）。 并且，除了物品数据，还有许多问题需要考虑，比如玩家身上的 scoreboard / team 数据，其他插件储存的玩家相关的状态数据都可能会导致数据切割不干净。甚至如果这些插件涉及到储存功能，例如类末影箱类插件，邮箱等，被滥用的后果不堪设想。 而本文所述的方案使用 transfer 特性解决这些问题。 Transfer 是什么/transfer 命令 是一项在 1.20.5 才被加入的新特性。如果你不知道他，只需要看这条命令的语法就可略知一二： /transfer &lt;hostname&gt; &lt;port&gt; [players] 他可以让玩家的客户端主动连接加入另一个服务器。那么这有什么用呢？ 首先我们要知道，Minecraft 中玩家是以 UUID 而不是名称确定的。因此，理论上可能发生这样的情况： 虽然他们的名字相同，但是他们的 UUID 不同，因此他们就是不同的玩家，而且账号数据也是毫不相干的（除了一些插件使用名称辨别，这是错误的做法）。 在一般情况下，玩家的 UUID，伴随着他的 GameProfile{name, id} 离开 Login State （也就是进入游戏）后就不可变了。如果想变更它的 UUID，我们只能在指派 Profile，也就是登录的时候做处理，否则会导致很多异常行为甚至数据损坏，服务端崩溃等。 但是这样做又引入了一个新的问题，也就是玩家体验不佳。他们需要在游戏内指定下一次登录时用的 GameProfile，然后退出重进，体验十分不好。并且对于离线玩家，退出重进时我们如何确定玩家的身份？IP + 玩家名并不可靠，如果你的服务器有为海外玩家设置的代理，情况将更加糟糕。 而 Transfer + Cookie 机制就可以很好的解决这个问题。Transfer 用于无缝转移玩家到新的 “子服” 中，Cookie 用于辨识玩家的身份，接下来本文将会开始分析这两者，并且给出应用实例以帮助您理解我所描述的过程。 Transfer 机制的原理为什么 Transfer 能够让我们安全修改 GameProfile 呢？先从原理说起。如果你在一个服务器内使用 /transfer mc.hypixel.net 25565, 你将会得到一条错误信息。 这是因为对端服务器并没有启用 transfer 导致的，但服务器是如何知道我们正在使用 transfer 的呢？ 既然是在登录时出错，那么这段错误的区间应该能在 HandShake ~ Login 期间找到答案。翻阅文档，可以找到这一条目： 也就是说，客户端通过连接时候指定 nextState=3 标识该连接为 transfer 连接，并且，这个状态标识正好就在 Handshake 阶段。那么，如果我们 transfer 自己，玩家不就会把 Handshake → Play 的流程走个遍，而且我们还能知道他正在 transfer 回来了吗？ 将 Handshake → Play 走一遍，也就意味着他将会重新启动登录流程。换句话说，也就是我们将有一个修改 Game Profile 的窗口期。现在，修改 GameProfile 的问题解决了一半，玩家只需要和跨世界一样等一下黑屏就行了——如果他不满意，还可以直接点击断线。现在来看问题的另一半——我们如何辨别这是刚刚请求跨服的玩家，而不是从其他服务器 transfer 过来的玩家呢？ 与 Transfer 伴随而来的 Cookies 机制注意！ Cookies 机制是一个高度实验性的机制，Minecraft Wiki 上也没有记载与其相关的命令，并且 Notchian（也就是原版）服务端通常会直接拒绝处理客户端发来的 Cookie Response. 伴随着 /transfer 来到 1.20.5 的还有新的 cookies 机制，对，就类似你想的那个浏览器上的 cookies. Cookies 机制非常特别，它贯穿了 Minecraft 从 Login 到 Play 的所有 State。我们从 Login 开始就可以向客户端请求 Cookies, 而在 Play 阶段也仍然能操作 Cookies. 并且，客户端储存的 Cookies 数据对使用 /transfer 过程中的所有服务器可用，这使得本方案也易于拓展成多服务器无代理的形式，因为服务器间不需要额外同步状态（除了吊销令牌） 先来看看 Cookies 机制有关的三种包 Cookie Request/Response 在 Play 到 Login 的所有 State 中都可用，封包格式一致。而 Store Cookie 比较特殊，他在 Configuration 往后可用。使用 Cookie 机制，我们就可以有效辨别跨服流程中的玩家，避免外源，而且不需要额外登录验证措施，因为 Cookies 数据只在 /transfer 中涉及的服务器里有效，当玩家主动离线后，Cookies 数据将会丢失。（这也是他的一个弱点） 由这两个机制，我们可以设计出这样一个简单的流程： [PLAY] 玩家请求跨服（准备 Transfer） 此时玩家会将需要加入的子服名称告诉服务器。 [PLAY] 储存 Cookies 到客户端 我们将玩家请求的子服名称作为 Cookies 存入玩家的客户端中，准备开始”跨服”。 [PLAY] 进入重配置阶段 我们发送 Start Configuration (0x69) 将玩家的客户端重置到 Configuration State. 在这个阶段，我们可以安全的准备 Cookies 和房间设施。（注意时间长了是可以点 Disconnect 的，不是不能） [CONFIG] 发送 Cookies 给客户端，并等待。 注意！ 客户端支持的 Cookie 的 Value 负荷上限为 5KiB, 不要超过这个数值 [CONFIG] 开始 Transfer 到自己（发送 Transfer (0x0B)） 此时客户端从服务器断开连接，但他即将重新连接。 [LOGIN] Login State 下，我们可以确定客户端的 Cookies，为其依据 Room ID 计算一个新的 UUID 覆盖掉原本 GameProfile 中的结果 note这个过程可以做到和正版验证不冲突，因此正版玩家仍然可以在登录之后才能进入服务器。你也可以直接根据 Cookies 直接放行 [PLAY] 玩家以”新玩家但同名”的身份成功加入游戏 数据和之前同名字不同 UUID 的存档完全隔离，你可以安全的对他做任何事情，比如传送到一个新世界的地皮并且赋予创造模式。 以下是具体实现环节，命名均来自 1.21 Yarn Mapping。 实例：使用 /goto 在服务器内反复横跳如果你喜欢直接看代码，可以直接看我的这个 spike test，但本文中的代码相对更加清晰一些（重写了）。 本篇文章讨论的特性正在 sfcraft 中被应用，欢迎留个 star。 接下来是我踩坑的总结 首先，为了辨别一下当前的 GameProfile, 写个提示工具： 123456private void onJoin(ServerPlayNetworkHandler handler, PacketSender sender, MinecraftServer server) { var profile = handler.player.getGameProfile(); handler.player.sendMessage(Text.of(&quot;Your uuid: &quot; + profile.getId())); handler.player.sendMessage(Text.of(&quot;Is room player: &quot;+ Helper.isRoomPlayer(profile))); handler.player.sendMessage(Text.of(&quot;Room id:&quot; + rooms.get(profile)));} 这个工具的逻辑比较简单，因此不多赘述，他能帮助你了解后面发生了什么事。 过程的第一步是玩家请求 transfer, 这里我用一个命令 /goto &lt;room&gt; 来做，让我们看看这个命令的逻辑： 12345678910111213private int onGoto(CommandContext&lt;ServerCommandSource&gt; ctx) { var room = ctx.getArgument(&quot;room&quot;, String.class); var player = ctx.getSource().getPlayer(); if (player == null) { return -1; } var network = player.networkHandler; network.reconfigure(); network.send(new StoreCookieS2CPacket(IDENTIFIER_ROOM, room.getBytes(StandardCharsets.UTF_8)), PacketCallbacks.always(()-&gt;{ network.sendPacket(new ServerTransferS2CPacket(&quot;localhost&quot;, serverSupplier.get().getServerPort()));); })); return 0;} 乍看没什么，但是这里其实有个雷，就是我没有直接发 Start Configuration (0x69) 而是使用了 network.reconfigure()，他们之间有什么区别吗？有，大大的有，因为你要是直接发包 1234[23:18:10] [Server thread/INFO] (Minecraft) iceBear67[/127.0.0.1:38938] logged in with entity id 11 at (673.0034440744827, 73.7776368487581, 2774.6987246258886)[23:18:10] [Server thread/INFO] (Minecraft) iceBear67 joined the game[23:18:14] [Server thread/INFO] (Minecraft) iceBear67 lost connection: Internal Exception: io.netty.handler.codec.EncoderException: Pipeline has no outbound protocol configured, can\\'t process packet net.minecraft.network.packet.s2c.play.ChunkDeltaUpdateS2CPacket@31cb9619[23:18:14] [Server thread/INFO] (Minecraft) iceBear67 left the game 他就会爆 因为你光发这个包，两端的状态是对不上的，我们点开 configure 的实现就能看到： 123456public void reconfigure() { this.requestedReconfiguration = true; this.cleanUp(); this.sendPacket(EnterReconfigurationS2CPacket.INSTANCE); this.connection.transitionOutbound(ConfigurationStates.S2C);} 对比一下，如果你直接发，服务端这边并不会 transitionOutbound 到 ConfigurationState, 所以我们需要使用这个包装好的方法才能正常进入状态。 info这里发 Transfer 最好放到 PacketCallbacks 中，避免可能的问题。 noteServer Transfer 包需要填写 IP 和 Port, 你可以手填，但还有一种更加稳定的方法。 在 Handshake 阶段，我们可以看到： 可以发现，客户端是会发送他们使用的 IP 和端口的。如果使用这里的凭据我们就可以适配上述的海外代理情形，而 Hypixel 实际上也使用这种方法来封禁 TCP 转发（虽然很容易被绕过）。说到这里，其实还可以用 Transfer 做代理 IP 检查，但是超出了本文的范畴，欢迎读者研究分享经验。 到这里为止，玩家进入了 Configuratation 状态，接收到了 Cookies 而且即将要开始他的 Transfer 了，我们要准备迎接他。 迎接 Transfer 玩家在上一步结束之后，玩家会从服务器断线并且尝试重新加入（客户端提示： Transferring to new server ） 根据上面所述的流程，我们要在他进入 Login State 时指派他将使用的 GameProfile. 在 Yarn 命名表中，负责该流程的类为 ServerLoginNetworkHandler, 我们找到它的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ServerLoginNetworkHandler implements ServerLoginPacketListener, TickablePacketListener{ // ... 无关代码被忽略 private volatile ServerLoginNetworkHandler.State state = ServerLoginNetworkHandler.State.HELLO; private final boolean transferred; // &lt;- 这就是上文说的标识 public ServerLoginNetworkHandler(MinecraftServer server, ClientConnection connection, boolean transferred) { // ... 无关代码被忽略 this.transferred = transferred; } @Override public void tick() { if (this.state == ServerLoginNetworkHandler.State.VERIFYING) { this.tickVerify((GameProfile)Objects.requireNonNull(this.profile)); } // ... 无关代码被忽略 } @Override public void onHello(LoginHelloC2SPacket packet) { // 登录入口从这里开始 Validate.validState(this.state == ServerLoginNetworkHandler.State.HELLO, &quot;Unexpected hello packet&quot;); Validate.validState(StringHelper.isValidPlayerName(packet.name()), &quot;Invalid characters in username&quot;); this.profileName = packet.name(); GameProfile gameProfile = this.server.getHostProfile(); if (gameProfile != null &amp;&amp; this.profileName.equalsIgnoreCase(gameProfile.getName())) { this.startVerify(gameProfile); } else { if (this.server.isOnlineMode() &amp;&amp; !this.connection.isLocal()) { this.state = ServerLoginNetworkHandler.State.KEY; // 开始正版验证 this.connection.send(new LoginHelloS2CPacket(&quot;&quot;, this.server.getKeyPair().getPublic().getEncoded(), this.nonce, true)); } else { this.startVerify(Uuids.getOfflinePlayerProfile(this.profileName)); // 离线玩家流程 } } } void startVerify(GameProfile profile) { this.profile = profile; this.state = ServerLoginNetworkHandler.State.VERIFYING; } private void tickVerify(GameProfile profile) { // 最后的检查... this.sendSuccessPacket(profile); // 进入游戏 }} 发现 ServerLoginNetworkHandler 已经提供了一个 transferred 标识，我们不需要做额外处理来获取他。我们来想一下一个问题，如果要做 GameProfile 的指派，我们就需要 Cookies, 那么这个 Cookies 哪里来呢？于是乎，我们需要发一个 Cookie Request. 当客户端发来的 Cookie Response 到达后，他会调用该类里面的一个回调方法： 12345@Overridepublic void onCookieResponse(CookieResponseC2SPacket packet) { // 从这里也可以看出是实验性功能 this.disconnect(ServerCommonNetworkHandler.UNEXPECTED_QUERY_RESPONSE_TEXT);} 分析结束，接下来是实现环节。 实现功能观察这个类的代码结构可以发现，一个玩家加入服务器首先会从 onHello 出发，接着判断正盗版之后选择启动正版验证流程（State.KEY）或者是直接开始准备进入游戏（ startVerify） 但是，startVerify 并不直接开始进入游戏流程，而是设置 state = VERIFING 之后直接返回，等待 tick 时根据 State 指派调用到 tickVerify. 而和正版验证有关的 State.KEY 也是回归到 startVerify 里处理。由此，我们可以选择在 startVerify 下钩子，这样就可以兼顾正盗版问题，并且不会引入更多复杂问题。 思考题 如果我们想让玩家绕过正版验证登录，应该怎么做呢？ 在 startVerify 的 HEAD 处注入一段代码（接下来不会贴出全部代码）向玩家请求 cookie，并且阻止服务器进入 State.VERIFYING 状态，否则玩家会直接进入服务器。 12345678910111213141516@Inject(method = &quot;startVerify&quot;, at = @At(&quot;HEAD&quot;), cancellable = true)private void sf$queryCookies(GameProfile profile, CallbackInfo ci) { if (this.transferred) { switch(this.sf$cookieState){ case NOT_SENT: this.profile = profile; this.connection.send(new CookieRequestS2CPacket(HintModule.IDENTIFIER_ROOM)); this.sf$cookieState = SENT; break; } if(this.sf$cookieState != DONE){ ci.cancel() return; } }} 接着，我们要注入 onCookieResponse 从而得到对应的数据。 123456789@Inject(method = &quot;onCookieResponse&quot;, at = @At(&quot;HEAD&quot;), cancellable = true)private void sf$onRoomId(CookieResponseC2SPacket packet, CallbackInfo ci) { if (packet.key().equals(SOME_SERVER_IDENTIFIER_KEY)) { if(sf$cookieState != SENT) throw new IllegalStateException(&quot;Protocol error&quot;); var payload = packet.payload(); sf$roomId = new String(payload); } ci.cancel();} 这样我们就得到了子服务器的 ID，接下来我们要考虑恢复到 VERIFYING 状态的问题。 情况有两个： 没有正确 Cookie 的 Transfer: 玩家将会因为给不出 Cookie 超时从而掉线 给了 Cookie 并且正确: 进入 Profile 的指派流程 第一个情况不需要考虑，我们只需要考虑第二个。我选择的方法是在 tick() 尾巴多插入一段逻辑用于触发 startVerify: 1234567@Inject(method = &quot;tick&quot;, at = @At(&quot;TAIL&quot;))private void sf$awaitRoom(CallbackInfo ci) { if (sf$cookieState == SENT &amp;&amp; sf$roomId != null) { sf$cookieState = COOKIE_RECV; startVerify(this.profile); }} 到这里，又会回归到我们在 startVerify 下的 hook 里面。现在我们已经有了子服务器的 ID（ sf$roomId ），可以继续正式开始指派了。 1234567891011121314151617181920212223242526@Inject(method = &quot;startVerify&quot;, at = @At(&quot;HEAD&quot;), cancellable = true)private void sf$queryCookies(GameProfile profile, CallbackInfo ci) { if (this.transferred) { switch(this.sf$cookieState){ case NOT_SENT: this.profile = profile; this.connection.send(new CookieRequestS2CPacket(HintModule.IDENTIFIER_ROOM)); this.sf$cookieState = SENT; break;+ case COOKIE_RECV: + // 根据 roomId hash 出一个新的 profile 以此做到数据隔离+ // 当然在这里你还可以检查一下冲突情况+ this.profile = Helper.generateProfileForRoom(sf$roomId, this.profile); // 此处是之前存进去的 profile+ // 但是要注意：参数里的 profile 是原本的 profile,如果这里不 cancel 的话会把你设置的 profile 覆盖掉+ // 你也可以把这段注入到 TAIL 来避免问题+ this.sf$cookieState = DONE;+ this.startVerify(this.profile);+ ci.cancel()+ return; } if(this.sf$cookieState != DONE){ ci.cancel() return; } }} 到此，指派 Profile 的过程就完毕了。如果你的服务器和我的一样开了白名单，那么还要额外给予赦免。 info在 Cookies 被检查过的情况下，可以认为玩家的连接是可信的（但我这里没做签名校验） 12345@Redirect(method = &quot;tickVerify&quot;, at = @At(value = &quot;INVOKE&quot;, target = &quot;Lnet/minecraft/server/PlayerManager;checkCanJoin(Ljava/net/SocketAddress;Lcom/mojang/authlib/GameProfile;)Lnet/minecraft/text/Text;&quot;))private Text sf$bypassRoomPlayer(PlayerManager instance, SocketAddress address, GameProfile profile) { if (sf$cookieVerified) return null; return instance.checkCanJoin(address, profile);} 以下是示例： ![中间过渡]/(attachment/e7ab3fc4-c988-4b63-8666-cc6cbecc28fa.png “ =862x516”) 这篇文章完整的技术 demo 可以在 这里 找到 End / 总结总结一下。 优势使用 Transfer 机制可以帮助你让玩家拥有多个不同的账号数据（也就是存档），并且你可以根据这个特性设计出很多好玩的东西，而不只是子服。 再者，使用此方案较 BungeeCord / Velocity 类更加轻量，在开头所述的轻量级子服情境下有着更高的资源利用率，且无论是腐竹还是开发者的运维/状态维护状态都更低。 该方案实现的多存档可以完美的抵御掉电/插件 bug 带来的切换账号时数据丢失，而且 cookies 的应用也使得服务器能够在 transfer 的窗口期间确定盗版玩家的身份，避免同 IP 情况卡着窗口期错误登录或者是其他特殊的情况，并有望减少多个服务器间状态同步的棘手问题。 缺点难以对服务器进行扩容，且群组服情境下要使用这个方案较为复杂，需要代理支持。 机制术语表Transfer —— 一个让客户端重新启动加入服务器流程的机制 Cookies —— 配合 Transfer 机制使用，可以（仅）在 Transfer 期间让玩家客户端储存自定义数据，大小不超过 5KiB 保留节目这个功能其实主要也是服务器需求推动的，文章开头的两个需求都是真实的例子，而我也确实是面板服（悲） 自从去年高考之后已经很久没有更新文章了，这次刚好有材料写了，一次性更个大的，感谢大家支持。 感觉 Hexo 越来越难用了，没准我会迁移到 Outline 上面去。。 🥰 Thank you for reading this","link":"2024/07/17/multiserver-based-on-one-utilizing-transfer/"},{"title":"GPG 公钥更新","text":"—–BEGIN PGP SIGNED MESSAGE—–Hash: SHA256 由于主密钥 A1EE45D2C11058AD0B6956D9EB38DC52AAAAAAAA 已经过期，源私钥文件已经丢失（在卡上），现在更换到了新的密钥对。如果你对此结果感到顾虑，可以联系我二次确认。 - —–BEGIN PGP PUBLIC KEY BLOCK—– mDMEZvDjgBYJKwYBBAHaRw8BAQdA3oZuzC28tuGaO7+8G6el89qqlwi4RIlIuhH5LPS6NOy0IGljZUJlYXIgNjcgPGljZWJlYXI2N0BzZmNsdWIuY2M+iJMEExYKADsWIQQ4bRohG2ElfZF6D0Hgs/Wka2seUwUCZvDjgAIbAwULCQgHAgIiAgYVCgkICwIEFgIDAQIeBwIXgAAKCRDgs/Wka2seU75FAQDEjFWn+udecNy94cB1rpNOFfVv+u/UwJv7tlDgrPnhaAEA3bUznVI61ky0wicHI2Vbd3tKIaraOlBCcBiKC2LsBAu4OARm8OOAEgorBgEEAZdVAQUBAQdAhy//jo78jg9r4f8KL+aPvKCXdCLd0V1UGDG6N+bgKUwDAQgHiHgEGBYKACAWIQQ4bRohG2ElfZF6D0Hgs/Wka2seUwUCZvDjgAIbDAAKCRDgs/Wka2seU5YEAQD6d7E1vwEiu1EbPogUy+9Ms1FgNNsl9tKnx3TsJH76IQD/fl+iie6lgsGlsSry0P1+r5MYfSFFY0yfdRd27mM0ewm5AY0EZvDkLwEMANhr/n6UOHoDeZOXwam6ZmpoDoRtHuRTcEj7C7+0zSXDkqR2Gvs8YAQsaIeIC04mQduzRfh6GoaEs0fLnr3seLrc+zzeohf2aGSfd+9Z9rwfLX5xYiZOpQ3oAJK0ZVp3gnQTZowv9ntWqe7U9pXooXf56FcPWfis9cZ/wpngLteqr0O78B2iJjWBJPoOKz44Un1hIeRYMH4jwTqw8NUYMrYDBjXhSJyBQHanJwIqFRwj4TnD/4ju3yeny7NduqQ98E5gdfkebn84P2MNmCoWN/19vxPNFzqGDlxhOYlTR/z9tREJDbdjzF10Eme5qr3Ro2YR/t8WkSrolulBmlok6E3XaojT8IzY/bomT32k5HUY1Gups8s5C79AXLJZLQWuXhEsVxNY2OUw+WNY3lf4GZSVaROhzFqtXJz+Er4k/NYKjjblT2ZvQMeu7DfqbppkWcNHlP5A/7WI4YvPWJYJM5fuAQDHyH1vVRSJ77OSUlODDyzV7abmL4QCfMeCwYyUuQARAQABiG8EGBYKACEWIQQ4bRohG2ElfZF6D0Hgs/Wka2seUwUCZvDkLwMbIAQAAAL9APwOrYyLG7rUL7sr3sxYfN0Q8Tjr/hMDChZLvjdBfmXqiwEAkYbixssEJAH45sTclR1nbH9c2dW80Cb8sFDEqFlKuA0==la7x- —–END PGP PUBLIC KEY BLOCK—–—–BEGIN PGP SIGNATURE—– iQGzBAEBCAAdFiEExBpOiqi5xrpc4YzQBkHyW7lupokFAmbw70QACgkQBkHyW7luponVBAwAqSB0t3xS3G6hK7c4/lfnwHQYb0eMYLlo0cFnSPOonVVNq4xocfJIUeMQtv4LFBaEMggSBsnLpeVYCS/RkuXeW6cNWuZxYIM7Lt7epjIaX+lj0cCT496ljIsOOtSR6MncdFZuyuDwK2rT9K3yzOgdVWI14nkDIGgknb3KRFTLhKdmBJo4C8T6rGh2pPQy2kwH1kzMCXAPiQ8WEB0o9H3F/x1glpobqtihi99bqVxUbe5oIZ5PyDX9nQk6aWZIlh/6lLPuRkmX1DphPQUDfqLZrLRmDwhtPEn7t+V+9sKPTfZkNnFA9JXi38+j50Vs34inWJ8dtxLaSpjh06h/1tlrMyrE0h82ryb7KDrk5REVkOdIRxEVyLvkeoKnfQWMdUCjyE3lu4F2Kjv9D+xSDVfoP7+0+H1DdHzPJ3vmFLGm6UMvlx4R5glRDeWQGZqDKSrB6vPt2aJWXBxZDv3pUddNe1cgEJXjQHTz0G86qpwlX6ssj9/+zs4pBhMbO7B5zl4a=6zXI—–END PGP SIGNATURE—– 再见了, AAAAAAAA.","link":"2024/09/23/changed/"}],"tags":[{"name":"misc","slug":"misc","link":"tags/misc/"},{"name":"compiler","slug":"compiler","link":"tags/compiler/"},{"name":"tech","slug":"tech","link":"tags/tech/"},{"name":"Java","slug":"Java","link":"tags/Java/"},{"name":"minecraft","slug":"minecraft","link":"tags/minecraft/"},{"name":"minestom","slug":"minestom","link":"tags/minestom/"},{"name":"guide","slug":"guide","link":"tags/guide/"},{"name":"daily","slug":"daily","link":"tags/daily/"},{"name":"memories","slug":"memories","link":"tags/memories/"},{"name":"Linux","slug":"Linux","link":"tags/Linux/"},{"name":"summary","slug":"summary","link":"tags/summary/"},{"name":"牢骚","slug":"牢骚","link":"tags/%E7%89%A2%E9%AA%9A/"},{"name":"security","slug":"security","link":"tags/security/"}],"categories":[{"name":"记事","slug":"记事","link":"categories/%E8%AE%B0%E4%BA%8B/"},{"name":"教程","slug":"教程","link":"categories/%E6%95%99%E7%A8%8B/"},{"name":"阐述","slug":"阐述","link":"categories/%E9%98%90%E8%BF%B0/"},{"name":"杂文","slug":"杂文","link":"categories/%E6%9D%82%E6%96%87/"},{"name":"教程","slug":"杂文/教程","link":"categories/%E6%9D%82%E6%96%87/%E6%95%99%E7%A8%8B/"}],"pages":[{"title":"关于 nstd::out","text":"NSTD 即 Non-STandard Output，非标准输出。博客更新频率很低，对于技术类的博客会尽量保证质量（不然就不更），偶尔会更一些杂文，比如年终总结和有感而发的散文（文笔不好还请见谅）。 你可以通过 RSS，Follow.It (就在右边) 和 GitHub 的 Watch 功能（这个最及时，但是可能会接收到我平时更新博客布局的通知）订阅我的博客，也可以选择不订阅，随便你。 转载文章或者摘抄片段请遵循文章底下声明的许可协议。通常是 CC 如果遇到评论发不出来的情况请重试，另外博客已经换了新域名，请留意。","link":"about/index.html"},{"title":"Lnks","text":"本博客名称： 非标准输出 HikariLan’s Blog贺兰星辰的博客 一叶知秋 - 秋是悲欢离合，雨是一生错过 秋雨落的博客 LxNet 灵晓🐮🍺 czm的博客 - 记想记的东西 Zoyn’s Blog - 金融民工 冰星姐姐~ Cysime Moflu - 再不会遇见第二个时光 RainChan的小博客 他妈的,他妈的博客 / Phakel Luo - 一碗螺 tdiant - 可爱的单元格TD的博客 冷域之地 - LYOfficial 的博客 Atmosphere - IN PURSUIT OF FREEDOM 虎鲸TheSnowfield 的博客 timetraveler314 - A simple implementation of Trivializer kirraObj inuEbisu - 犬戎的博客 有笨蛋过了好久才发现没加上 妖梦的博客 - 其实叫妖梦的人还挺多的？？ Litwak913 高考加油！","link":"links/index.html"},{"title":"空调房","text":"我们在此处安装了空调，您可以在此自由休憩。","link":"%E7%A9%BA%E8%B0%83%E6%88%BF/index.html"},{"title":"","text":".admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:1rem;page-break-inside:avoid;border-left:.3rem solid #42b983;background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}","link":"styles/admonition.css"}]}