{
    "version": "https://jsonfeed.org/version/1",
    "title": "nstd::out",
    "description": "iceBear 的博客",
    "home_page_url": "https://nstd.sfclub.cc",
    "items": [
        {
            "id": "https://nstd.sfclub.cc/2021/11/05/How-Does-Java-Tag-Garbages/",
            "url": "https://nstd.sfclub.cc/2021/11/05/How-Does-Java-Tag-Garbages/",
            "title": "浅谈 Java 虚拟机是如何标识垃圾的",
            "date_published": "2021-11-05T15:20:16.000Z",
            "content_html": "<p>Java 作为一门 VM 语言，它的垃圾回收机制确实帮我们省了很多事情，我们不再需要去”手动管理内存的分配和释放”，只需要交给 VM 来做就好了。  </p>\n<p>然而，真的是这样吗？即使有<a href=\"https://malloc.se/blog/zgc-jdk16\">神一般高性能的垃圾回收器</a>，我们写代码时仍然需要注意它是<em>如何标记垃圾对象</em>的，因为垃圾回收器并不是万能的，仍然有一些工作需要程序员自己完成。  </p>\n<p>本文试图通俗易懂的讲解 JVM 上标记垃圾的方法，如有错误请在评论区指正。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"两种标记垃圾的方式\"><a href=\"#两种标记垃圾的方式\" class=\"headerlink\" title=\"两种标记垃圾的方式\"></a>两种标记垃圾的方式</h1><p>或许你曾听闻过 <code>引用计数法</code>，也就是 <code>一个对象被引用时计数器 + 1 ，解除引用时计数器 - 1，当计数器为 0 时将会被 GC</code>，看起来非常可行。  </p>\n<p>但是这种方法没有被 Java 采用，因为他有两个显而易见的问题：</p>\n<ul>\n<li>循环引用问题 如果一个对象内部引用了另一个 引用这个对象的 对象，那么计数器将永远不会为 0</li>\n<li>计数器的维护问题 引用计数器的值会以极快的速度更新，更新任务变得繁重 </li>\n</ul>\n<p>或许因此，Java 采用了 <code>可达性分析</code> 的方法对垃圾进行标记。</p>\n<h1 id=\"可达性分析\"><a href=\"#可达性分析\" class=\"headerlink\" title=\"可达性分析\"></a>可达性分析</h1><p>可达性分析的思路很简单。</p>\n<p>他从一组叫 <code>GC Root</code> 的引用出发，递归搜索出所有能被到达的节点作为<strong>存活</strong>的对象，而此外那些没有被搜索到的对象就会被标记 <strong>将被清理</strong>。</p>\n<p><img src=\"https://upload.cc/i1/2021/11/05/cvqtiw.png\">  </p>\n<p>途中，被蓝色尖头指向的对象将不会被清除，因为他们间接或者直接的被 <code>GC Root</code> 引用。而旁边没有被 <code>GC Root</code> 引用的两个对象将会被清除，无论他们之间有什么关系。</p>\n<p>不久，因为 <code>Garbage F</code> 和他的朋友 <code>Garbage E</code> 没有来自 <code>GC Root</code> 的直接/间接引用，他们就会被 gc 回收掉了。</p>\n<blockquote>\n<p>想想看，如果在这个图中 <code>Object C</code> 建立了到 <code>Garbage F</code> 的一个引用，会发生什么？  </p>\n</blockquote>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>在聊 <code>GC Root</code> 是什么之前，你可能需要知道引用是什么。  </p>\n<p>举个例子:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object a = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = b;</span><br><span class=\"line\"><span class=\"keyword\">assert</span> a == c;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码运行不会报错，因为他们是在内存中是同一个对象。这是如何做到的呢？ JVM 并没有把这个对象拷贝很多次，因为他赋值并不是赋一个对象，而是引用。  </p>\n<p>这是因为对象是分配在堆里的，<code>new Object()</code> 返回的实际上是一个<code>引用</code>。引用就是指向对象的钥匙。  </p>\n<p>打个比方说， <code>网盘链接</code> 可以指向一个资源，你把链接给了别人并不是直接把资源发送给了别人，只是给了一个指向资源的钥匙，它可以通过这个钥匙获取到资源。  </p>\n<p>再来看一个例子  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt; someObject = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">someObject.add(objectA);</span><br><span class=\"line\">someObject.add(objectB);</span><br></pre></td></tr></table></figure>\n\n<p>显然，以上的代码将两个对象塞到了一个容器里，看起来是这样的：</p>\n<p><img src=\"https://upload.cc/i1/2021/11/05/7QuXlj.png\">   </p>\n<p>当然，不只是塞到容器才有引用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    A anotherA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">A b = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">a.anotherA = b;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload.cc/i1/2021/11/06/0Dv9Rg.png\"></p>\n<p>另外，Java 还有多种引用类型来帮助你实现更加灵活的对象生命周期管理。本文主要讨论的是强引用的情况，并不考虑弱引用类型，有兴趣的读者可以自行了解( WeakReference , PhantomReference , SoftReference )。</p>\n<p>如果你无法理解引用也没有问题，只需要理解成一个对象存了另一个对象之间建立的关系就好了。  </p>\n<h2 id=\"GC-Root\"><a href=\"#GC-Root\" class=\"headerlink\" title=\"GC Root\"></a>GC Root</h2><p>GC Root 是垃圾收集器进行分析的起点，不会被回收，而且类型有很多种<del>但是基本上不用特地记</del>，主要就注意这几个。</p>\n<ol>\n<li>局部变量，参数之类的 就是指方法里面声明的那些变量，不过出了方法就没了</li>\n<li>类静态字段或常量 比如 <code>private static final XX xx = new XX()</code> </li>\n<li>虚拟机内部引用</li>\n<li>被同步锁持有的对象</li>\n</ol>\n<h1 id=\"来个例子\"><a href=\"#来个例子\" class=\"headerlink\" title=\"来个例子\"></a>来个例子</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;OOMObject&gt; oomObjects = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">114514</span> ; i++) &#123;</span><br><span class=\"line\">    oomObjects.add(<span class=\"keyword\">new</span> OOMObject());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>试图说明程序内存溢出的原因。</p>\n<h1 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h1><p>总之，写代码的时候要注意一些潜在的，未消除的引用，虽然一般碰不到。</p>\n",
            "tags": [
                "tech"
            ]
        },
        {
            "id": "https://nstd.sfclub.cc/2021/10/12/Windy-Day/",
            "url": "https://nstd.sfclub.cc/2021/10/12/Windy-Day/",
            "title": "大风天",
            "date_published": "2021-10-12T09:01:14.000Z",
            "content_html": "<p>深夜了。</p>\n<p>窗外，大风呼啸着向我宣告冬天的到来。我躺在床上，静静地聆听风的呼声。  </p>\n<p>闭上了双眼，就仿佛置身于世界之外，只有风的护声。仿佛想到在几千年前……更久以前风也是这么呼的。  </p>\n<p>像是凄凉的呼唤，又像是愤怒的咆哮——不过只是人主观给他添加上的情绪。风大抵是没有感情的，只是咆哮，从地球之初到现世皆是如此，毫无忌惮的咆哮着。  </p>\n<p>风挂过窗外的小河引起阵阵波浪，也刮的树叶动燥不安，风试图撞进窗来，而我听着他们的声音安稳的睡了一觉。</p>\n<span id=\"more\"></span>\n\n\n<p>…</p>\n<p>一觉醒来，世界又好像被大风改造成一番新景色。可能是拜前几天的台风所赐，夏日的炎炎酷热早就荡然无存。大风划过我睡的迷迷糊糊的脸颊，让我打了一哆嗦。  </p>\n<p>大风天！我不禁感叹。每当到了这样的大风天，我总是能亢奋起来。大风吹过我的身体，给我注入了新的活力。</p>\n<p>于是我敞开胸怀，让大风使劲地吹。与夏日那股闷燥的气息不同，冬天的大风清爽怡人（我所在的城市基本没有秋天这个概念），它不仅能卷走一切，也能让我打一喷嚏。  </p>\n<p>我喜欢大风天，但不只是为了凉爽。</p>\n<p>…</p>\n<p>曾经，也是同样的大风天里，我给我的猫洗了个澡。</p>\n<p>大风在窗外呼啸，然而它也冷的发抖。大抵是身上的水还没有沥干罢。我抱着它到被窝里，头对着头睡了一觉。  </p>\n<p>它没有逃跑，只是依偎着，暖暖的，大风仍在呼啸。</p>\n<p>又是曾经的一个大风天，那时候我还没有住宿，我走在回家的小路上。  </p>\n<p>大风吹过校园，刮的树们好不安分，太阳也慢慢地沉下去。</p>\n<p> 我悠闲自在的走在小路上，想着今晚吃什么，回家之后先做点什么。</p>\n<p> 有时，还能在路边发现流浪猫。我总是忘记带上水和猫粮——偶尔会带一些水，不过不知道猫愿不愿意喝，它也不出来，便放在它可能出现的地方许个愿就走了。</p>\n<p> 我希望它能找到住所。</p>\n<p>睡觉的时候，我躲在被窝里，想到任凭窗外大风呼啸也冻不着我，笑了起来。</p>\n<p>…</p>\n<p>也是曾经，在一个大风天里，我被委屈骂了一顿。  </p>\n<p>淋着大雨回到了家，不为洗澡只为哭。我锁上门，瘫坐在地上哭起来，巴不得把全世界控诉一遍才开心。</p>\n<p>还没哭一小会，猫就听闻到我的声音，从它熟睡的地方跳出来，试图安慰我，于是也叫了起来。</p>\n<p>我看着它傻傻的样子，不禁破涕而笑。窗外阴云密布，但我有小太阳。  </p>\n<p>…</p>\n<p>再后来，又是新年，又是一番喜庆的景象。追着人家的小牛绕着圈，在院子里玩玩具枪，在乡下体验”探险”，那时候还没有抖音，快手。</p>\n<p>我坐在院子里，享受着晚风悄悄地吹过。</p>\n<p>…</p>\n<p>时光飞逝。</p>\n<p>再后来，我上了初中，又上了高中，还住了宿，再也没有看夕阳和闲情雅致的时间，陪伴猫的时间也越来越少。</p>\n<p>后来，家姐把它领了回去，再后来见他时已然过了两三年，但它仍然记得我，不禁让我万分感动。然而猫还是活不过人，只好在他现存的时候尽可能陪陪它，也算是让我不留缺憾了。  </p>\n<p>大风天卷走一切，也卷不走回忆和温暖。我吹着大风，听着大风，然而我却不觉得冷，就好像幸福的事情即将发生，就好像我还是曾经在床头旁哭的我。</p>\n<p>大风天。每当想起这些事情，我就仿佛有了屏障，有了一个小太阳，不仅仅是挡住了大风，也烧掉了我的痛苦，我的惆怅。</p>\n<p>2021.10.12 回忆。</p>\n",
            "tags": [
                "life memories"
            ]
        },
        {
            "id": "https://nstd.sfclub.cc/2021/10/01/Writting-A-Compiler-1/",
            "url": "https://nstd.sfclub.cc/2021/10/01/Writting-A-Compiler-1/",
            "title": "从零开始的编译器生涯",
            "date_published": "2021-10-01T14:12:37.000Z",
            "content_html": "<p>近日一屑高二学生无聊动手写起了编译器….这是他的珍贵作战记录    </p>\n<span id=\"more\"></span>\n\n<h1 id=\"0x01-理论基础\"><a href=\"#0x01-理论基础\" class=\"headerlink\" title=\"0x01 理论基础\"></a>0x01 理论基础</h1><p>我摊牌，我没有看任何编译原理相关的书籍，因此这篇文章并不能作为严格的参考资料，甚至很多地方可能是错误的。  </p>\n<p>编译器，编译器，就是把高级语言的代码编译成另一种形式（class，asm，二进制，IR），而他在编译成另一种形式之前大概需要过这么个流程:</p>\n<p>Lex -&gt; Parse -&gt; Compile  </p>\n<p>接下来逐步讲解这个过程。</p>\n<h2 id=\"Lexer\"><a href=\"#Lexer\" class=\"headerlink\" title=\"Lexer\"></a>Lexer</h2><p>就是分词器，输入用户提供的代码接着把他分成 <code>tokens</code>，也就是 <code>tokenstream</code>。<br>你肯定看不懂上面那句话的意思，让我们来点实例：<br><img src=\"https://upload.cc/i1/2021/10/01/gGftuh.png\" alt=\"image\"><br><code>a.value</code> 里的那个 <code>ArrayList</code> 就是一个 <code>token stream</code>，<code>str</code> 是被解析的代码。不难发现，语句被 Lexer 按顺序进行了分类以及数据的分割，如 <code>a</code> 被识别为了一个 <code>Identify</code> (标记)。 </p>\n<p>因此也可以归纳出来 <code>Token</code> 大致的代码长啥样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Token</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> line;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Parser\"><a href=\"#Parser\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p>Lexer 从源码中提取出 <code>token stream</code> 后将会交给 <code>Parser</code> 处理，它负责对 <code>token stream</code> 进行解析，生成一个 <code>AST (Abstract Syntax Tree)</code>，也就是 <code>抽象语法树</code>。  </p>\n<p><img src=\"https://upload.cc/i1/2021/10/01/nVE3wl.png\"><br>这张图直观的描述了这一过程，你可以看到它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。  </p>\n<p>接着，AST 将会丢给代码生成器用于生成代码，但是一般会先对 AST 进行优化，例如 <code>常量折叠</code></p>\n<h2 id=\"Static-Analyzing\"><a href=\"#Static-Analyzing\" class=\"headerlink\" title=\"Static Analyzing\"></a>Static Analyzing</h2><p>但在这之前，我们还有一些问题要解决。<br><del>其实这玩意我是和 Parser 写一块的</del><br>试想一下，如果有这样一行代码：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = love + cats</span><br></pre></td></tr></table></figure>\n<p>代码生成器如何知道 <code>love</code> 和 <code>cats</code> 是什么？ 在 Parser 的眼里，他们只是 <code>Identifier</code>，然而它们之间不能相加减。  </p>\n<p>在这种时候，Parser 需要预先建立一个符号表，这样他才能找出 <code>love</code> 和 <code>cats</code> 究竟是什么以及是否能够编译。</p>\n<p>同理，下面的代码也一样需要这一过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(List&lt;String&gt; args)</span></span>&#123; <span class=\"comment\">// 此处 Parser 将会分析出 java.lang.String 和 java.util.List</span></span><br><span class=\"line\">  NullCat nc = <span class=\"keyword\">new</span> SBNC(); <span class=\"comment\">// 按照 Java 的逻辑，此处没有导入（或同包）于是会产生错误，因为Parser找不到 SBNC / NullCat</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Code-Generation\"><a href=\"#Code-Generation\" class=\"headerlink\" title=\"Code Generation\"></a>Code Generation</h2><p>接着是生成代码！<br>一般编译器都会输出一种 <code>IR (Intermediate Representation)</code> 码，而他的作用则是一种中间表示。<br>例如，如果你输出 LLVM 的 IR 码，那么接下来你的编译工作（win,x64,linux,…jvm）就可以交给 LLVM 来完成，而像 <code>LLVM</code> 这样负责最后这一步骤的我们称之为 <code>编译器的后端</code></p>\n<p>使用这一种方法有几个好处：</p>\n<ul>\n<li>它可以使得开发者更专注于 <code>语言设计</code> 而不用过多的考虑 <code>优化</code>，因为大多数编译器后端会帮你完成这件事情 <del>，除非你直接输出汇编那就得你自己负责优化了</del>。</li>\n<li>IR 是中间表示，它可以按照相同的语义编译出不同平台，不同架构的代码，大大节省了开发者时间</li>\n<li>…</li>\n</ul>\n<p> 处于个人习惯，我选择了 Java 的字节码作为 “IR”，他将会被 JVM 加载并在运行过程中收集数据被更好的优化以及可以享受和 Java 互操作，跨平台的优势。</p>\n<h1 id=\"0x02-实践\"><a href=\"#0x02-实践\" class=\"headerlink\" title=\"0x02 实践\"></a>0x02 实践</h1><p>知道了这些理论，我们立即可以开始编写我们的第一个 Lexer 了。</p>\n<p>这是我们这一大章节的目标代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using java.util.List</span><br><span class=\"line\"></span><br><span class=\"line\">fn main(args: List&lt;String&gt;)&#123;</span><br><span class=\"line\">  println &quot;hello world!&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，让我们开始吧！<br>下文将会有大量代码，为了可读性，我会删掉一些无关紧要的部分。</p>\n<h2 id=\"Lexer-1\"><a href=\"#Lexer-1\" class=\"headerlink\" title=\"Lexer\"></a>Lexer</h2><p>我的 Lexer 分为两步：<code>fuzzyTokenize</code> 和 <code>tokenize</code>。<br>实际上这是取决于做法的，有正则转 DFA（状态机）的，也有直接 <code>charStream</code> 的。</p>\n<p>我选择了第二种，因为我认为使用正则的代码可读性比较糟糕，不易于维护。那么，让我们开始做一些准备工作…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lexer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String fileName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String rawContent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Lexer</span><span class=\"params\">(String content,String fileName)</span> </span>&#123;</span><br><span class=\"line\">        rawContent = content.replaceAll(<span class=\"string\">&quot;//.*|(\\&quot;(?:\\\\\\\\[^\\&quot;]|\\\\\\\\\\&quot;|.)*?\\&quot;)|(?s)/\\\\*.*?\\\\*/&quot;</span>, <span class=\"string\">&quot;$1 &quot;</span>); <span class=\"comment\">// remove comments.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName=fileName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从构造方法接受源代码和文件名并且删除注释。你可能会问文件名用来干啥，那当然是用来报错的～<br>接着，还有一个 <code>LexedNode</code> 用来表示 <code>fuzzyTokenize</code> 后的产物。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LexedNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> NodeType type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 初始化和getter...</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">NodeType</span> </span>&#123;</span><br><span class=\"line\">        IDENTIFIER,SYMBOL,KEYWORD,OPERATOR,</span><br><span class=\"line\">        LINE_SEPERATOR,</span><br><span class=\"line\">        LITERAL_STRING,LITERAL_NUMBER</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这就是一个最基本的 <code>token</code>! 在后文，我们将会进行第二次 <code>tokenize</code> 使它变得更详细。  </p>\n<p>准备好了，开始写吧！首先是一个状态机：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;LexedNode&gt; <span class=\"title\">fuzzyTokenize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] charStream = rawContent.toCharArray();</span><br><span class=\"line\">    List&lt;LexedNode&gt; nodes = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> line = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; charStream.length; i++) &#123; <span class=\"comment\">// 使用 fori 是为了循环时移动指针</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> now = charStream[i];</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (now) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\n&#x27;</span>:</span><br><span class=\"line\">              nodes.add(<span class=\"keyword\">new</span> LexedNode(NodeType.LINE_SEPERATOR,<span class=\"string\">&quot;\\n&quot;</span>))</span><br><span class=\"line\">              <span class=\"keyword\">continue</span>; <span class=\"comment\">// 此处使用 continue 立即跳到下一次循环</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nodes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是你的第一个 Lexer，可以先输出一下看看结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LINE_SEPERATOR</span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR</span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR</span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR</span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR</span><br></pre></td></tr></table></figure>\n\n<p>因为代码有五行，因此是五个 <code>LINE_SEPERATOR</code>。<br>只有换行符可不够，我们还要识别 <code>KEYWORD</code> ，也就是关键词。<br>然而关键词使用空格分割，因此我们可以这样做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(...)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27; &#x27;</span>:                </span><br><span class=\"line\">        inIdOrLiteral = !inIdOrLiteral;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inIdOrLiteral) &#123; <span class=\"comment\">// start collecting</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// end!</span></span><br><span class=\"line\">        String str = buffer.toString();</span><br><span class=\"line\">        identifierParse(str, nodes);</span><br><span class=\"line\">        buffer = <span class=\"keyword\">new</span> StringBuilder(); <span class=\"comment\">// compose</span></span><br><span class=\"line\">         <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 此处换行同理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Collect String or Identifier */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inIdOrLiteral) &#123;</span><br><span class=\"line\">        buffer.append(now);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以看到，我们引入了两个新的变量和一个方法，它们分别是 <code>inIdOrLiteral</code> 和 <code>buffer</code> 以及 <code>identifierParse</code>。</p>\n<p><strong>inIdOrLiteral</strong> 表示当前是否正在遍历一个 <code>Identifier</code> 或者一个字面量<br><strong>buffer</strong> 用于收集这个字面量，当然你也可以使用 <code>substring</code> 和 <code>charAt</code> 的方法<br><strong>identifierParse</strong> 是一个方法，他用于分类 Identifier。对于 <code>11</code>，他会分类成一个 <code>LITERAL_NUMBER</code>，对于 <code>not_a_keyword</code>，他会分类成一个 identifier，对于 <code>fn</code>，他会分类成一个 Keyword。</p>\n<p>还没完，天资聪颖的你肯定已经注意到了这里少了一样东西——我要怎么匹配最开头的一个 <code>using</code> ？ <code>using</code> 的前头可没有一个空格。<br>这时你可以回忆一下，在各种编程语言中作为 <code>Identifier</code> 的符号应该符合什么规则….是的，他们通常不会以运算符作为开头，以及他们不是一个关键字，因此我们还可以利用这个特性写出这样的代码:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         <span class=\"comment\">/* Other Symbols */</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (SYMBOL_OR_OPERATORS.contains(now）) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (inIdOrLiteral) &#123; <span class=\"comment\">// keyword</span></span><br><span class=\"line\">                 <span class=\"comment\">// now == a symbol,we should end this.</span></span><br><span class=\"line\">                 identifierParse(buffer.toString(), nodes);</span><br><span class=\"line\">                 buffer = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                 inIdOrLiteral = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (SYMBOLS.contains(now)) &#123;</span><br><span class=\"line\">                 nodes.add(<span class=\"keyword\">new</span> LexedNode(now, LexedNode.NodeType.SYMBOL));</span><br><span class=\"line\">                 <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (OPERATORS.contains(now)) &#123;</span><br><span class=\"line\">                 nodes.add(<span class=\"keyword\">new</span> LexedNode(now, LexedNode.NodeType.OPERATOR));</span><br><span class=\"line\">                 <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> LexerException(fileName+<span class=\"string\">&quot;: Unknown char: &quot;</span> + now+<span class=\"string\">&quot; line: &quot;</span>+line);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             inIdOrLiteral = <span class=\"keyword\">true</span>; <span class=\"comment\">// not symbol &amp; not identifier</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Collect String or Identifier */</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (inIdOrLiteral) &#123;</span><br><span class=\"line\">     buffer.append(now);</span><br><span class=\"line\">     <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一段代码将会在匹配第一个字符没有遇到语言规定的操作符或者特殊符号的时候把 <code>inIdOrLiteral</code> 设置为 <code>true</code>。配合上面的代码，在遇到一个空格的时候他会结束收集并且尝试判断是什么。</p>\n<p>实际上应该是 <code>switch</code> 的任务但是写成 <code>if</code> 更加直观一些。  </p>\n<p>那么到现在，我们可以开始尝试代码了！这是 Lexer 的输出：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEYWORD using</span><br><span class=\"line\">IDENTIFIER java</span><br><span class=\"line\">OPERATOR .</span><br><span class=\"line\">IDENTIFIER util</span><br><span class=\"line\">OPERATOR .</span><br><span class=\"line\">IDENTIFIER List</span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">KEYWORD fn</span><br><span class=\"line\">IDENTIFIER main</span><br><span class=\"line\">SYMBOL (</span><br><span class=\"line\">IDENTIFIER args</span><br><span class=\"line\">OPERATOR :</span><br><span class=\"line\">IDENTIFIER List&lt;String&gt;</span><br><span class=\"line\">SYMBOL )</span><br><span class=\"line\">SYMBOL &#123;</span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">KEYWORD println</span><br><span class=\"line\"><span class=\"deletion\">- LITERAL_STRING hello world!</span></span><br><span class=\"line\"><span class=\"addition\">+ IDENTIFIER &quot;hello</span></span><br><span class=\"line\"><span class=\"addition\">+ IDENTIFIER world!&quot;</span></span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">SYMBOL &#125;</span><br><span class=\"line\">5: RIGHT_BRACKET &#125;</span><br></pre></td></tr></table></figure>\n\n<p>相比你已经注意到了，理应出现的 <code>LITERAL_STRING</code> 被两个 IDENTIFIER 代替了，这显然不是我们想要的结果。因此，我们要给 String 加入特 殊 支 持  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(now)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&quot;&#x27;</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; charStream[i - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;\\\\&#x27;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// string starts or end</span></span><br><span class=\"line\">                        inIdOrLiteral = !inIdOrLiteral;</span><br><span class=\"line\">                        stringMode = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!inIdOrLiteral) &#123;</span><br><span class=\"line\">                            stringMode = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                            <span class=\"comment\">// a new string!</span></span><br><span class=\"line\">                            nodes.add(<span class=\"keyword\">new</span> LexedNode(buffer.toString(), LexedNode.NodeType.LITERAL_STRING));</span><br><span class=\"line\">                            buffer = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    case &#x27; &#x27;:</span><br><span class=\"line\"><span class=\"addition\">+        if (stringMode) &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+            break;</span></span><br><span class=\"line\"><span class=\"addition\">+        &#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">- if (SYMBOL_OR_OPERATORS.contains(now)) &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+ if (SYMBOL_OR_OPERATORS.contains(now) &amp;&amp; !stringMode) &#123;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样我们就躲开了这个陷阱，完成了对于 String 的支持后，我们的 <code>fuzzyTokenize</code> 就做好了！</p>\n<blockquote>\n<p>关于 OPERATORS 和 SYMBOLS<br>一门语言里的符号很多，你绝对不会想把他们一个个 add 到 list 里面的，但你可以写一个 <a href=\"https://github.com/iceBear67/NullCatLang/blob/85a9b3234bcaab21451c0c6023f46d3599e5764d/src/main/java/io/ib67/lexer/Lexer.java#L11-L34\">loader</a> 来解决这个问题  </p>\n<p><img src=\"https://upload.cc/i1/2021/10/01/HwBhRN.png\"></p>\n</blockquote>\n<hr>\n<p>然后，是 <code>tokenizer</code>。<code>fuzzyTokenize</code> 输出的结果显然不足以交给 Parser 做解析，我们需要使i结果更加详细。</p>\n<p>好在经过 <code>fuzzyTokenize</code> 后代码已经被格式化成了比较模糊的 <code>Token Stream</code>，这一点使我们写第二次 tokenize 的时候会轻松很多，因为你不会再见到 <code>inIdOrLiteral</code> 和 <code>stringMode</code> 这种让人抓狂的东西了。</p>\n<p>首先，让我们从一个新的 Token 开始（你不会想和 LexedNode 混一块的）:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Token</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> line;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Type</span></span>&#123;</span><br><span class=\"line\">        IDENTIFIER(<span class=\"string\">&quot;&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        CLASS(<span class=\"string\">&quot;class&quot;</span>),FUNCTION(<span class=\"string\">&quot;fn&quot;</span>),ANNOTATION(<span class=\"string\">&quot;annotation&quot;</span>),FOR(<span class=\"string\">&quot;for&quot;</span>),WHILE(<span class=\"string\">&quot;while&quot;</span>),IF(<span class=\"string\">&quot;if&quot;</span>),USING(<span class=\"string\">&quot;using&quot;</span>)</span><br><span class=\"line\">        ,THIS(<span class=\"string\">&quot;this&quot;</span>),TRUE(<span class=\"string\">&quot;true&quot;</span>),FALSE(<span class=\"string\">&quot;false&quot;</span>),ELSE(<span class=\"string\">&quot;else&quot;</span>),VAR(<span class=\"string\">&quot;var&quot;</span>),NULL(<span class=\"string\">&quot;null&quot;</span>),PRINTLN(<span class=\"string\">&quot;println&quot;</span>), <span class=\"comment\">// KEYWORDS</span></span><br><span class=\"line\">        VAL(<span class=\"string\">&quot;val&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        LEFT_BRACE(<span class=\"string\">&quot;(&quot;</span>),RIGHT_BRACE(<span class=\"string\">&quot;)&quot;</span>),</span><br><span class=\"line\">        LEFT_BRACKET(<span class=\"string\">&quot;&#123;&quot;</span>),RIGHT_BRACKET(<span class=\"string\">&quot;&#125;&quot;</span>),</span><br><span class=\"line\">        LEFT_MID_BRACE(<span class=\"string\">&quot;[&quot;</span>),RIGHT_MID_BRACE(<span class=\"string\">&quot;]&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        COMMA(<span class=\"string\">&quot;,&quot;</span>),DOT(<span class=\"string\">&quot;.&quot;</span>),MINUS(<span class=\"string\">&quot;-&quot;</span>),PLUS(<span class=\"string\">&quot;+&quot;</span>),STAR(<span class=\"string\">&quot;*&quot;</span>),SLASH(<span class=\"string\">&quot;/&quot;</span>), <span class=\"comment\">// operators</span></span><br><span class=\"line\">        BREAK_LINE(<span class=\"string\">&quot;\\n&quot;</span>),ASSIGNMENT(<span class=\"string\">&quot;=&quot;</span>),EQUALS(<span class=\"string\">&quot;==&quot;</span>),SEMICOLON(<span class=\"string\">&quot;;&quot;</span>),AT(<span class=\"string\">&quot;@&quot;</span>),COLON(<span class=\"string\">&quot;:&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        LITERAL_STRING(<span class=\"string\">&quot;&quot;</span>),LITERAL_NUMBER(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// literals</span></span><br><span class=\"line\">        <span class=\"meta\">@Getter</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String def;</span><br><span class=\"line\">        Type(String def)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.def=def;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>比上文的 LexedNode 详细了很多——比如他主动去分类 keyword 了。<br>接着是一个 fori ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Pair&lt;String,List&lt;Token&gt;&gt; tokenize() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lexedNodes = fuzzyTokenize();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tokens = <span class=\"keyword\">new</span> ArrayList&lt;Token&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> line = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lexedNodes.size(); i++) &#123;</span><br><span class=\"line\">        LexedNode lexedNode = lexedNodes.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (lexedNode.getType()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LINE_SEPERATOR:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.BREAK_LINE,<span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">                line++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SYMBOL:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> KEYWORD:</span><br><span class=\"line\">                <span class=\"keyword\">var</span> type = Arrays.stream(Token.Type.values()).filter(e -&gt; e.getDef().equals(lexedNode.getContent())).findFirst().orElseThrow(()-&gt;&#123;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NullPointerException(lexedNode.toString());</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, type, type.getDef()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LITERAL_STRING:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.LITERAL_STRING, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LITERAL_NUMBER:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.LITERAL_NUMBER, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OPERATOR:</span><br><span class=\"line\">                <span class=\"comment\">// =</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> isEnd = (i == lexedNodes.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (lexedNode.getContent()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;=&quot;</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (isEnd) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> LexerException(fileName+<span class=\"string\">&quot;: Invalid syntax line &quot;</span>+line);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (lexedNodes.get(i + <span class=\"number\">1</span>).getType() == LexedNode.NodeType.OPERATOR &amp;&amp; lexedNodes.get(i + <span class=\"number\">1</span>).getContent().equals(<span class=\"string\">&quot;=&quot;</span>)) &#123; <span class=\"comment\">// ==</span></span><br><span class=\"line\">                            tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.EQUALS, <span class=\"string\">&quot;==&quot;</span>));</span><br><span class=\"line\">                            i = i + <span class=\"number\">1</span>; <span class=\"comment\">// skip next</span></span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.ASSIGNMENT, <span class=\"string\">&quot;=&quot;</span>));</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;.&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.DOT, <span class=\"string\">&quot;.&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;,&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.COMMA, <span class=\"string\">&quot;,&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.MINUS, <span class=\"string\">&quot;-&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.PLUS, <span class=\"string\">&quot;+&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.STAR,<span class=\"string\">&quot;*&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.SLASH,<span class=\"string\">&quot;/&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;;&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.SEMICOLON,<span class=\"string\">&quot;;&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;:&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line,Token.Type.COLON,<span class=\"string\">&quot;:&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IDENTIFIER:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.IDENTIFIER, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pair.of(fileName,tokens);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码并不难懂。在这个例子中，我们遍历来自 fuzzyTokenizer 的数据并且通过 switch 分类枚举来处理把他们转化成 <code>Token</code> 来表达并且存储到 <code>tokens</code>。对于 symbol 和 keyword，我们通过直接搜索 enum 内值的方法避免写出了像 <code>case OPERATOR</code> 里更糟糕的代码。  </p>\n<p><code>case OPERATOR</code> 里写成这样是为了双符号操作的支持，例如 <code>==</code></p>\n<p>回到原题，这次我们可以通过 tokenize 解析出这样的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1: USING using</span><br><span class=\"line\">1: IDENTIFIER java</span><br><span class=\"line\">1: DOT .</span><br><span class=\"line\">1: IDENTIFIER util</span><br><span class=\"line\">1: DOT .</span><br><span class=\"line\">1: IDENTIFIER List</span><br><span class=\"line\">1: BREAK_LINE </span><br><span class=\"line\">2: BREAK_LINE </span><br><span class=\"line\">3: FUNCTION fn</span><br><span class=\"line\">3: IDENTIFIER main</span><br><span class=\"line\">3: LEFT_BRACE (</span><br><span class=\"line\">3: IDENTIFIER args</span><br><span class=\"line\">3: COLON :</span><br><span class=\"line\">3: IDENTIFIER List&lt;String&gt;</span><br><span class=\"line\">3: RIGHT_BRACE )</span><br><span class=\"line\">3: LEFT_BRACKET &#123;</span><br><span class=\"line\">3: BREAK_LINE </span><br><span class=\"line\">4: PRINTLN println</span><br><span class=\"line\">4: LITERAL_STRING hello world!</span><br><span class=\"line\">4: BREAK_LINE </span><br><span class=\"line\">5: RIGHT_BRACKET &#125;</span><br><span class=\"line\">5: RIGHT_BRACKET &#125;</span><br></pre></td></tr></table></figure>\n<p>是不是详细了很多？接着我们就可以靠着这个写一个 Parser了</p>\n<h2 id=\"在-Parse-之前\"><a href=\"#在-Parse-之前\" class=\"headerlink\" title=\"在 Parse 之前\"></a>在 Parse 之前</h2><p>在 Parse 之前，我们需要先做一次 Static Analyzing。在这个阶段，Parser 会对文件里的类型和导入表作出关联，同时也是多文件编译的基础。</p>\n<h3 id=\"Metadata\"><a href=\"#Metadata\" class=\"headerlink\" title=\"Metadata\"></a>Metadata</h3><p>你不可能靠着所有人的源码来建立索引，而且源码中的无用信息太多了。<br>实际上，确定符号链接只需要这些信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CatMetadata</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassDef classDefinition = <span class=\"keyword\">new</span> ClassDef();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String,CatMetadata&gt; cachedUsings = <span class=\"keyword\">new</span> HashMap&lt;&gt;(); <span class=\"comment\">// 这是对于被解析对象才有的</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt; MethodSign&gt; methods = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, VariableDef&gt; fields = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关于 <code>ClassDef</code>, <code>MethodSign</code>, <code>VariableDef</code> 等信息本文不贴出，因为并不会影响观看体验。<br>如果有兴趣，可以在<a href=\"https://github.com/iceBear67/NullCatLang/tree/master/src/main/java/io/ib67/ast/decl\">这里</a>找到他们相对应的具体代码  </p>\n</blockquote>\n<p>以及一个编译器全局索引，用 FQDN 确定唯一性的 Map:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Global</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String,CatMetadata&gt; GLOBAL_METADATAS = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> CatMetadata <span class=\"title\">forClass</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          * Scan compiler classPaths</span></span><br><span class=\"line\"><span class=\"comment\">          */</span></span><br><span class=\"line\">         <span class=\"keyword\">var</span> meta = NullCatCompiler.solveMeta(str);</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(meta!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             GLOBAL_METADATAS.put(str, meta);</span><br><span class=\"line\">         &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">             meta = NullCatCompiler.solveMeta(<span class=\"string\">&quot;java.lang.&quot;</span> + str);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> meta;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>准备就绪，我们来单独拿出一个类作为 <code>MetadataGenerator</code> 状态机  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequiredArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MetadataGenerator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String fileName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Token&gt; tokens;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> CatMetadata cm = <span class=\"keyword\">new</span> CatMetadata();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着，是提取数据的部分:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CatMetadata <span class=\"title\">gen</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tokens.size(); i++) &#123;</span><br><span class=\"line\">        Token now = tokens.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> end = (i==tokens.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">        Token next = end?<span class=\"keyword\">null</span>:tokens.get(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(now.getType())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> USING:</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!end)&#123;</span><br><span class=\"line\">                    i=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> clazz = readAsStringUntilLB();</span><br><span class=\"line\">                    cm.getCachedUsings().put(clazz, Optional.ofNullable(CatMetadata.Global.forClass(clazz)).orElseThrow(()-&gt;<span class=\"keyword\">new</span> ParseException(<span class=\"string\">&quot;Can&#x27;t find clazz &quot;</span>+clazz)));</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    throwEOF();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> FUNCTION:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (end) &#123;</span><br><span class=\"line\">                    throwEOF();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// fn main()&#123;&#125;</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(next.getType() != Token.Type.IDENTIFIER)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ParseException(fileName+<span class=\"string\">&quot;: Unexcepted &quot;</span>+next.getType()+<span class=\"string\">&quot; at line &quot;</span>+now.getLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                String methodName = next.getContent();</span><br><span class=\"line\">                i=i+<span class=\"number\">1</span>; <span class=\"comment\">// Move Pointer to (</span></span><br><span class=\"line\">                MethodSign sign = readMethodSign(methodName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode()))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ParseException(fileName+<span class=\"string\">&quot;: Duplicated method: &quot;</span>+sign+<span class=\"string\">&quot; at line &quot;</span>+now.getLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cm.getMethods().add(sign);</span><br><span class=\"line\">                skipCodeBlocks();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cm;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在这个循环当中，我们通过获取到 Token 的类型来判定需要做的操作，这是基于语言设计定义来做的—— 例如 <code>fn</code> 的后面必然是一个方法签名，而不可以是别的。最终 <code>MetadataGenerator</code> 将会返回一个 CatMetadata 以供后续操作。</p>\n<p>因此，这一阶段我们也可以发掘出类型错误和大的语法错误。</p>\n<h3 id=\"与-Java-的世界\"><a href=\"#与-Java-的世界\" class=\"headerlink\" title=\"与 Java 的世界\"></a>与 Java 的世界</h3><p>我们需要和 Java 交互，因此我们需要给 <code>Class</code> 建立 <code>CatMetadata</code> 。好在这很简单，因为 CatMetadata 需要的所有数据都可以通过反射获取，这里提供一段参考代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassMetaPathImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">MetaPath</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassLoader classLoader;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CatMetadata <span class=\"title\">findClass</span><span class=\"params\">(String clazz)</span> </span>&#123;</span><br><span class=\"line\">        CatMetadata cm = <span class=\"keyword\">new</span> CatMetadata();</span><br><span class=\"line\">        Class&lt;?&gt; claz = Util.runCatching(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Class.forName(clazz,<span class=\"keyword\">false</span>,classLoader);</span><br><span class=\"line\">        &#125;).getResult();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(claz==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Field declaredField : claz.getDeclaredFields()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Modifier.isPublic(declaredField.getModifiers())) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            VariableDef def = <span class=\"keyword\">new</span> VariableDef(declaredField.getType().getCanonicalName(),declaredField.getName());</span><br><span class=\"line\">            cm.getFields().put(declaredField.getName(),def);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Method declaredMethod: claz.getDeclaredMethods())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Modifier.isPublic(declaredMethod.getModifiers()))<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            MethodSign sign = <span class=\"keyword\">new</span> MethodSign(declaredMethod.getName(), (ArrayList&lt;String&gt;) Arrays.stream(declaredMethod.getParameterTypes()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList()));</span><br><span class=\"line\">            cm.getMethods().add(sign);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ClassDef cdf = <span class=\"keyword\">new</span> ClassDef();</span><br><span class=\"line\">        cdf.setClassName(clazz);</span><br><span class=\"line\">        cdf.setSuperclass(claz.getSuperclass()==<span class=\"keyword\">null</span>?<span class=\"keyword\">null</span>:claz.getSuperclass().getCanonicalName());</span><br><span class=\"line\">        cdf.setInterfaces(Arrays.stream(claz.getInterfaces()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList()));</span><br><span class=\"line\">        cm.setClassDefinition(cdf);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>静态分析结束后，我们就要准备开始生成 AST 了。</p>\n<blockquote>\n<p>附<br>我们从 token 流中获取数据，并且根据类型进行匹配——但我们其实没有用到状态<br>仔细看，你会发现这个东西：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        i=i+1; // Move Pointer to (</span><br><span class=\"line\"><span class=\"addition\">+        MethodSign sign = readMethodSign(methodName);</span></span><br><span class=\"line\">        if(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode()))&#123;</span><br><span class=\"line\">            throw new ParseException(fileName+&quot;: Duplicated method: &quot;+sign+&quot; at line &quot;+now.getLine());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cm.getMethods().add(sign);</span><br><span class=\"line\"><span class=\"addition\">+        skipCodeBlocks();</span></span><br><span class=\"line\">        continue;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>是不是有些象是 DSL？<br>这其实归咎于类字段中那个不起眼的 <code>int i = 0</code>，它使得 for 循环的指针可以被整个类里的方法所共享。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String <span class=\"title\">readAsStringUntilLB</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 一只读，读到一个换行为止并且收集成字符串</span></span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> a = i; tokens.get(a).getType()!= Token.Type.BREAK_LINE;a++)&#123;</span><br><span class=\"line\">        sb.append(tokens.get(a).getContent());</span><br><span class=\"line\">        b=a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在经过更加详细的 tokenize 之后，代码实际上变得更加可观了，</p>\n</blockquote>\n<h2 id=\"Parser-1\"><a href=\"#Parser-1\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p>先占个坑位～</p>\n",
            "tags": [
                "tech"
            ]
        },
        {
            "id": "https://nstd.sfclub.cc/2021/07/18/Idea/",
            "url": "https://nstd.sfclub.cc/2021/07/18/Idea/",
            "title": "修复 Intellij IDEA 无法使用中文输入法",
            "date_published": "2021-07-18T05:51:17.000Z",
            "content_html": "<p>踩坑记录  </p>\n<h1 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h1><p>系统: ArchLinux<br>一切的大前提: 环境变量设置正确(GTK_IM_MODULE…)  </p>\n<ol>\n<li>ibus 用户可以试试迁移到 fcitx</li>\n<li>fcitx 如果不行可能得自己编译一个 patched 的 JetBrains Runtime<span id=\"more\"></span>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1>IDEA 没法输入中文的问题其实在我系统上盘踞很久了，一会能用一会不能的….所以我打算动手整顿他</li>\n</ol>\n<h1 id=\"设置环境变量\"><a href=\"#设置环境变量\" class=\"headerlink\" title=\"设置环境变量\"></a>设置环境变量</h1><p>学着 ArchLinux Wiki，我首先往 <code>~/.pam_environment</code> 加了这些东西:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GTK_IM_MODULE DEFAULT&#x3D;ibus</span><br><span class=\"line\">QT_IM_MODULE DEFAULT&#x3D;ibus</span><br><span class=\"line\">XMODIFIERS DEFAULT&#x3D;\\@im&#x3D;ibus</span><br></pre></td></tr></table></figure>\n<p>然而并没有什么效果… 加到 <code>idea.sh</code> 头上也不行，<code>qtconfig-qt4</code> 也改过了，没啥效果</p>\n<h1 id=\"修改键盘布局\"><a href=\"#修改键盘布局\" class=\"headerlink\" title=\"修改键盘布局\"></a>修改键盘布局</h1><p><del>压根没变化</del></p>\n<h1 id=\"更换输入法\"><a href=\"#更换输入法\" class=\"headerlink\" title=\"更换输入法\"></a>更换输入法</h1><p>于是我尝试更换到 fcitx （<br>更换到 fcitx 之后似乎已经可以在 idea 窗口里面召唤出 fcitx 了，但是好像还是输入不了中文  </p>\n<h1 id=\"自己编译\"><a href=\"#自己编译\" class=\"headerlink\" title=\"自己编译\"></a>自己编译</h1><p>在 archlinuxcn 论坛上找到了一个回复:</p>\n<blockquote>\n<p>其实解决这个问题的过程还挺曲折的，我不打算直接给出顺利的解决方案，所以建议先看完，再动手操作，否则会踩老坑，以下是折腾记录：<br>问题：fcitx搜狗输入法在idea环境中文输入不跟随光标<br>解决方案参考链接： <a href=\"https://blog.csdn.net/u011166277/articl\">https://blog.csdn.net/u011166277/articl</a> … /106287587<br>辛酸史：<br>先下载JetBrainsRuntime源码，<a href=\"https://github.com/JetBrains/JetBrainsRuntime\">https://github.com/JetBrains/JetBrainsRuntime</a><br>因为github很慢，所以到<a href=\"https://gitee.com/%E4%B8%8A%E5%AF%BC%E5%85%A5github%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%A4%E7%A7%8D%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%95%99%E7%A8%8B%E9%83%BD%E5%9C%A8https://zhuanlan.zhihu.com/p/121015450\">https://gitee.com/上导入github进行下载，还有两种下载方式，教程都在https://zhuanlan.zhihu.com/p/121015450</a><br>代下载网站<a href=\"https://shrill-pond-3e81.hunsh.workers.dev/\">https://shrill-pond-3e81.hunsh.workers.dev/</a>       <a href=\"http://g.widyun.com/\">http://g.widyun.com/</a>    网速慢的话容易过期<br>下载完JetBrainsRuntime之后下载idea.patch  <a href=\"https://github.com/prehonor/myJetBrainsRuntime\">https://github.com/prehonor/myJetBrainsRuntime</a><br>然后把idea.patch拷贝到JetBrainsRuntime根目录<br>git checkout cfc3e87f2ac27a0b8c78c729c113aa52535feff6  （这一步经过测试，并不需要，用最新的就好）<br>git apply idea.patch<br>然后根据官方教程编译就行了，但是，别信官方的，经过测试docker打包出现未知错误，还不知道咋查，ubuntu版本低了还不行，一会儿404，一会儿缺jdk11，拖过来一个jdk11又说glibc版本不够，安装glibc直接整个系统挂了，所有命令都不能用了，所以还是开个虚拟机，直接上ubuntu20吧，然后按照官方的教程编译<br>$ sudo apt-get install autoconf make build-essential libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libxrandr-dev libcups2-dev libfontconfig1-dev libasound2-dev<br>$ cd JetBrainsRuntime<br>$ sh ./configure –disable-warnings-as-errors<br>$ make images<br>你以为这就完了吗？中途会直接出现killed错误，所以，内存至少2G，swap单开一个3G的<br>$ dd if=/dev/zero of=swapfile bs=1024 count=3<em>1024</em>1024<br>$ sudo mkswap swapfile<br>$ sudo swapon swapfile<br>$ free -h<br>然后照常make images，编译完了之后，会生成jdk，从虚拟机中拷贝出来<br>sudo scp -o PasswordAuthentication=yes -r 用户名@虚拟机ip:/home/用户名/JetBrainsRuntime/build/linux-x86_64-normal-server-release/images/jdk  /usr/lib/jvm/java-11.0.7-jetbrains<br>如果你以为按照教程里export IDEA_JDK=/usr/lib/jvm/java-11.0.7-jetbrains 就可以启动，那就又错了，还会报错<br>/usr/lib/jvm/java-11.0.7-jetbrains/bin/java: symbol lookup error: /usr/lib/jvm/java-11.0.7-jetbrains/lib/libnio.so: undefined symbol: initInetAddressIDs<br>你以为只要ldd 看到libjvm.so =&gt; not found就应该把/usr/lib/jvm/java-11.0.7-jetbrains/lib/server/libjvm.so 加到环境变量就行了？不，亲自试验过了，没用，对比了一下正常启动的idea，发现libnet.so路径不对，正常要取jdk里的，于是又加入环境变量，这回启动两次居然直接crash了<br>最后，经过一系列折腾，搞出一个最佳解决办法，修改启动文件<br>$ sudo vim /opt/intellij-idea-ultimate-edition/bin/idea.sh<br>在开头加上<br>export LD_LIBRARY_PATH=/usr/lib/jvm/java-11.0.7-jetbrains/lib:$LD_LIBRARY_PATH &amp;&amp; export IDEA_JDK=/usr/lib/jvm/java-11.0.7-jetbrain<br>这回终于能启动成功了，编译好的jdk最好保存一下，别再这么折腾了</p>\n</blockquote>\n<p>实际操作 ( px 是透明代理 )：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">px git clone https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;JetBrainsRuntime</span><br><span class=\"line\">cd JetBrainsRuntime</span><br><span class=\"line\">px wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;prehonor&#x2F;myJetBrainsRuntime&#x2F;master&#x2F;idea.patch</span><br><span class=\"line\">git apply .&#x2F;idea.patch</span><br><span class=\"line\">sh .&#x2F;configure --disable-warnings-as-errors</span><br><span class=\"line\">make images #其实这一步内存足够就不会出问题，不一定需要开swap什么的 编译使用的是liberica-11-openjdk</span><br><span class=\"line\">sudo mv .&#x2F;build&#x2F;linux-&lt;tab&gt;&#x2F;images&#x2F;jdk &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jetbrains-11-openjdk</span><br></pre></td></tr></table></figure>\n\n<p>然后打开 IDEA，安装 <code>Choose Runtime</code> 插件<br>添加自定义jdk，使用你刚编译的jetbrains runtime启动即可。（笔者机器上无报错）<br>此处提供版本 <code>jb11_0_11-b1504.12</code> 的构建修改版（x86_64）: <a href=\"https://ipfs.io/ipfs/QmRMkFu4UKCP4bFfXaMFurRt6f3aWJuWqZj97z1LbC92Ri?filename=jbjdk.7z\">下载</a></p>\n",
            "tags": [
                "idea,fcitx,ibus"
            ]
        },
        {
            "id": "https://nstd.sfclub.cc/2021/03/13/%E4%BD%BF%E7%94%A8-cproxy-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/",
            "url": "https://nstd.sfclub.cc/2021/03/13/%E4%BD%BF%E7%94%A8-cproxy-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/",
            "title": "使用 cproxy 对程序进行透明代理",
            "date_published": "2021-03-13T14:57:30.000Z",
            "content_html": "<p>在 Windows 下，说到 <code>透明代理</code> ，你可能会想到 <code>Proxifier</code> , <code>SSTap</code>, <code>Mellow</code><br>但在 Linux 下，你可能会想到 <code>proxychains</code> 然后再想到 <code>proxychains</code> 不能代理 static-linked 的程序。  </p>\n<span id=\"more\"></span>\n<h1 id=\"为什么-ProxyChains-NG-不能代理静态连接的程序\"><a href=\"#为什么-ProxyChains-NG-不能代理静态连接的程序\" class=\"headerlink\" title=\"为什么 ProxyChains(NG) 不能代理静态连接的程序\"></a>为什么 ProxyChains(NG) 不能代理静态连接的程序</h1><p>ProxyChains NG 通过一个预加载的共享库来hook到网络相关的函数(比如: connect,getaddrinfo)上，接着他就可以转发这些流量。<br>缺点似乎显而易见，如果只是通过 <a href=\"https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick\">LD_PRELOAD</a> 来进行透明代理，那么这招对于静态连接的程序是无用的（比如说 Go 程序..)<br>其次，ProxyChains 只支持 TCP，这可能导致无法转发 DNS 流量 -&gt; DNS 流量泄漏。  </p>\n<h1 id=\"cproxy-是什么\"><a href=\"#cproxy-是什么\" class=\"headerlink\" title=\"cproxy 是什么\"></a>cproxy 是什么</h1><p><a href=\"https://github.com/NOBLES5E/cproxy\">cproxy</a> 也是透明代理，作用和 proxychains 类似。<br>原理上与 proxychains 不同，它使用 <code>cgroup</code> 进行对程序的代理 <del>，不过配置起来还有点麻烦</del><br>本文将会教您在您的Linux PC上使用 cproxy，截至本文发布之前，cproxy似乎只支持 Linux。  </p>\n<h2 id=\"下载-cproxy\"><a href=\"#下载-cproxy\" class=\"headerlink\" title=\"下载 cproxy\"></a>下载 cproxy</h2><p>官方推荐的方法是: 直接用 <code>cargo</code>    </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo install cproxy</span><br></pre></td></tr></table></figure>\n\n<p>如果没有 cargo 可以在 <a href=\"https://github.com/NOBLES5E/cproxy/releases\">Release</a> 上下载压缩包。<br>解压压缩包，可能会发现有两个可执行文件，不过似乎只留一个就好了。  </p>\n<h2 id=\"安装-cproxy\"><a href=\"#安装-cproxy\" class=\"headerlink\" title=\"安装 cproxy\"></a>安装 cproxy</h2><p>先来试一试 cproxy！  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cproxy --port &lt;本地代理端口&gt; -- curl ip.sb</span><br></pre></td></tr></table></figure>\n\n<p>( ｀д′) 失败了<br>如果你和我一样，在port上写了 socks5 的代理端口，那么你就被坑了。<br>笔者填入 geph 的 HTTP 代理端口时是可以成功的，但是使用 v2ray 的s5/http端口都无法使用。<br>这是因为 cproxy 需要<a href=\"https://github.com/NOBLES5E/cproxy/wiki/Example-setup-with-V2Ray\">修改 v2ray 的配置</a>进行兼容，<a href=\"https://github.com/zfl9/ipt2socks\">如果你不想去改配置</a>  </p>\n<p>在确保可以使用 cproxy 后，我们来配置 <code>alias</code>。<br>将以下内容写到 <code>~/.bashrc</code>，记得自己修改一些部分。  </p>\n<pre><code class=\"bash\">alias &quot;px&quot;=&quot;/path/to/cproxy --port &lt;your-local-proxy-port&gt; --&quot;\n</code></pre>\n<p>例如我的配置：</p>\n<pre><code class=\"bash\">alias &quot;px&quot;=&quot;/bin/cproxy --port 60080 --use-tproxy -- &quot; # 60080 是ipt2socks的默认监听端口。\n</code></pre>\n<p>保存后，使用 <code>source ~/.bashrc</code> 载入，试试 <code>px curl ip.sb</code>，看看是否成功。  </p>\n<h2 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h2><p>每次使用都要 sudo ，还是挺烦人的吧…<br>对于这种情况，也可以考虑使用有后台常驻的 <a href=\"https://github.com/springzfx/cgproxy\">cgproxy</a>，但本文不做介绍，有兴趣可以自己了解。  </p>\n",
            "tags": [
                "tech,linux"
            ]
        },
        {
            "id": "https://nstd.sfclub.cc/2021/03/12/hello-world/",
            "url": "https://nstd.sfclub.cc/2021/03/12/hello-world/",
            "title": "Hello World",
            "date_published": "2021-03-12T14:43:58.173Z",
            "content_html": "<p>你好, Hexo！<br>折腾了一个晚上，我终于还是回到 Hexo 的怀抱了。<br>接下来会陆陆续续更新一些杂文，并且把我在 Lxnet 发布的那几篇文章搬一下，欢迎 <a href=\"https://github.com/iceBear67/blog\">Watch/订阅</a> 我的博客。  </p>\n",
            "tags": []
        }
    ]
}