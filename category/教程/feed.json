{
    "version": "https://jsonfeed.org/version/1",
    "title": "nstd::out • All posts by \"教程\" category",
    "description": "iceBear 的博客",
    "home_page_url": "https://ib67.io",
    "items": [
        {
            "id": "https://ib67.io/2022/07/06/Extending-Java-Compiler/",
            "url": "https://ib67.io/2022/07/06/Extending-Java-Compiler/",
            "title": "「9+」 Java 编译器插件教程 101",
            "date_published": "2022-07-06T11:25:58.000Z",
            "content_html": "<p>写了上万行 Java 代码，相比你已经对 Java “木纳呆板”的语法恨之入骨了。  </p>\n<p>那么，有没有一种可能，我是说可能，我们可以给 Java 编译器写插件？</p>\n<span id=\"more\"></span>\n\n<p>如果你要在面包店里买面包，你最好跟店员说你要买哪块面包。本文所指的 <code>Java 编译器</code> 均为 OpenJDK 自带的那个 <code>javac</code>，而不是其他的前端编译器实现。</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>自从 Java 8 起，Oracle 就将<a href=\"https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Plugin.html\">插件</a>系统引入了 <code>javac</code> 中，因此是可以写 Javac 插件的。</p>\n<p>虽然写一个 Javac 插件并且修改代码是可能的，但是这方面的资料很少（国内就更少了），并且大多内容重复（教你写个 HelloWorld 然后就结束），其次 javac 的东西也不是很好摸，毕竟不是公开 API（ JDK 9+ 开始已经不暴露在外了）。  </p>\n<p>恰逢今年还没写技术类的博客，就拿来磨磨刀吧。</p>\n<h1 id=\"先从插件说起\"><a href=\"#先从插件说起\" class=\"headerlink\" title=\"先从插件说起\"></a>先从插件说起</h1><p>上文刚刚提到了一个词，<code>插件</code>。它其实正是 <a href=\"https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Plugin.html\">com.sun.source.util.Plugin</a>。通过这个类，我们可以让 Javac 在编译时加载我们的代码。</p>\n<p>加载了代码，那么做什么呢？所以我们立一个目标：<em>给所有 <code>@Jsonized</code> 标注过的类都生成一个可以输出 json 的 <code>toString()</code> 方法。</em></p>\n<p>什么意思呢？就比如说这样一个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyResponse</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String message;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> success;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyResponse</span><span class=\"params\">(String message, <span class=\"keyword\">boolean</span> success)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.message = message;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.success = success;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后你想把它序列化成 Json。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> response = <span class=\"keyword\">new</span> MyResponse(<span class=\"string\">&quot;\\&quot;Success!\\&quot; Took me 114514 yr 1919810 m&quot;</span>,<span class=\"keyword\">false</span>).toString();</span><br><span class=\"line\">response.equals(<span class=\"string\">&quot;&quot;</span><span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;&quot;</span>message<span class=\"string\">&quot;: &quot;</span>\\<span class=\"string\">&quot;Success!\\&quot; Took me 114514 yr 1919810 m&quot;</span>, <span class=\"string\">&quot;success&quot;</span>: <span class=\"keyword\">false</span>&#125;</span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span><span class=\"string\">&quot;);</span></span><br></pre></td></tr></table></figure>\n\n<p>又快又便捷，还不需要第三方类库，这就是我们的目标。</p>\n<p>那么先把这个注解写出来吧！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.inlambda.kiwi.magic;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Classes with this type can be serialized to json by their &#123;<span class=\"doctag\">@link</span> #toString()&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Jsonized &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得提一点就是这些编译器注解的 <code>Retention</code> 用 <code>RetentionPolicy.SOURCE</code> 也是可以的，但是以后可能运行期间我们需要识别到这些被修改过的类，所以设置为 <code>RUNTIME</code>。</p>\n<p>接着是，实现 Javac 的 <code>Plugin</code> 接口！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.inlambda.kiwi.magic.plugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.util.Plugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KiwiJavacPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Kiwi&quot;</span>; <span class=\"comment\">// 插件的名字</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(JavacTask task, String... args)</span> </span>&#123; <span class=\"comment\">// 插件初始化回调</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello Kiwi&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是它不让你过编译。</p>\n<h2 id=\"打通模块的穴位\"><a href=\"#打通模块的穴位\" class=\"headerlink\" title=\"打通模块的穴位\"></a>打通模块的穴位</h2><p>这怎么能忍！在默认包目录下创建一个 <code>module-info.java</code>。  </p>\n<p><img src=\"https://upload.cc/i1/2022/07/06/avTEyu.png\" alt=\"Package Layout\"></p>\n<p>然后我们写点东西进去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> kiwi.magic.main &#123; <span class=\"comment\">// module 后跟模块名，下文要用</span></span><br><span class=\"line\">    <span class=\"keyword\">requires</span> jdk.internal.vm.compiler;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> jdk.compiler;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> java.naming;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加入这些之后，还要配置一下构建工具的编译参数。</p>\n<p>（本教程使用 Gradle, Maven/SBT 用户请自行摸索….）</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compileJava &#123;</span><br><span class=\"line\">    options.compilerArgs &lt;&lt; <span class=\"string\">&quot;--add-exports=jdk.compiler/com.sun.tools.javac.tree=kiwi.magic.main&quot;</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;--add-exports=jdk.compiler/com.sun.tools.javac.code=kiwi.magic.main&quot;</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;--add-exports=jdk.compiler/com.sun.tools.javac.util=kiwi.magic.main&quot;</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;--add-exports=jdk.compiler/com.sun.tools.javac.api=kiwi.magic.main&quot;</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;--add-exports=jdk.compiler/com.sun.tools.javac.processing=kiwi.magic.main&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就能过编译了！虽然 IDEA 仍然会划出红线，但是只要接受他的解决方案就好（形如 <code>add XX to compiler option</code>）</p>\n<blockquote>\n<p>由于 IDEA 可能不会自动补全没有确定模块关系的类，教程可能会大量使用完整的类名或是指向 Java SE 8 Documentation 的引用链接。</p>\n</blockquote>\n<h2 id=\"配置-Service\"><a href=\"#配置-Service\" class=\"headerlink\" title=\"配置 Service\"></a>配置 Service</h2><p>Javac 通过 <a href=\"https://www.baeldung.com/java-spi\">Java SPI</a> 发现插件，因此你需要写一个 Service 文件让他能够发现你。</p>\n<p>在 <code>src/main/resource/META-INF/services/com.source.util.Plugin</code> 中写出：</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># 填写你的插件主类名，这是教程的例子。</span></span><br><span class=\"line\">org.inlambda.kiwi.magic.plugin.KiwiJavacPlugin</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload.cc/i1/2022/07/06/Mxt7gB.png\" alt=\"File Location\"></p>\n<p>但是还差一步。</p>\n<h2 id=\"加载插件\"><a href=\"#加载插件\" class=\"headerlink\" title=\"加载插件\"></a>加载插件</h2><p>Javac 也是一个 Java 程序，他是在他的运行时 classpath 里面寻找插件的。  </p>\n<p>而在 Gradle 中，<code>annotationProcessor</code> 就会被加入到编译器的 classpath 中。但我们不能用 <code>annotationProcessor this</code> ，因为 gradle 不允许，所以我们需要另外新建一个模块专门测试插件。</p>\n<p><img src=\"https://upload.cc/i1/2022/07/06/dG2bf6.png\" alt=\"Module Layout\"></p>\n<p>为了加载插件，应当确保 <code>build.gradle</code> 中有如下内容：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    testImplementation <span class=\"string\">&#x27;org.junit.jupiter:junit-jupiter-api:5.8.1&#x27;</span></span><br><span class=\"line\">    testRuntimeOnly <span class=\"string\">&#x27;org.junit.jupiter:junit-jupiter-engine:5.8.1&#x27;</span></span><br><span class=\"line\">    compileOnly(project(<span class=\"string\">&quot;:magic&quot;</span>))</span><br><span class=\"line\">    annotationProcessor(project(<span class=\"string\">&quot;:magic&quot;</span>)) <span class=\"comment\">// 就是这个！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">compileJava &#123; options.compilerArgs &lt;&lt; <span class=\"string\">&#x27;-Xplugin:Kiwi&#x27;</span> &#125; <span class=\"comment\">// Kiwi 是插件的名字</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>万事具备，开 <code>assemble</code> ！</p>\n<p><img src=\"https://upload.cc/i1/2022/07/06/AcTFPU.png\" alt=\"Gradle Assemble Output\"></p>\n<p>现在，我们已经让 Javac 加载了我们的代码，但这仅仅是个开始。为了实现 <code>@Jsonized</code> 的目标，我们还需要注入代码。</p>\n<h1 id=\"得到编译单元\"><a href=\"#得到编译单元\" class=\"headerlink\" title=\"得到编译单元\"></a>得到编译单元</h1><p>对 AST 下手，首先要拿到 <a href=\"https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/CompilationUnitTree.html\">CompilationUnit</a></p>\n<p>而 Javac 通过 <a href=\"https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/TaskEvent.html\">TaskEvent</a> 将它传递给我们，因此我们要注册一个 <code>com.sun.source.util.TaskListener</code> 来收 <code>TaskEvent</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(JavacTask task, String... args)</span> </span>&#123; <span class=\"comment\">// 插件初始化回调</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello Kiwi&quot;</span>);</span><br><span class=\"line\">    task.addTaskListener(<span class=\"keyword\">new</span> KiwiTaskListener(((BasicJavacTask) task).getContext()); <span class=\"comment\">// this!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>KiwiTaskListener</code>: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.inlambda.kiwi.magic.plugin.jc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.util.TaskEvent;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.util.TaskListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Context;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KiwiTaskListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">TaskListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Context context;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">KiwiTaskListener</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.context = context;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">started</span><span class=\"params\">(TaskEvent e)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finished</span><span class=\"params\">(TaskEvent e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.getKind() != TaskEvent.Kind.PARSE) &#123; <span class=\"comment\">// 注意此处</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> compUnit = e.getCompilationUnit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>编译流程:<br>Java 编译器的几个阶段:</p>\n<ul>\n<li>COMPILATION</li>\n<li>PARSE – 构造抽象语法树 (AST)</li>\n<li>ENTER – 源码里的引用均已被解析</li>\n<li>ANALYZE – 生成 AST 并用于分析错误</li>\n<li>GENERATE – 为源码生成输出 (.class)</li>\n<li>ANNOTATION_PROCESSING - 注解处理器被唤起</li>\n<li>ANNOTATION_PROCESSING_ROUND</li>\n<li>COMPILATION</li>\n</ul>\n<p>因为我们的目标是修改代码（对编译器来说，也就是对抽象语法树下手），所以只需要关心 PARSE 阶段就好了。<br>如果你对 “AST” 和 “PARSE” 的概念还不太了解，那么你可以先看看我的<a href=\"./Writting-A-Compiler-1.md\">另一篇博客</a></p>\n</blockquote>\n<h2 id=\"获取-AST\"><a href=\"#获取-AST\" class=\"headerlink\" title=\"获取 AST\"></a>获取 AST</h2><p>得到 <code>CompilationUnit</code> 后，我们便可以<a href=\"https://refactoringguru.cn/design-patterns/visitor\">“访问”</a>到对应的 <code>class</code> 了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.inlambda.kiwi.magic.plugin.jc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.tree.ClassTree;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.util.TreeScanner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.tree.JCTree; <span class=\"comment\">//注意这些完整类名，如果你的 IDEA 补全不了尝试复制这些到 IDEA 里面去。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.tree.TreeMaker; </span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Names;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.inlambda.kiwi.magic.plugin.gens.GenJsonToString;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonizedTreeScanner</span> <span class=\"keyword\">extends</span> <span class=\"title\">TreeScanner</span>&lt;<span class=\"title\">Void</span>, <span class=\"title\">Context</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">visitClass</span><span class=\"params\">(ClassTree node, Context ctx)</span> </span>&#123; <span class=\"comment\">// 此处 Context 是类型参数里规定的</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> maker = TreeMaker.instance(ctx); <span class=\"comment\">// 1</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> name = Names.instance(ctx); <span class=\"comment\">// 2</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> claz = (JCTree.JCClassDecl) node; <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.getModifiers()</span><br><span class=\"line\">                .getAnnotations()</span><br><span class=\"line\">                .stream()</span><br><span class=\"line\">                .anyMatch(e -&gt;</span><br><span class=\"line\">                    e.getAnnotationType()</span><br><span class=\"line\">                        .toString()</span><br><span class=\"line\">                        .equals(<span class=\"string\">&quot;Jsonized&quot;</span>))) &#123; <span class=\"comment\">// 判断是否有 Jsonized</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Jsonized class found: &quot;</span> + node.getSimpleName());</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.visitClass(node, ctx);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            System.err.println(t.getMessage());</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (StackTraceElement stackTraceElement : t.getStackTrace()) &#123;</span><br><span class=\"line\">                System.out.println(stackTraceElement); </span><br><span class=\"line\">                <span class=\"comment\">// Javac 会屏蔽掉正常的报错输出，因此需要手动打印出来。</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.visitClass(node, ctx);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来逐个讲解这些代码。</p>\n<ol>\n<li><p><strong>TreeMaker</strong> 是一个非常重要的组件，通过 <code>TreeMaker</code> 我们可以创建语法树的组件然后把它们插入到现有的语法树里，也就是修改代码。</p>\n</li>\n<li><p><strong>Names</strong> 也是一个重要组件，因为它几乎就是符号表，虽然其本身是 <code>Identifier</code> ….。</p>\n</li>\n<li><p><code>JCTree.JCClassDecl</code> 就是类在AST中的定义，我们接下来会讲解到它以及更多 <code>JCTree</code> 子类的应用。</p>\n</li>\n</ol>\n<p>同时，我们在 <code>magic-test</code> 模块中创建一个类用于测试 <code>@Jsonized</code>，但为了节约篇幅，类的代码不列出。</p>\n<p>让我们的访客访问 <code>CompilationUnit</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finished</span><span class=\"params\">(TaskEvent e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.getKind() != TaskEvent.Kind.PARSE) &#123; <span class=\"comment\">// 注意此处</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> compUnit = e.getCompilationUnit();</span><br><span class=\"line\">    compUnit.accept(<span class=\"keyword\">new</span> JsonizedTreeScanner(), context); <span class=\"comment\">// 此处 context 是上文类构造器依赖注入进来的</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>尝试编译 <code>magic-test</code>，你应当能在 <code>compileJava</code> 阶段看到 <code>Jsonized class found: XXX</code>。</p>\n<h1 id=\"对-AST-动手动脚\"><a href=\"#对-AST-动手动脚\" class=\"headerlink\" title=\"对 AST 动手动脚\"></a>对 AST 动手动脚</h1><p><em>哎呀，你怎么动手动脚的！</em>  </p>\n<p>拿到了类定义，我们就可以访问类里的所有元素了！另外，<code>JCTree</code> 的子类通常是可以<em>直接 toString()</em> 出来的，你可以利用这一点查看编译的输出。</p>\n<p>但在修改之前，得先了解一下 Javac 内部的 List 实现。</p>\n<h2 id=\"List-in-Javac\"><a href=\"#List-in-Javac\" class=\"headerlink\" title=\"List in Javac\"></a>List in Javac</h2><p>Javac 不知道出于什么缘故，他自己有一个链表（<code>com.sun.tools.javac.util.List&lt;A&gt;</code>）的实现，而且他是不可变的。</p>\n<p>这个链表不对外公开（因为 Oracle 官方网站也没有 Javadoc），所以不提供引用链接了。</p>\n<p>此处介绍几个常用的方法。</p>\n<ul>\n<li><p>List.nil()<br>静态方法。顾名思义，空集。</p>\n</li>\n<li><p>List.of(A x1, A x2, A x3, A… rest)<br>一个静态工厂，用于创建一个定长的 List.</p>\n</li>\n<li><p>一些类似 <code>prepend</code> 和 <code>append</code> 这样对元素操作的方法…<br>他们都返回新的实例，因为 <code>List&lt;A&gt;</code> 是不可变的，小心别被坑了。</p>\n</li>\n</ul>\n<p>等等，那不定长的呢？于是我们还有一个类，他就是 <code>com.sun.tools.javac.util.ListBuffer&lt;A&gt;</code>。</p>\n<p><code>ListBuffer&lt;A&gt;</code> 是 <code>List&lt;A&gt;</code> 某种类似 <a href=\"https://refactoringguru.cn/design-patterns/builder\">Builder</a> 的工具，他的 <code>append</code> 等方法始终返回他自己，用完之后可以 <code>toList()</code> 转换成 <code>List&lt;A&gt;</code>。</p>\n<p>做好这些基础知识的准备工作，我们终于，终于，终于可以开始动工了。</p>\n<h2 id=\"访问类里的元素\"><a href=\"#访问类里的元素\" class=\"headerlink\" title=\"访问类里的元素\"></a>访问类里的元素</h2><p><img src=\"https://upload.cc/i1/2022/07/06/tQ4Xlz.png\" alt=\"Methods of JCClassDecl\"></p>\n<p><code>JCClassDecl</code> 并没有严格区分开来方法和字段，他们都是 <code>member</code>。然而 <code>getMembers()</code> 是只读的（因为 <code>List&lt;A&gt;</code> 不可变），所以我们要绕开 <code>getMembers()</code> 直接访问到后面的字段。</p>\n<p>绕也很简单…</p>\n<p><img src=\"https://upload.cc/i1/2022/07/06/7hlANk.png\" alt=\"field defs\"></p>\n<p>没想到吧，Javac 里面就是这么乱。</p>\n<p>接下来往 <code>defs</code> 里面插入方法即可。</p>\n<h2 id=\"构造方法然后插进去！\"><a href=\"#构造方法然后插进去！\" class=\"headerlink\" title=\"构造方法然后插进去！\"></a>构造方法然后插进去！</h2><p>这里我们就要请出刚刚提到过的大名鼎鼎的 <code>TreeMaker</code> 了！ 方法定义在 Javac 中就是 <code>com.sun.tools.javac.tree.JCTree.MethodDecl</code>，可以通过 <code>TreeMaker#MethodDef</code> 构造。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 建议把生成方法单独放起来</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> JCTree.<span class=\"function\">JCMethodDecl <span class=\"title\">genMethod</span><span class=\"params\">(TreeMaker maker, Names symbolTable, JCTree.JCClassDecl claz)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> method = maker.at(claz.pos).MethodDef( <span class=\"comment\">// 1</span></span><br><span class=\"line\">            maker.Modifiers(Flags.PUBLIC | Flags.FINAL), <span class=\"comment\">// 方法的修饰符</span></span><br><span class=\"line\">            symbolTable.fromString(<span class=\"string\">&quot;toString&quot;</span>), <span class=\"comment\">// 2 方法的名称</span></span><br><span class=\"line\">            maker.Ident(symbolTable.fromString(<span class=\"string\">&quot;String&quot;</span>)), <span class=\"comment\">// 3 返回值类型</span></span><br><span class=\"line\">            List.nil(),</span><br><span class=\"line\">            List.nil(), <span class=\"comment\">// 这三个先忽略再说</span></span><br><span class=\"line\">            List.nil(),</span><br><span class=\"line\">            maker.Block(<span class=\"number\">0</span>, makeReturnJsonExpress(maker, symbolTable, claz)) <span class=\"comment\">// 方法体</span></span><br><span class=\"line\">            , <span class=\"keyword\">null</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> method;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是不是有些迷糊？我们”娓娓道来”…</p>\n<ol>\n<li><code>at(claz.pos).MethodDef(</code><br> 这句的意思是把 <code>TreeMaker</code> 当前的位置调整到目标类上然后再创建一个方法定义，不然可能会把方法生成到别的地方。（不过我没试过，其实方法和类关系是比较确定的，所以这个 <code>pos</code> 可能是给语句用的，因为语句有顺序。）</li>\n<li><code>symbolTable.fromString(&quot;toString&quot;)</code><br> <code>Names</code> 提供了 <code>fromString</code> 方法用来创建对应的标识符/名字（Identifier）。</li>\n<li><code>maker.Ident</code><br> <code>Ident</code> 是一个很常用的方法，他可以接受一个 <code>Names</code> 然后输出一个 <code>JCIdent</code>。<br> 而 <code>JCIdent</code> 恰好是 <code>JCExpression</code>，也就是 <code>JCTree</code> 的子类。</li>\n</ol>\n<p>注意，从符号表拿类型并不需要把命名写完整（就好像上文写的不是 java.lang.String），如果要引入外部的类型只需要 <code>maker.Import</code> 即可</p>\n<blockquote>\n<p>例如：<code>maker.Import(maker.Ident(names.fromString(&quot;java.util.Objects&quot;)).getTree(), false);</code></p>\n</blockquote>\n<p>这还只是方法的基本信息，接下来是方法体，也就是最关键的那部分。</p>\n<p>但在写输出 Json 之前，我们不妨先写个 <code>HelloWorld</code> 试试。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;JCTree.JCStatement&gt; makeReturnJsonExpress(TreeMaker maker, Names name, JCTree.JCClassDecl claz) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> List.of(maker.Return(maker.Literal(<span class=\"string\">&quot;Hello Jsonized!&quot;</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们回到上文，把新的方法体插入到类里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">var</span> claz = (JCTree.JCClassDecl) node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.getModifiers().getAnnotations().stream().anyMatch(e -&gt; e.getAnnotationType().toString().equals(<span class=\"string\">&quot;Jsonized&quot;</span>))) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Jsonized class found: &quot;</span> + node.getSimpleName());</span><br><span class=\"line\">        claz.def = claz.def.append(genMethod(maker,name,claz)); <span class=\"comment\">// THIS</span></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.visitClass(node, ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">    System.err.println(t.getMessage());</span><br></pre></td></tr></table></figure>\n\n<p>尝试编译 <code>magic-test</code> 模块并且查看编译输出，如果你没有干坏事的话应该能看到 <code>@Jsonized</code> 标注过的类里多出来一个 <code>public final String toString()</code>，并且代码体正是 <code>return &quot;Hello Jsonized!&quot;;</code>。</p>\n<p><img src=\"https://upload.cc/i1/2022/07/06/AMR7Q0.png\" alt=\"Decompiler Output\"><br><em>(由于我的 Jsonized 用的是 <code>RetentionPolicy.SOURCE</code>，所以注解编译后就被抹除掉了)</em></p>\n<h1 id=\"AST-的常用姿势\"><a href=\"#AST-的常用姿势\" class=\"headerlink\" title=\"AST 的常用姿势\"></a>AST 的常用姿势</h1><p>到上一节，你已经成功的：</p>\n<ul>\n<li>让 Javac 加载你的代码</li>\n<li>对特定注解标志过的类添加代码</li>\n</ul>\n<p>那么这一节，我们着重讲解一些常用的操作以及更多基础知识。</p>\n<h2 id=\"从获取字段开始\"><a href=\"#从获取字段开始\" class=\"headerlink\" title=\"从获取字段开始\"></a>从获取字段开始</h2><p>为了序列化出所有字段，我们首先需要知道我们的类里有哪些字段。</p>\n<p>幸好，使用 <code>Stream</code> 就可以很轻松地做到这件事:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nameToVar = claz.getMembers().stream()</span><br><span class=\"line\">    .filter(e -&gt; e.getKind() == Tree.Kind.VARIABLE) <span class=\"comment\">// 其实这个可能可以省略</span></span><br><span class=\"line\">    .filter(e -&gt; e <span class=\"keyword\">instanceof</span> JCTree.JCVariableDecl)</span><br><span class=\"line\">    .map(e -&gt; (JCTree.JCVariableDecl) e)</span><br><span class=\"line\">    .collect(Collectors.toMap(e -&gt; e.getName(), e -&gt; e.getType()));</span><br></pre></td></tr></table></figure>\n\n<p>产出一个 <code>Map&lt;Names, JCTree&gt;</code>。<code>JCTree</code> 就是类定义，此处为 <code>JCVariableDecl</code></p>\n<p>有了这样一个 nameToVar 之后，我们就可以构造 Json 了。</p>\n<h2 id=\"拼接字符串与二元表达式\"><a href=\"#拼接字符串与二元表达式\" class=\"headerlink\" title=\"拼接字符串与二元表达式\"></a>拼接字符串与二元表达式</h2><p><em>哪个男孩不想体验一下二元运算符呢？</em></p>\n<p><img src=\"https://upload.cc/i1/2022/07/06/bYdHB3.png\" alt=\"Figure: Binary Operator\"></p>\n<p>“+” 是一个二元运算符，它接受两个参数: <code>a</code> 和 <code>b</code> 并且产出一个结果。</p>\n<p>在 Java 里，我们是这样写的：<code>a + b</code></p>\n<p>那么如果更多参数呢？</p>\n<p><img src=\"https://upload.cc/i1/2022/07/06/8xWLDn.png\" alt=\"Figure: Complexier Binary Tree\"></p>\n<p>以此类推，可以构造出一个很长很长的二元树，而这正好是我们今天要做的事情。  </p>\n<hr>\n<p>先从拼接字符串开始，举个例子：<code>a + &quot;literal&quot;</code></p>\n<p>如果我们要让一个命名 <code>a</code> 和一个字面量（<code>&quot;literal&quot;</code>）相加，要怎么做呢？其实很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JCTree.JCBinary binary = maker.Binary(</span><br><span class=\"line\">    JCTree.Tag.PLUS,</span><br><span class=\"line\">     maker.Ident(names.fromString(<span class=\"string\">&quot;a&quot;</span>)),</span><br><span class=\"line\">      maker.Literal(<span class=\"string\">&quot;literal&quot;</span>)); <span class=\"comment\">// 此处 PLUS 为运算符 &quot;+&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload.cc/i1/2022/07/06/uf4SRB.png\" alt=\"Figure: Explaination of Java Code\"></p>\n<p>回过头来，我们拼接 Json 的代码应该是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&#123;\\&quot;success\\&quot;:&quot;</span>+ success +<span class=\"string\">&quot;,\\&quot;response\\&quot;:+&quot;</span> response <span class=\"string\">&quot;+&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>也就是:</p>\n<p><img src=\"https://upload.cc/i1/2022/07/06/AcwJkP.png\" alt=\"Figure: Example of Json Concatenating\"></p>\n<p>不难看出，到最后这些拼接代码都会被聚合成一个 <code>JCBinary</code>。通过这个性质，我们可以使用 <code>Stream#reduce</code> 来把众多元素聚合成一个 <code>JCBinary</code>。</p>\n<p>此处贴出完整的 <code>makeReturnJsonExpress</code> 以供参考。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;JCTree.JCStatement&gt; makeReturnJsonExpress(TreeMaker maker, Names name, JCTree.JCClassDecl claz) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> json = claz.getMembers().stream()</span><br><span class=\"line\">        .filter(e -&gt; e.getKind() == Tree.Kind.VARIABLE)</span><br><span class=\"line\">        .filter(e -&gt; e <span class=\"keyword\">instanceof</span> JCTree.JCVariableDecl)</span><br><span class=\"line\">        .map(e -&gt; (JCTree.JCVariableDecl) e)</span><br><span class=\"line\">        .collect(Collectors.toMap(e -&gt; e.getName(), e -&gt; e.getType()));</span><br><span class=\"line\">    <span class=\"keyword\">var</span> list = json.entrySet().stream()</span><br><span class=\"line\">            .map(e -&gt; </span><br><span class=\"line\">            maker.Binary(JCTree.Tag.PLUS, </span><br><span class=\"line\">                maker.Literal(<span class=\"string\">&quot;\\&quot;&quot;</span> + e.getKey() + <span class=\"string\">&quot;\\&quot;:&quot;</span>),</span><br><span class=\"line\">                maker.Ident(e.getKey()) <span class=\"comment\">// 引用字段名</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">            ).reduce((e1, e2) -&gt; </span><br><span class=\"line\">                maker.Binary(</span><br><span class=\"line\">                    JCTree.Tag.PLUS, </span><br><span class=\"line\">                    e1, </span><br><span class=\"line\">                    maker.Binary(</span><br><span class=\"line\">                        JCTree.Tag.PLUS, </span><br><span class=\"line\">                        maker.Literal(<span class=\"string\">&quot;,&quot;</span>),</span><br><span class=\"line\">                        e2)</span><br><span class=\"line\">            ))</span><br><span class=\"line\">            .orElseThrow();</span><br><span class=\"line\">    list = maker.Binary(JCTree.Tag.PLUS, maker.Literal(<span class=\"string\">&quot;&#123;&quot;</span>), list);</span><br><span class=\"line\">    list = maker.Binary(JCTree.Tag.PLUS, list, maker.Literal(<span class=\"string\">&quot;&#125;&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> List.of(maker.Return(</span><br><span class=\"line\">            list</span><br><span class=\"line\">    ));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们的 <code>@Jsonized</code> 生成的 <code>toString</code> 已经可以处理简单情况了。</p>\n<h2 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h2><p>但是游戏还没结束，你很快会发现一个问题…. 如果数据里存有特殊字符，例如 <code>&quot;</code> 那就出事了！因此，要给字符串加一些特殊处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&#123;\\&quot;success\\&quot;:&quot;</span>+ success +<span class=\"string\">&quot;,\\&quot;response\\&quot;:+&quot;</span> response.replaceAll(<span class=\"string\">&quot;\\\\\\&quot;&quot;</span>,<span class=\"string\">&quot;\\\\\\\\\\&quot;&quot;</span>) <span class=\"string\">&quot;+&#125;&quot;</span> <span class=\"comment\">// 拼接的时候把 &quot; 替换为 \\&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>也就是说，我们要对 <code>response</code> 进行方法调用。那么，先引入一个新方法吧！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> JCTree.<span class=\"function\">JCExpression <span class=\"title\">processValue</span><span class=\"params\">(JCTree value, Name name, TreeMaker maker, Names names)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> typeName = value.toString();</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (typeName) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;String&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;CharSequence&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;StringBuilder&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;StringBuffer&quot;</span>: <span class=\"comment\">// 一切可以 toString 的...</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> toS = maker.Exec(maker.Apply(</span><br><span class=\"line\">                    List.nil(),</span><br><span class=\"line\">                    maker.Select(</span><br><span class=\"line\">                            maker.Ident(name),</span><br><span class=\"line\">                            names.fromString(<span class=\"string\">&quot;toString&quot;</span>)</span><br><span class=\"line\">                    ),</span><br><span class=\"line\">                    List.nil()</span><br><span class=\"line\">            )); <span class=\"comment\">// toS: name.toString()</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> replaced = maker.Exec( <span class=\"comment\">// 1</span></span><br><span class=\"line\">                    maker.Apply( <span class=\"comment\">// 2</span></span><br><span class=\"line\">                            List.nil(), <span class=\"comment\">// 类型参数，就是方法的泛型，不多过关心</span></span><br><span class=\"line\">                            maker.Select( <span class=\"comment\">// 3</span></span><br><span class=\"line\">                                    toS.expr,</span><br><span class=\"line\">                                    names.fromString(<span class=\"string\">&quot;replaceAll&quot;</span>)</span><br><span class=\"line\">                            ),</span><br><span class=\"line\">                            List.of( <span class=\"comment\">// 方法参数</span></span><br><span class=\"line\">                                    maker.Literal(<span class=\"string\">&quot;\\\\\\&quot;&quot;</span>),</span><br><span class=\"line\">                                    maker.Literal(<span class=\"string\">&quot;\\\\\\\\\\&quot;&quot;</span>)</span><br><span class=\"line\">                            )</span><br><span class=\"line\">                    )</span><br><span class=\"line\">            ); <span class=\"comment\">// replaced: name.toString().replaceAll(...)</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> maker.Binary(JCTree.Tag.PLUS, maker.Literal(<span class=\"string\">&quot;\\&quot;&quot;</span>),</span><br><span class=\"line\">                    maker.Binary(JCTree.Tag.PLUS, replaced.expr, maker.Literal(<span class=\"string\">&quot;\\&quot;&quot;</span>)));</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> maker.Ident(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>写这篇博文的时候我还没有去深究具体要怎么获取到 <code>JCVariable</code> 的类型关系，所以只有这么蠢的方法。</p>\n</blockquote>\n<p>还是老样子，逐步解释代码：</p>\n<ol>\n<li><code>Exec</code> 执行的意思，这里可以传入一个 <code>JCExpression</code></li>\n<li><code>Apply</code> 返回一个 <code>JCMethodInvocation</code>，正是我们要的东西</li>\n<li><code>Select</code> 返回一个 <code>JCFieldAccess</code>，而参数是发起操作的对象和他对应的方法/字段（瞎猜的）<br>当然这里你也可以用 <code>maker.Ident(name)</code> 来代替 <code>Select</code>，也就是直接对 name 对应的对象发起动作。</li>\n</ol>\n<p>之后再修改一下之前的代码：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                .map(e -&gt; </span><br><span class=\"line\">                maker.Binary(JCTree.Tag.PLUS, </span><br><span class=\"line\">                    maker.Literal(&quot;\\&quot;&quot; + e.getKey() + &quot;\\&quot;:&quot;),</span><br><span class=\"line\"><span class=\"deletion\">-                   maker.Ident(e.getKey()) // 引用字段名</span></span><br><span class=\"line\"><span class=\"addition\">+                   processValue(e.getValue(), e.getKey(), maker, name)</span></span><br><span class=\"line\">                )</span><br><span class=\"line\">                ).reduce((e1, e2) -&gt; </span><br></pre></td></tr></table></figure>\n\n<p><em>大功告成。现在你已经得到了一个可以处理 <code>String/CharSequence/StringBuilder/StringBuffer</code> 里的转义问题（当然，只限于双引号）的编译期序列化 Json 的编译器插件了！</em></p>\n<blockquote>\n<p>一种更好的做法: 委托<br>与其这样大费周章的在编译器完成这些工作，倒不如再带几个类进去然后委托到类上的静态方法进行转换。<br>这样做的好处有很多，例如无需重新编译这些 <code>class</code> , 例如可以通过代码编写更灵活的转换机制… 等等。实际上，Java 14+ 中 Record 的 <code>equals</code> 正是通过 <code>INVOKEDYNAMIC</code> 委托到别处比较实现的，并且高版本 Java 中 String 类型的拼接也使用了委托。</p>\n</blockquote>\n<h1 id=\"附：使用注解处理器\"><a href=\"#附：使用注解处理器\" class=\"headerlink\" title=\"附：使用注解处理器\"></a>附：使用注解处理器</h1><p>除了直接编写 Javac 插件，我们还有另外一种做法，就是 <code>Annotation Processor</code>，注解处理器。</p>\n<p>比起 Javac 插件，它的局限较高，但是用起来会方便一点<del>因为不用加那个”-Xplugin”的编译器 参数</del></p>\n<p>所以这里简单介绍一下如何使用注解处理器访问 AST。类似 <code>Plugin</code>，你需要先继承一个 <code>AbstractProcessor</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.inlambda.kiwi.magic.plugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.util.Trees;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.tree.JCTree;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.tree.TreeMaker;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Names;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.inlambda.kiwi.magic.Jsonized;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.inlambda.kiwi.magic.NoNullExcepted;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.inlambda.kiwi.magic.plugin.gens.GenJsonToString;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.inlambda.kiwi.magic.plugin.gens.GenNoNull;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.processing.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.lang.model.SourceVersion;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.lang.model.element.Element;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.lang.model.element.TypeElement;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SupportedAnnotationTypes(&quot;*&quot;)</span> <span class=\"comment\">// 表示处理任意元素</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedSourceVersion(SourceVersion.RELEASE_11)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KiwiAnnotationProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Context context;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Trees trees; <span class=\"comment\">// 注意这里还有个 Trees</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeMaker maker;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Names names;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnv);</span><br><span class=\"line\">        trees = Trees.instance(processingEnv);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> f = processingEnv.getClass().getDeclaredField(<span class=\"string\">&quot;context&quot;</span>); <span class=\"comment\">// 得到 context</span></span><br><span class=\"line\">            f.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            context = (Context) f.get(processingEnv);</span><br><span class=\"line\">            maker = TreeMaker.instance(context);</span><br><span class=\"line\">            names = Names.instance(context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后一样在 <code>META-INF/services/javax.annotation.processing.Processor</code> 里写上你的类名，注意是 <code>Processor</code> 而不是 <code>AbstractProcessor</code> …</p>\n<p>拿到 <code>TreeMaker</code>, <code>Context</code>，<code>Trees</code> 和 <code>Names</code> 之后就好办很多了，接下来的问题是怎么获取到 AST。</p>\n<p>好在 Annotation Processor API 允许我们处理所有元素而不只是规定的几个注解标注过的元素，我们可以在 <code>boolean process(...)</code> 方法中访问到所有我们要的元素（前提是 <code>@SupportedAnnotationTypes(&quot;*&quot;)</code> ）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TypeElement annotation : annotations) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotation.getQualifiedName().contentEquals(Jsonized.class.getName())) &#123; <span class=\"comment\">// 先判断这个注解是不是我们的</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Element element : roundEnv.getElementsAnnotatedWith(annotation)) &#123; </span><br><span class=\"line\">                <span class=\"comment\">//接着可以拿到注解标注过的所有元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 因为我们的注解 Target 是 TYPE，所以只能在类上。这里直接强转成 JCClassDecl 即可。</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 通过 Trees 得到它对应的 AST 元素。这里的 element 实际上是个 ClassSymbol</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> jtree = (JCTree.JCClassDecl) trees.getTree(element);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> method = GenJsonToString.genMethod(maker, names, jtree); <span class=\"comment\">// 似曾相似的套路，这就是我什么推荐你单独放....</span></span><br><span class=\"line\">                jtree.defs = jtree.defs.append(method);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>That’s it!</em> 其实这种需求用注解处理器的话似乎比直接写 Javac 插件还要简单一些？</p>\n<blockquote>\n<p>注意: 注解处理器不能和 javac 插件混着用，而且在 gradle 中，他们似乎是在不同的环境里被加载的。（也就是你无法通过静态字段传递加载信息来判断用户想用的是插件还是注解处理器）</p>\n</blockquote>\n<h1 id=\"End-结语\"><a href=\"#End-结语\" class=\"headerlink\" title=\"End / 结语\"></a>End / 结语</h1><p>本文简要介绍了 javac 闭包 API 的基本使用以及一种使用注解处理器访问 javac AST 的方法。</p>\n<p>不过需要注意的是，虽然这些 API 自从 1.8 加入以来就没怎么变过（应该？），他们仍然是<strong>不稳定，不安全，无保障</strong>的。因此，若要使用，请总是进行单元测试并且尝试检查版本兼容性。</p>\n<p>本篇博客的所有代码均为 <a href=\"https://codeberg.org/InlinedLambdas/Kiwi\">Kiwi</a> 项目的一部分，Kiwi 以 MIT 协议开源，如果你想 Star 但是没有 Codeberg 帐号的话可以去 GitHub 上的<a href=\"https://github.com/InlinedLambdas/kiwi\">镜像</a> (疯狂暗示)</p>\n<p>文章可能有偏差，可以在评论区指正。</p>\n<p>End.</p>\n<hr>\n<p>Credits:</p>\n<p><a href=\"https://stackoverflow.com/questions/46773519/accessing-com-sun-tools-javac-util-from-java-9\">StackoverFlow - Accessing com.sun.tools.javac.util from Java 9</a><br><a href=\"https://www.baeldung.com/java-annotation-processing-builder\">Baeldung - Java Annotation Processing and create a builder</a><br><a href=\"https://www.baeldung.com/java-build-compiler-plugin\">Baeldung - Creating a Java Compiler Plugin</a>  </p>\n<p>… and many random StackoverFlow Answers. Thanks for them.</p>\n",
            "tags": [
                "编译器",
                "技术",
                "Java"
            ]
        },
        {
            "id": "https://ib67.io/2021/10/01/Writting-A-Compiler-1/",
            "url": "https://ib67.io/2021/10/01/Writting-A-Compiler-1/",
            "title": "从零开始的编译器生涯",
            "date_published": "2021-10-01T14:12:37.000Z",
            "content_html": "<p>近日一屑高二学生无聊动手写起了编译器….这是他的珍贵作战记录    </p>\n<span id=\"more\"></span>\n\n<h1 id=\"0x01-理论基础\"><a href=\"#0x01-理论基础\" class=\"headerlink\" title=\"0x01 理论基础\"></a>0x01 理论基础</h1><p>我摊牌，我没有看任何编译原理相关的书籍，因此这篇文章并不能作为严格的参考资料，甚至很多地方可能是错误的。  </p>\n<p>编译器，编译器，就是把高级语言的代码编译成另一种形式（class，asm，二进制，IR），而他在编译成另一种形式之前大概需要过这么个流程:</p>\n<p>Lex -&gt; Parse -&gt; Compile  </p>\n<p>接下来逐步讲解这个过程。</p>\n<h2 id=\"Lexer\"><a href=\"#Lexer\" class=\"headerlink\" title=\"Lexer\"></a>Lexer</h2><p>就是分词器，输入用户提供的代码接着把他分成 <code>tokens</code>，也就是 <code>tokenstream</code>。<br>你肯定看不懂上面那句话的意思，让我们来点实例：<br><img src=\"https://upload.cc/i1/2021/10/01/gGftuh.png\" alt=\"image\"><br><code>a.value</code> 里的那个 <code>ArrayList</code> 就是一个 <code>token stream</code>，<code>str</code> 是被解析的代码。不难发现，语句被 Lexer 按顺序进行了分类以及数据的分割，如 <code>a</code> 被识别为了一个 <code>Identify</code> (标记)。 </p>\n<p>因此也可以归纳出来 <code>Token</code> 大致的代码长啥样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Token</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> line;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Parser\"><a href=\"#Parser\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p>Lexer 从源码中提取出 <code>token stream</code> 后将会交给 <code>Parser</code> 处理，它负责对 <code>token stream</code> 进行解析，生成一个 <code>AST (Abstract Syntax Tree)</code>，也就是 <code>抽象语法树</code>。  </p>\n<p><img src=\"https://upload.cc/i1/2021/10/01/nVE3wl.png\"><br>这张图直观的描述了这一过程，你可以看到它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。  </p>\n<p>接着，AST 将会丢给代码生成器用于生成代码，但是一般会先对 AST 进行优化，例如 <code>常量折叠</code></p>\n<h2 id=\"Static-Analyzing\"><a href=\"#Static-Analyzing\" class=\"headerlink\" title=\"Static Analyzing\"></a>Static Analyzing</h2><p>但在这之前，我们还有一些问题要解决。<br><del>其实这玩意我是和 Parser 写一块的</del><br>试想一下，如果有这样一行代码：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = love + cats</span><br></pre></td></tr></table></figure>\n<p>代码生成器如何知道 <code>love</code> 和 <code>cats</code> 是什么？ 在 Parser 的眼里，他们只是 <code>Identifier</code>，然而它们之间不能相加减。  </p>\n<p>在这种时候，Parser 需要预先建立一个符号表，这样他才能找出 <code>love</code> 和 <code>cats</code> 究竟是什么以及是否能够编译。</p>\n<p>同理，下面的代码也一样需要这一过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(List&lt;String&gt; args)</span></span>&#123; <span class=\"comment\">// 此处 Parser 将会分析出 java.lang.String 和 java.util.List</span></span><br><span class=\"line\">  NullCat nc = <span class=\"keyword\">new</span> SBNC(); <span class=\"comment\">// 按照 Java 的逻辑，此处没有导入（或同包）于是会产生错误，因为Parser找不到 SBNC / NullCat</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Code-Generation\"><a href=\"#Code-Generation\" class=\"headerlink\" title=\"Code Generation\"></a>Code Generation</h2><p>接着是生成代码！<br>一般编译器都会输出一种 <code>IR (Intermediate Representation)</code> 码，而他的作用则是一种中间表示。<br>例如，如果你输出 LLVM 的 IR 码，那么接下来你的编译工作（win,x64,linux,…jvm）就可以交给 LLVM 来完成，而像 <code>LLVM</code> 这样负责最后这一步骤的我们称之为 <code>编译器的后端</code></p>\n<p>使用这一种方法有几个好处：</p>\n<ul>\n<li>它可以使得开发者更专注于 <code>语言设计</code> 而不用过多的考虑 <code>优化</code>，因为大多数编译器后端会帮你完成这件事情 <del>，除非你直接输出汇编那就得你自己负责优化了</del>。</li>\n<li>IR 是中间表示，它可以按照相同的语义编译出不同平台，不同架构的代码，大大节省了开发者时间</li>\n<li>…</li>\n</ul>\n<p> 处于个人习惯，我选择了 Java 的字节码作为 “IR”，他将会被 JVM 加载并在运行过程中收集数据被更好的优化以及可以享受和 Java 互操作，跨平台的优势。</p>\n<h1 id=\"0x02-实践\"><a href=\"#0x02-实践\" class=\"headerlink\" title=\"0x02 实践\"></a>0x02 实践</h1><p>知道了这些理论，我们立即可以开始编写我们的第一个 Lexer 了。</p>\n<p>这是我们这一大章节的目标代码：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> java.util.List</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">fn <span class=\"title\">main</span><span class=\"params\">(args: List&lt;<span class=\"keyword\">String</span>&gt;)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span> <span class=\"string\">&quot;hello world!&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，让我们开始吧！<br>下文将会有大量代码，为了可读性，我会删掉一些无关紧要的部分。</p>\n<h2 id=\"Lexer-1\"><a href=\"#Lexer-1\" class=\"headerlink\" title=\"Lexer\"></a>Lexer</h2><p>我的 Lexer 分为两步：<code>fuzzyTokenize</code> 和 <code>tokenize</code>。<br>实际上这是取决于做法的，有正则转 DFA（状态机）的，也有直接 <code>charStream</code> 的。</p>\n<p>我选择了第二种，因为我认为使用正则的代码可读性比较糟糕，不易于维护。那么，让我们开始做一些准备工作…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lexer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String fileName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String rawContent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Lexer</span><span class=\"params\">(String content,String fileName)</span> </span>&#123;</span><br><span class=\"line\">        rawContent = content.replaceAll(<span class=\"string\">&quot;//.*|(\\&quot;(?:\\\\\\\\[^\\&quot;]|\\\\\\\\\\&quot;|.)*?\\&quot;)|(?s)/\\\\*.*?\\\\*/&quot;</span>, <span class=\"string\">&quot;$1 &quot;</span>); <span class=\"comment\">// remove comments.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName=fileName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从构造方法接受源代码和文件名并且删除注释。你可能会问文件名用来干啥，那当然是用来报错的～<br>接着，还有一个 <code>LexedNode</code> 用来表示 <code>fuzzyTokenize</code> 后的产物。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LexedNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> NodeType type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 初始化和getter...</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">NodeType</span> </span>&#123;</span><br><span class=\"line\">        IDENTIFIER,SYMBOL,KEYWORD,OPERATOR,</span><br><span class=\"line\">        LINE_SEPERATOR,</span><br><span class=\"line\">        LITERAL_STRING,LITERAL_NUMBER</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这就是一个最基本的 <code>token</code>! 在后文，我们将会进行第二次 <code>tokenize</code> 使它变得更详细。  </p>\n<p>准备好了，开始写吧！首先是一个状态机：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;LexedNode&gt; <span class=\"title\">fuzzyTokenize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] charStream = rawContent.toCharArray();</span><br><span class=\"line\">    List&lt;LexedNode&gt; nodes = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> line = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; charStream.length; i++) &#123; <span class=\"comment\">// 使用 fori 是为了循环时移动指针</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> now = charStream[i];</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (now) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\n&#x27;</span>:</span><br><span class=\"line\">              nodes.add(<span class=\"keyword\">new</span> LexedNode(NodeType.LINE_SEPERATOR,<span class=\"string\">&quot;\\n&quot;</span>))</span><br><span class=\"line\">              <span class=\"keyword\">continue</span>; <span class=\"comment\">// 此处使用 continue 立即跳到下一次循环</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nodes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是你的第一个 Lexer，可以先输出一下看看结果：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br></pre></td></tr></table></figure>\n\n<p>因为代码有五行，因此是五个 <code>LINE_SEPERATOR</code>。<br>只有换行符可不够，我们还要识别 <code>KEYWORD</code> ，也就是关键词。<br>然而关键词使用空格分割，因此我们可以这样做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(...)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27; &#x27;</span>:                </span><br><span class=\"line\">        inIdOrLiteral = !inIdOrLiteral;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inIdOrLiteral) &#123; <span class=\"comment\">// start collecting</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// end!</span></span><br><span class=\"line\">        String str = buffer.toString();</span><br><span class=\"line\">        identifierParse(str, nodes);</span><br><span class=\"line\">        buffer = <span class=\"keyword\">new</span> StringBuilder(); <span class=\"comment\">// compose</span></span><br><span class=\"line\">         <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 此处换行同理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Collect String or Identifier */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inIdOrLiteral) &#123;</span><br><span class=\"line\">        buffer.append(now);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以看到，我们引入了两个新的变量和一个方法，它们分别是 <code>inIdOrLiteral</code> 和 <code>buffer</code> 以及 <code>identifierParse</code>。</p>\n<p><strong>inIdOrLiteral</strong> 表示当前是否正在遍历一个 <code>Identifier</code> 或者一个字面量<br><strong>buffer</strong> 用于收集这个字面量，当然你也可以使用 <code>substring</code> 和 <code>charAt</code> 的方法<br><strong>identifierParse</strong> 是一个方法，他用于分类 Identifier。对于 <code>11</code>，他会分类成一个 <code>LITERAL_NUMBER</code>，对于 <code>not_a_keyword</code>，他会分类成一个 identifier，对于 <code>fn</code>，他会分类成一个 Keyword。</p>\n<p>还没完，天资聪颖的你肯定已经注意到了这里少了一样东西——我要怎么匹配最开头的一个 <code>using</code> ？ <code>using</code> 的前头可没有一个空格。<br>这时你可以回忆一下，在各种编程语言中作为 <code>Identifier</code> 的符号应该符合什么规则….是的，他们通常不会以运算符作为开头，以及他们不是一个关键字，因此我们还可以利用这个特性写出这样的代码:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         <span class=\"comment\">/* Other Symbols */</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (SYMBOL_OR_OPERATORS.contains(now）) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (inIdOrLiteral) &#123; <span class=\"comment\">// keyword</span></span><br><span class=\"line\">                 <span class=\"comment\">// now == a symbol,we should end this.</span></span><br><span class=\"line\">                 identifierParse(buffer.toString(), nodes);</span><br><span class=\"line\">                 buffer = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                 inIdOrLiteral = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (SYMBOLS.contains(now)) &#123;</span><br><span class=\"line\">                 nodes.add(<span class=\"keyword\">new</span> LexedNode(now, LexedNode.NodeType.SYMBOL));</span><br><span class=\"line\">                 <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (OPERATORS.contains(now)) &#123;</span><br><span class=\"line\">                 nodes.add(<span class=\"keyword\">new</span> LexedNode(now, LexedNode.NodeType.OPERATOR));</span><br><span class=\"line\">                 <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> LexerException(fileName+<span class=\"string\">&quot;: Unknown char: &quot;</span> + now+<span class=\"string\">&quot; line: &quot;</span>+line);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             inIdOrLiteral = <span class=\"keyword\">true</span>; <span class=\"comment\">// not symbol &amp; not identifier</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Collect String or Identifier */</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (inIdOrLiteral) &#123;</span><br><span class=\"line\">     buffer.append(now);</span><br><span class=\"line\">     <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一段代码将会在匹配第一个字符没有遇到语言规定的操作符或者特殊符号的时候把 <code>inIdOrLiteral</code> 设置为 <code>true</code>。配合上面的代码，在遇到一个空格的时候他会结束收集并且尝试判断是什么。</p>\n<p>实际上应该是 <code>switch</code> 的任务但是写成 <code>if</code> 更加直观一些。  </p>\n<p>那么到现在，我们可以开始尝试代码了！这是 Lexer 的输出：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEYWORD using</span><br><span class=\"line\">IDENTIFIER java</span><br><span class=\"line\">OPERATOR .</span><br><span class=\"line\">IDENTIFIER util</span><br><span class=\"line\">OPERATOR .</span><br><span class=\"line\">IDENTIFIER List</span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">KEYWORD fn</span><br><span class=\"line\">IDENTIFIER main</span><br><span class=\"line\">SYMBOL (</span><br><span class=\"line\">IDENTIFIER args</span><br><span class=\"line\">OPERATOR :</span><br><span class=\"line\">IDENTIFIER List&lt;String&gt;</span><br><span class=\"line\">SYMBOL )</span><br><span class=\"line\">SYMBOL &#123;</span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">KEYWORD println</span><br><span class=\"line\"><span class=\"deletion\">- LITERAL_STRING hello world!</span></span><br><span class=\"line\"><span class=\"addition\">+ IDENTIFIER &quot;hello</span></span><br><span class=\"line\"><span class=\"addition\">+ IDENTIFIER world!&quot;</span></span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">SYMBOL &#125;</span><br><span class=\"line\">5: RIGHT_BRACKET &#125;</span><br></pre></td></tr></table></figure>\n\n<p>相比你已经注意到了，理应出现的 <code>LITERAL_STRING</code> 被两个 IDENTIFIER 代替了，这显然不是我们想要的结果。因此，我们要给 String 加入特 殊 支 持  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(now)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&quot;&#x27;</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; charStream[i - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;\\\\&#x27;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// string starts or end</span></span><br><span class=\"line\">                        inIdOrLiteral = !inIdOrLiteral;</span><br><span class=\"line\">                        stringMode = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!inIdOrLiteral) &#123;</span><br><span class=\"line\">                            stringMode = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                            <span class=\"comment\">// a new string!</span></span><br><span class=\"line\">                            nodes.add(<span class=\"keyword\">new</span> LexedNode(buffer.toString(), LexedNode.NodeType.LITERAL_STRING));</span><br><span class=\"line\">                            buffer = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    case &#x27; &#x27;:</span><br><span class=\"line\"><span class=\"addition\">+        if (stringMode) &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+            break;</span></span><br><span class=\"line\"><span class=\"addition\">+        &#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">- if (SYMBOL_OR_OPERATORS.contains(now)) &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+ if (SYMBOL_OR_OPERATORS.contains(now) &amp;&amp; !stringMode) &#123;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样我们就躲开了这个陷阱，完成了对于 String 的支持后，我们的 <code>fuzzyTokenize</code> 就做好了！</p>\n<blockquote>\n<p>关于 OPERATORS 和 SYMBOLS<br>一门语言里的符号很多，你绝对不会想把他们一个个 add 到 list 里面的，但你可以写一个 <a href=\"https://github.com/iceBear67/NullCatLang/blob/85a9b3234bcaab21451c0c6023f46d3599e5764d/src/main/java/io/ib67/lexer/Lexer.java#L11-L34\">loader</a> 来解决这个问题  </p>\n<p><img src=\"https://upload.cc/i1/2021/10/01/HwBhRN.png\"></p>\n</blockquote>\n<hr>\n<p>然后，是 <code>tokenizer</code>。<code>fuzzyTokenize</code> 输出的结果显然不足以交给 Parser 做解析，我们需要使i结果更加详细。</p>\n<p>好在经过 <code>fuzzyTokenize</code> 后代码已经被格式化成了比较模糊的 <code>Token Stream</code>，这一点使我们写第二次 tokenize 的时候会轻松很多，因为你不会再见到 <code>inIdOrLiteral</code> 和 <code>stringMode</code> 这种让人抓狂的东西了。</p>\n<p>首先，让我们从一个新的 Token 开始（你不会想和 LexedNode 混一块的）:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Token</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> line;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Type</span></span>&#123;</span><br><span class=\"line\">        IDENTIFIER(<span class=\"string\">&quot;&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        CLASS(<span class=\"string\">&quot;class&quot;</span>),FUNCTION(<span class=\"string\">&quot;fn&quot;</span>),ANNOTATION(<span class=\"string\">&quot;annotation&quot;</span>),FOR(<span class=\"string\">&quot;for&quot;</span>),WHILE(<span class=\"string\">&quot;while&quot;</span>),IF(<span class=\"string\">&quot;if&quot;</span>),USING(<span class=\"string\">&quot;using&quot;</span>)</span><br><span class=\"line\">        ,THIS(<span class=\"string\">&quot;this&quot;</span>),TRUE(<span class=\"string\">&quot;true&quot;</span>),FALSE(<span class=\"string\">&quot;false&quot;</span>),ELSE(<span class=\"string\">&quot;else&quot;</span>),VAR(<span class=\"string\">&quot;var&quot;</span>),NULL(<span class=\"string\">&quot;null&quot;</span>),PRINTLN(<span class=\"string\">&quot;println&quot;</span>), <span class=\"comment\">// KEYWORDS</span></span><br><span class=\"line\">        VAL(<span class=\"string\">&quot;val&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        LEFT_BRACE(<span class=\"string\">&quot;(&quot;</span>),RIGHT_BRACE(<span class=\"string\">&quot;)&quot;</span>),</span><br><span class=\"line\">        LEFT_BRACKET(<span class=\"string\">&quot;&#123;&quot;</span>),RIGHT_BRACKET(<span class=\"string\">&quot;&#125;&quot;</span>),</span><br><span class=\"line\">        LEFT_MID_BRACE(<span class=\"string\">&quot;[&quot;</span>),RIGHT_MID_BRACE(<span class=\"string\">&quot;]&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        COMMA(<span class=\"string\">&quot;,&quot;</span>),DOT(<span class=\"string\">&quot;.&quot;</span>),MINUS(<span class=\"string\">&quot;-&quot;</span>),PLUS(<span class=\"string\">&quot;+&quot;</span>),STAR(<span class=\"string\">&quot;*&quot;</span>),SLASH(<span class=\"string\">&quot;/&quot;</span>), <span class=\"comment\">// operators</span></span><br><span class=\"line\">        BREAK_LINE(<span class=\"string\">&quot;\\n&quot;</span>),ASSIGNMENT(<span class=\"string\">&quot;=&quot;</span>),EQUALS(<span class=\"string\">&quot;==&quot;</span>),SEMICOLON(<span class=\"string\">&quot;;&quot;</span>),AT(<span class=\"string\">&quot;@&quot;</span>),COLON(<span class=\"string\">&quot;:&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        LITERAL_STRING(<span class=\"string\">&quot;&quot;</span>),LITERAL_NUMBER(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// literals</span></span><br><span class=\"line\">        <span class=\"meta\">@Getter</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String def;</span><br><span class=\"line\">        Type(String def)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.def=def;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>比上文的 LexedNode 详细了很多——比如他主动去分类 keyword 了。<br>接着是一个 fori ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Pair&lt;String,List&lt;Token&gt;&gt; tokenize() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lexedNodes = fuzzyTokenize();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tokens = <span class=\"keyword\">new</span> ArrayList&lt;Token&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> line = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lexedNodes.size(); i++) &#123;</span><br><span class=\"line\">        LexedNode lexedNode = lexedNodes.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (lexedNode.getType()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LINE_SEPERATOR:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.BREAK_LINE,<span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">                line++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SYMBOL:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> KEYWORD:</span><br><span class=\"line\">                <span class=\"keyword\">var</span> type = Arrays.stream(Token.Type.values()).filter(e -&gt; e.getDef().equals(lexedNode.getContent())).findFirst().orElseThrow(()-&gt;&#123;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NullPointerException(lexedNode.toString());</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, type, type.getDef()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LITERAL_STRING:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.LITERAL_STRING, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LITERAL_NUMBER:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.LITERAL_NUMBER, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OPERATOR:</span><br><span class=\"line\">                <span class=\"comment\">// =</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> isEnd = (i == lexedNodes.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (lexedNode.getContent()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;=&quot;</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (isEnd) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> LexerException(fileName+<span class=\"string\">&quot;: Invalid syntax line &quot;</span>+line);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (lexedNodes.get(i + <span class=\"number\">1</span>).getType() == LexedNode.NodeType.OPERATOR &amp;&amp; lexedNodes.get(i + <span class=\"number\">1</span>).getContent().equals(<span class=\"string\">&quot;=&quot;</span>)) &#123; <span class=\"comment\">// ==</span></span><br><span class=\"line\">                            tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.EQUALS, <span class=\"string\">&quot;==&quot;</span>));</span><br><span class=\"line\">                            i = i + <span class=\"number\">1</span>; <span class=\"comment\">// skip next</span></span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.ASSIGNMENT, <span class=\"string\">&quot;=&quot;</span>));</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;.&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.DOT, <span class=\"string\">&quot;.&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;,&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.COMMA, <span class=\"string\">&quot;,&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.MINUS, <span class=\"string\">&quot;-&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.PLUS, <span class=\"string\">&quot;+&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.STAR,<span class=\"string\">&quot;*&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.SLASH,<span class=\"string\">&quot;/&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;;&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.SEMICOLON,<span class=\"string\">&quot;;&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;:&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line,Token.Type.COLON,<span class=\"string\">&quot;:&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IDENTIFIER:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.IDENTIFIER, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pair.of(fileName,tokens);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码并不难懂。在这个例子中，我们遍历来自 fuzzyTokenizer 的数据并且通过 switch 分类枚举来处理把他们转化成 <code>Token</code> 来表达并且存储到 <code>tokens</code>。对于 symbol 和 keyword，我们通过直接搜索 enum 内值的方法避免写出了像 <code>case OPERATOR</code> 里更糟糕的代码。  </p>\n<p><code>case OPERATOR</code> 里写成这样是为了双符号操作的支持，例如 <code>==</code></p>\n<p>回到原题，这次我们可以通过 tokenize 解析出这样的结果：</p>\n<figure class=\"highlight ldif\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">1</span>: USING using</span><br><span class=\"line\"><span class=\"attribute\">1</span>: IDENTIFIER java</span><br><span class=\"line\"><span class=\"attribute\">1</span>: DOT .</span><br><span class=\"line\"><span class=\"attribute\">1</span>: IDENTIFIER util</span><br><span class=\"line\"><span class=\"attribute\">1</span>: DOT .</span><br><span class=\"line\"><span class=\"attribute\">1</span>: IDENTIFIER List</span><br><span class=\"line\"><span class=\"attribute\">1</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">2</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">3</span>: FUNCTION fn</span><br><span class=\"line\"><span class=\"attribute\">3</span>: IDENTIFIER main</span><br><span class=\"line\"><span class=\"attribute\">3</span>: LEFT_BRACE (</span><br><span class=\"line\"><span class=\"attribute\">3</span>: IDENTIFIER args</span><br><span class=\"line\"><span class=\"attribute\">3</span>: COLON :</span><br><span class=\"line\"><span class=\"attribute\">3</span>: IDENTIFIER List&lt;String&gt;</span><br><span class=\"line\"><span class=\"attribute\">3</span>: RIGHT_BRACE )</span><br><span class=\"line\"><span class=\"attribute\">3</span>: LEFT_BRACKET &#123;</span><br><span class=\"line\"><span class=\"attribute\">3</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">4</span>: PRINTLN println</span><br><span class=\"line\"><span class=\"attribute\">4</span>: LITERAL_STRING hello world!</span><br><span class=\"line\"><span class=\"attribute\">4</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">5</span>: RIGHT_BRACKET &#125;</span><br><span class=\"line\"><span class=\"attribute\">5</span>: RIGHT_BRACKET &#125;</span><br></pre></td></tr></table></figure>\n<p>是不是详细了很多？接着我们就可以靠着这个写一个 Parser了</p>\n<h2 id=\"在-Parse-之前\"><a href=\"#在-Parse-之前\" class=\"headerlink\" title=\"在 Parse 之前\"></a>在 Parse 之前</h2><p>在 Parse 之前，我们需要先做一次 Static Analyzing。在这个阶段，Parser 会对文件里的类型和导入表作出关联，同时也是多文件编译的基础。</p>\n<h3 id=\"Metadata\"><a href=\"#Metadata\" class=\"headerlink\" title=\"Metadata\"></a>Metadata</h3><p>你不可能靠着所有人的源码来建立索引，而且源码中的无用信息太多了。<br>实际上，确定符号链接只需要这些信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CatMetadata</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassDef classDefinition = <span class=\"keyword\">new</span> ClassDef();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String,CatMetadata&gt; cachedUsings = <span class=\"keyword\">new</span> HashMap&lt;&gt;(); <span class=\"comment\">// 这是对于被解析对象才有的</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt; MethodSign&gt; methods = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, VariableDef&gt; fields = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关于 <code>ClassDef</code>, <code>MethodSign</code>, <code>VariableDef</code> 等信息本文不贴出，因为并不会影响观看体验。<br>如果有兴趣，可以在<a href=\"https://github.com/iceBear67/NullCatLang/tree/master/src/main/java/io/ib67/ast/decl\">这里</a>找到他们相对应的具体代码  </p>\n</blockquote>\n<p>以及一个编译器全局索引，用 FQDN 确定唯一性的 Map:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Global</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String,CatMetadata&gt; GLOBAL_METADATAS = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> CatMetadata <span class=\"title\">forClass</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          * Scan compiler classPaths</span></span><br><span class=\"line\"><span class=\"comment\">          */</span></span><br><span class=\"line\">         <span class=\"keyword\">var</span> meta = NullCatCompiler.solveMeta(str);</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(meta!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             GLOBAL_METADATAS.put(str, meta);</span><br><span class=\"line\">         &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">             meta = NullCatCompiler.solveMeta(<span class=\"string\">&quot;java.lang.&quot;</span> + str);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> meta;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>准备就绪，我们来单独拿出一个类作为 <code>MetadataGenerator</code> 状态机  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequiredArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MetadataGenerator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String fileName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Token&gt; tokens;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> CatMetadata cm = <span class=\"keyword\">new</span> CatMetadata();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着，是提取数据的部分:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CatMetadata <span class=\"title\">gen</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tokens.size(); i++) &#123;</span><br><span class=\"line\">        Token now = tokens.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> end = (i==tokens.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">        Token next = end?<span class=\"keyword\">null</span>:tokens.get(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(now.getType())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> USING:</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!end)&#123;</span><br><span class=\"line\">                    i=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> clazz = readAsStringUntilLB();</span><br><span class=\"line\">                    cm.getCachedUsings().put(clazz, Optional.ofNullable(CatMetadata.Global.forClass(clazz)).orElseThrow(()-&gt;<span class=\"keyword\">new</span> ParseException(<span class=\"string\">&quot;Can&#x27;t find clazz &quot;</span>+clazz)));</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    throwEOF();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> FUNCTION:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (end) &#123;</span><br><span class=\"line\">                    throwEOF();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// fn main()&#123;&#125;</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(next.getType() != Token.Type.IDENTIFIER)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ParseException(fileName+<span class=\"string\">&quot;: Unexcepted &quot;</span>+next.getType()+<span class=\"string\">&quot; at line &quot;</span>+now.getLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                String methodName = next.getContent();</span><br><span class=\"line\">                i=i+<span class=\"number\">1</span>; <span class=\"comment\">// Move Pointer to (</span></span><br><span class=\"line\">                MethodSign sign = readMethodSign(methodName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode()))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ParseException(fileName+<span class=\"string\">&quot;: Duplicated method: &quot;</span>+sign+<span class=\"string\">&quot; at line &quot;</span>+now.getLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cm.getMethods().add(sign);</span><br><span class=\"line\">                skipCodeBlocks();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cm;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在这个循环当中，我们通过获取到 Token 的类型来判定需要做的操作，这是基于语言设计定义来做的—— 例如 <code>fn</code> 的后面必然是一个方法签名，而不可以是别的。最终 <code>MetadataGenerator</code> 将会返回一个 CatMetadata 以供后续操作。</p>\n<p>因此，这一阶段我们也可以发掘出类型错误和大的语法错误。</p>\n<h3 id=\"与-Java-的世界\"><a href=\"#与-Java-的世界\" class=\"headerlink\" title=\"与 Java 的世界\"></a>与 Java 的世界</h3><p>我们需要和 Java 交互，因此我们需要给 <code>Class</code> 建立 <code>CatMetadata</code> 。好在这很简单，因为 CatMetadata 需要的所有数据都可以通过反射获取，这里提供一段参考代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassMetaPathImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">MetaPath</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassLoader classLoader;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CatMetadata <span class=\"title\">findClass</span><span class=\"params\">(String clazz)</span> </span>&#123;</span><br><span class=\"line\">        CatMetadata cm = <span class=\"keyword\">new</span> CatMetadata();</span><br><span class=\"line\">        Class&lt;?&gt; claz = Util.runCatching(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Class.forName(clazz,<span class=\"keyword\">false</span>,classLoader);</span><br><span class=\"line\">        &#125;).getResult();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(claz==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Field declaredField : claz.getDeclaredFields()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Modifier.isPublic(declaredField.getModifiers())) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            VariableDef def = <span class=\"keyword\">new</span> VariableDef(declaredField.getType().getCanonicalName(),declaredField.getName());</span><br><span class=\"line\">            cm.getFields().put(declaredField.getName(),def);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Method declaredMethod: claz.getDeclaredMethods())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Modifier.isPublic(declaredMethod.getModifiers()))<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            MethodSign sign = <span class=\"keyword\">new</span> MethodSign(declaredMethod.getName(), (ArrayList&lt;String&gt;) Arrays.stream(declaredMethod.getParameterTypes()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList()));</span><br><span class=\"line\">            cm.getMethods().add(sign);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ClassDef cdf = <span class=\"keyword\">new</span> ClassDef();</span><br><span class=\"line\">        cdf.setClassName(clazz);</span><br><span class=\"line\">        cdf.setSuperclass(claz.getSuperclass()==<span class=\"keyword\">null</span>?<span class=\"keyword\">null</span>:claz.getSuperclass().getCanonicalName());</span><br><span class=\"line\">        cdf.setInterfaces(Arrays.stream(claz.getInterfaces()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList()));</span><br><span class=\"line\">        cm.setClassDefinition(cdf);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>静态分析结束后，我们就要准备开始生成 AST 了。</p>\n<blockquote>\n<p>附<br>我们从 token 流中获取数据，并且根据类型进行匹配——但我们其实没有用到状态<br>仔细看，你会发现这个东西：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        i=i+1; // Move Pointer to (</span><br><span class=\"line\"><span class=\"addition\">+        MethodSign sign = readMethodSign(methodName);</span></span><br><span class=\"line\">        if(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode()))&#123;</span><br><span class=\"line\">            throw new ParseException(fileName+&quot;: Duplicated method: &quot;+sign+&quot; at line &quot;+now.getLine());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cm.getMethods().add(sign);</span><br><span class=\"line\"><span class=\"addition\">+        skipCodeBlocks();</span></span><br><span class=\"line\">        continue;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>是不是有些象是 DSL？<br>这其实归咎于类字段中那个不起眼的 <code>int i = 0</code>，它使得 for 循环的指针可以被整个类里的方法所共享。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String <span class=\"title\">readAsStringUntilLB</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 一只读，读到一个换行为止并且收集成字符串</span></span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> a = i; tokens.get(a).getType()!= Token.Type.BREAK_LINE;a++)&#123;</span><br><span class=\"line\">        sb.append(tokens.get(a).getContent());</span><br><span class=\"line\">        b=a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在经过更加详细的 tokenize 之后，代码实际上变得更加可观了，</p>\n</blockquote>\n<h2 id=\"Parser-1\"><a href=\"#Parser-1\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p>先占个坑位～</p>\n",
            "tags": [
                "编译器",
                "技术"
            ]
        },
        {
            "id": "https://ib67.io/2021/03/13/%E4%BD%BF%E7%94%A8-cproxy-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/",
            "url": "https://ib67.io/2021/03/13/%E4%BD%BF%E7%94%A8-cproxy-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/",
            "title": "使用 cproxy 对程序进行透明代理",
            "date_published": "2021-03-13T14:57:30.000Z",
            "content_html": "<p>在 Windows 下，说到 <code>透明代理</code> ，你可能会想到 <code>Proxifier</code> , <code>SSTap</code>, <code>Mellow</code><br>但在 Linux 下，你可能会想到 <code>proxychains</code> 然后再想到 <code>proxychains</code> 不能代理 static-linked 的程序。  </p>\n<span id=\"more\"></span>\n<h1 id=\"为什么-ProxyChains-NG-不能代理静态连接的程序\"><a href=\"#为什么-ProxyChains-NG-不能代理静态连接的程序\" class=\"headerlink\" title=\"为什么 ProxyChains(NG) 不能代理静态连接的程序\"></a>为什么 ProxyChains(NG) 不能代理静态连接的程序</h1><p>ProxyChains NG 通过一个预加载的共享库来hook到网络相关的函数(比如: connect,getaddrinfo)上，接着他就可以转发这些流量。<br>缺点似乎显而易见，如果只是通过 <a href=\"https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick\">LD_PRELOAD</a> 来进行透明代理，那么这招对于静态连接的程序是无用的（比如说 Go 程序..)<br>其次，ProxyChains 只支持 TCP，这可能导致无法转发 DNS 流量 -&gt; DNS 流量泄漏。  </p>\n<h1 id=\"cproxy-是什么\"><a href=\"#cproxy-是什么\" class=\"headerlink\" title=\"cproxy 是什么\"></a>cproxy 是什么</h1><p><a href=\"https://github.com/NOBLES5E/cproxy\">cproxy</a> 也是透明代理，作用和 proxychains 类似。<br>原理上与 proxychains 不同，它使用 <code>cgroup</code> 进行对程序的代理 <del>，不过配置起来还有点麻烦</del><br>本文将会教您在您的Linux PC上使用 cproxy，截至本文发布之前，cproxy似乎只支持 Linux。  </p>\n<h2 id=\"下载-cproxy\"><a href=\"#下载-cproxy\" class=\"headerlink\" title=\"下载 cproxy\"></a>下载 cproxy</h2><p>官方推荐的方法是: 直接用 <code>cargo</code>    </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo install cproxy</span><br></pre></td></tr></table></figure>\n\n<p>如果没有 cargo 可以在 <a href=\"https://github.com/NOBLES5E/cproxy/releases\">Release</a> 上下载压缩包。<br>解压压缩包，可能会发现有两个可执行文件，不过似乎只留一个就好了。  </p>\n<h2 id=\"安装-cproxy\"><a href=\"#安装-cproxy\" class=\"headerlink\" title=\"安装 cproxy\"></a>安装 cproxy</h2><p>先来试一试 cproxy！  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cproxy --port &lt;本地代理端口&gt; -- curl ip.sb</span><br></pre></td></tr></table></figure>\n\n<p>( ｀д′) 失败了<br>如果你和我一样，在port上写了 socks5 的代理端口，那么你就被坑了。<br>笔者填入 geph 的 HTTP 代理端口时是可以成功的，但是使用 v2ray 的s5/http端口都无法使用。<br>这是因为 cproxy 需要<a href=\"https://github.com/NOBLES5E/cproxy/wiki/Example-setup-with-V2Ray\">修改 v2ray 的配置</a>进行兼容，<a href=\"https://github.com/zfl9/ipt2socks\">如果你不想去改配置</a>  </p>\n<p>在确保可以使用 cproxy 后，我们来配置 <code>alias</code>。<br>将以下内容写到 <code>~/.bashrc</code>，记得自己修改一些部分。  </p>\n<pre><code class=\"bash\">alias &quot;px&quot;=&quot;/path/to/cproxy --port &lt;your-local-proxy-port&gt; --&quot;\n</code></pre>\n<p>例如我的配置：</p>\n<pre><code class=\"bash\">alias &quot;px&quot;=&quot;/bin/cproxy --port 60080 --use-tproxy -- &quot; # 60080 是ipt2socks的默认监听端口。\n</code></pre>\n<p>保存后，使用 <code>source ~/.bashrc</code> 载入，试试 <code>px curl ip.sb</code>，看看是否成功。  </p>\n<h2 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h2><p>每次使用都要 sudo ，还是挺烦人的吧…<br>对于这种情况，也可以考虑使用有后台常驻的 <a href=\"https://github.com/springzfx/cgproxy\">cgproxy</a>，但本文不做介绍，有兴趣可以自己了解。  </p>\n",
            "tags": [
                "技术",
                "Linux"
            ]
        }
    ]
}