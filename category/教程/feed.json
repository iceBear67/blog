{
    "version": "https://jsonfeed.org/version/1",
    "title": "nstd::out • All posts by \"教程\" category",
    "description": "iceBear 的博客",
    "home_page_url": "https://ib67.io",
    "items": [
        {
            "id": "https://ib67.io/2022/12/19/Getting-Started-With-Minestom/",
            "url": "https://ib67.io/2022/12/19/Getting-Started-With-Minestom/",
            "title": "上手 Minestom: 新时代 Minecraft 服务端实现",
            "date_published": "2022-12-19T13:20:35.000Z",
            "content_html": "<p>笔者观望 <a href=\"https://github.com/Minestom/Minestom\">Minestom</a> 已经有一段时间了. 以前他的线程模型还不够成熟, 曾经联系 @TheMode 想帮他翻译那块的文档结果鸽了.<br>正好, 今天摸鱼的时候看了一眼 Minestom 官方, 发觉现在或许是时候上手尝试一下了.</p>\n<p>简中圈子里吹 Minestom 的很多, 然而真正上手 / 普及 Minestom 开发的很少. 官方文档已经足够详尽, 因此本篇博文只作引路贴, 希望对 Minestom 感兴趣的你自己上手尝试.</p>\n<span id=\"more\"></span>\n\n<h1 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a>配置环境</h1><p>Minestom 主要托管在 <a href=\"https://jitpack.io/\">JitPack</a> 上.</p>\n<p><code>build.gradle:</code></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    maven &#123;</span><br><span class=\"line\">        name <span class=\"string\">&#x27;JitPack&#x27;</span></span><br><span class=\"line\">        url <span class=\"string\">&#x27;https://jitpack.io&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.github.Minestom:Minestom:VERSION&#x27;</span> <span class=\"comment\">// 版本号自己去 JitPack 上面找</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>静静等待依赖图下载完成, 下载的过程中, 我们不难发现一些老熟人.</p>\n<h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><p>Minestom 启动<code>实现</code>很简单, 只需要两行就搞定了.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">mc</span> <span class=\"operator\">=</span> MinecraftServer.init();</span><br><span class=\"line\">    mc.start(<span class=\"string\">&quot;0.0.0.0&quot;</span>, <span class=\"number\">25565</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个空的 Minestom <code>实现</code>在一秒钟内就能初始化完毕.<br>打开 Minecraft, 添加一个 <code>localhost</code> 到服务器列表中就能看到你的新 Minestom 服务器.</p>\n<p><img src=\"https://i.ibb.co/m0j5BN8/image.png?80\" alt=\"Minestom in ServerList\"></p>\n<blockquote>\n<p>注意: Minestom 语境下的 <code>实例</code> 和 <code>实现</code> 可能和你想象中的不一样<br>例如: <code>实现/Implementation</code> 是基于 Minestom 开发的服务端软件, 而 <code>实例/Instance</code> 不只指对象.</p>\n</blockquote>\n<p>你很快就会发现你卡在登入中. 先别急着去 Issues 找骂, 看看日志怎么说:</p>\n<p><img src=\"https://i.ibb.co/q9xcpxY/image.png\" alt=\"Logs\"></p>\n<p><code>You need to specify a spawning instance in the PlayerLoginEvent</code> 嗯… 有意思.<br>如果想加入我们刚刚创建的新鲜 Minestom 实现, 我们首先要设置玩家加入的 <code>实例</code>. 那么, 实例是什么?</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><blockquote>\n<p>Instances are what replace “worlds” from Minecraft vanilla, those are lightweight and should offer similar properties. There are multiple instances implementation, currently InstanceContainer and SharedInstance (both are explained below)</p>\n<p>–<a href=\"https://wiki.minestom.net/world/instances\"><em>The Minestom Wiki</em></a></p>\n</blockquote>\n<p>简单的说, 在 Minestom 的世界里, <code>实例</code> 和我们先前在 Bukkit / Forge 上开发时的 <code>世界</code> 是相同的概念. 不同的是, 比起世界来说, 一个 <code>实例</code> 通常更加轻量一些.</p>\n<p>那么怎么创建实例呢? 你可能会发现你刚刚得到的 <code>MinecraftServer</code> 对象除了能监听端口什么都不会干, 这是因为 Minestom 的大部分功能…</p>\n<p><img src=\"https://i.ibb.co/kX4C16G/image.png\" alt=\"Method Complements\"></p>\n<p>都被 <code>MinecraftServer</code> 的静态方法包装起来了. 我觉得这样做的意图可能是模拟其他 JVM 语言上 “<code>object</code>“ 的做法, <code>object</code> 类型的 “类” 默认就是单例, 因此这种类的静态方法不复存, 所有的方法和字段实际上都直接指向那个单例.<br>虽然在 Java 的语境下这样的做法难免令人<del>我</del>感觉奇怪, 但是这毕竟不是重点.</p>\n<p>我们拿到 <code>InstanceManager</code>, 然后创建一个新的实例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">var</span> <span class=\"variable\">manager</span> <span class=\"operator\">=</span> MinecraftServer.getInstanceManager();</span><br><span class=\"line\"><span class=\"type\">var</span> <span class=\"variable\">instanceContainer</span> <span class=\"operator\">=</span> manager.createInstanceContainer();</span><br></pre></td></tr></table></figure>\n\n<p>噢! 不要忘记设置默认的 <code>世界生成器</code>, 不然你会一直掉下去虚空的.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instanceContainer.setGenerator(unit -&gt;</span><br><span class=\"line\">    unit.modifier().fillHeight(<span class=\"number\">0</span>,<span class=\"number\">1</span>, Block.GRASS_BLOCK));</span><br></pre></td></tr></table></figure>\n\n<p>然后要注册一个事件监听器, 用于告诉 Minestom 我们想让玩家出生在什么地方.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MinecraftServer.getGlobalEventHandler().addListener(PlayerLoginEvent.class, evt -&gt;&#123;</span><br><span class=\"line\">    evt.setSpawningInstance(instanceContainer);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>但是! 虽然现在已经可以进入服务器了, 我们会出生在 <code>(0,0,0)</code>, 然后无尽掉虚空.<br>所以, 还需要额外补几行防止这种情况.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MinecraftServer.getGlobalEventHandler().addListener(PlayerSpawnEvent.class, evt -&gt;&#123;</span><br><span class=\"line\">    evt.getPlayer().teleport(<span class=\"keyword\">new</span> <span class=\"title class_\">Pos</span>(<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>启动服务器, 进去将会发现一大片草方块.</p>\n<p>或者, 你也可以稍微更换一些参数…</p>\n<p><img src=\"https://i.ibb.co/8cBNXBT/image.png\" alt=\"莫名其妙的压迫感\"></p>\n<p>Minestom 生成世界的速度很快(可能是懒加载而已), 你几乎感受不到平时在 Notchian 服上最常见的世界生成卡顿. (可能是因为空 Minestom 处理的数据比较少, Minestom 就算直接加载 Minecraft 地图速度也是远超 Notchian.)<br>虽然 Minestom 支持直接加载 Anvil 格式的存档, 但是官方文档没有提到要怎么做.</p>\n<h3 id=\"加载-Anvil-格式的地图\"><a href=\"#加载-Anvil-格式的地图\" class=\"headerlink\" title=\"加载 Anvil 格式的地图\"></a>加载 Anvil 格式的地图</h3><blockquote>\n<p>注: 以下使用的主要 API 被官方标记为不稳定</p>\n</blockquote>\n<p>不难发现, <code>createInstanceContainer</code> 其实有支持传入 <code>IChunkLoader</code> 的重载方法. 只需要搜索片刻…</p>\n<p>你就能找到 <code>AnvilLoader</code>.</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    var manager = MinecraftServer.getInstanceManager();</span><br><span class=\"line\"><span class=\"deletion\">-   var instanceContainer = manager.createInstanceContainer();</span></span><br><span class=\"line\"><span class=\"addition\">+   var instanceContainer = manager.createInstanceContainer(new AnvilLoader(&quot;/path/to/A New World&quot;));</span></span><br><span class=\"line\"></span><br><span class=\"line\">    instanceContainer.setGenerator(unit -&gt;</span><br></pre></td></tr></table></figure>\n\n<p>只需要这样, 就可以加载你的 Minecraft 地图了.</p>\n<p><img src=\"https://i.ibb.co/5BR9Mtv/image.png\" alt=\"半秒以内就齐刷刷闪出来了!!\"></p>\n<h1 id=\"聊天与命令\"><a href=\"#聊天与命令\" class=\"headerlink\" title=\"聊天与命令\"></a>聊天与命令</h1><p>Minestom 似乎内置一个简单的聊天功能实现 (连聊天格式都和原版一样), 处理信息的方法应该和在 Bukkit 上的相差不大, 只不过 Minestom <strong>大量</strong>运用了 Kyori 的 <a href=\"https://docs.adventure.kyori.net/\">Adventure API</a><del>我有点反胃</del>. 写代码时最好留个心眼在返回值上.</p>\n<p><img src=\"https://i.ibb.co/VBkX8Xk/image.png\" alt=\"`getUsername` 才是正解\"></p>\n<p>所以比较想提一嘴的是命令, 毕竟其他教程也有<del>自古以来</del>从命令入手写功能的习俗.</p>\n<p>注册一个新的命令很简单:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">var</span> <span class=\"variable\">commandNew</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Command</span>(<span class=\"string\">&quot;new&quot;</span>);</span><br><span class=\"line\">commandNew.setDefaultExecutor((sender, context)-&gt;&#123;</span><br><span class=\"line\">    <span class=\"comment\">// your business logic...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">MinecraftServer.getCommandManager().register(commandNew);</span><br></pre></td></tr></table></figure>\n<p>接着你就可以在你的实现里用 <code>/new</code> 了, 正如你想象的那样运行. 这个命令框架看起来并不新奇, 笔者甚至觉得有些奇怪.</p>\n<p>不过, 上面给的例子只是为了你三行快速上手, 官方推崇的写法是这样的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo.commands;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> net.minestom.server.command.builder.Command;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCommand</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Command</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">TestCommand</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(<span class=\"string\">&quot;my-command&quot;</span>, <span class=\"string\">&quot;hey&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// &quot;my-command&quot; 是这个命令的主要名字.</span></span><br><span class=\"line\">        <span class=\"comment\">// &quot;hey&quot; 是命令的别名, 使用 /hey 和 /my-command 是一样的.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后一样的套路: <code>MinecraftServer.getCommandManager().register(new TestCommand())</code><br>接着是, 有参数的情况:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo.commands;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> net.minestom.server.command.builder.Command;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.minestom.server.command.builder.arguments.ArgumentType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCommand</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Command</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">TestCommand</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(<span class=\"string\">&quot;command&quot;</span>, <span class=\"string\">&quot;alias&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果没有匹配到其他 Executor 就回落到这上面.</span></span><br><span class=\"line\">        setDefaultExecutor((sender, context) -&gt; &#123;</span><br><span class=\"line\">            sender.sendMessage(<span class=\"string\">&quot;You executed the command&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 全部的默认参数类型都在 ArgumentType 类里</span></span><br><span class=\"line\">        <span class=\"comment\">// 这些静态工厂的参数是一些 `标识符`, 用于让程序分辨参数 (并且在 Minestom 内部用于创建节点)</span></span><br><span class=\"line\">        <span class=\"type\">var</span> <span class=\"variable\">numberArgument</span> <span class=\"operator\">=</span> ArgumentType.Integer(<span class=\"string\">&quot;my-number&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 最后, 定义指令的 语法. (Syntax)</span></span><br><span class=\"line\">        addSyntax((sender, context) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">number</span> <span class=\"operator\">=</span> context.get(numberArgument);</span><br><span class=\"line\">            sender.sendMessage(<span class=\"string\">&quot;You typed the number &quot;</span> + number);</span><br><span class=\"line\">        &#125;, numberArgument, ...more);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在埋头苦读上方源码之前, 不如看看官方文档是怎么解释的.</p>\n<blockquote>\n<p>All auto-completable commands should extend Command, each command is composed of zero or multiple syntaxes, and each syntax is composed of arguments</p>\n<p>If you find it confusing, here are a few examples:</p>\n<p><code>/health</code> 一条指令<br><code>/health set 50;</code> 一条指令和他的语法<br><code>set</code> 一小段字面量型的参数<br><code>~ ~ ~</code> 一<strong>个</strong>坐标参数</p>\n</blockquote>\n<p>一条命令由零个或多个 <code>语法</code> 构成, 每个 <code>语法</code> 又由一个或多个参数构成. 如果感到无法理解, 不如这样想:</p>\n<ul>\n<li>所谓的 <code>语法</code> 就是命令的一个基本样子.<br>比如: <code>/effect xxx give xxx</code> 是一条语法, 而 <code>/effect xxx give xxx 30 24</code> 因为后面多了两个参数就是一个新的语法.</li>\n<li>所以语法就规定了应该有哪些参数, 以及它们对应的类型.</li>\n</ul>\n<p> <img src=\"https://i.ibb.co/6bcw38v/image.png\" alt=\"上面命令补全回调触发的效果\"></p>\n<p>更多内容, 请转向 <a href=\"https://wiki.minestom.net/feature/commands\">官方文档 / Minestom Wiki</a></p>\n<h1 id=\"一些别的\"><a href=\"#一些别的\" class=\"headerlink\" title=\"一些别的\"></a>一些别的</h1><p>虽然它还是高度实验性的服务端, 但是它很有潜力一举代替 Spigot 成为支撑 RPG, 小游戏服务器的主流服务端, <del>这也说明这真的不怪Java, 别再说什么 C++ 重写性能翻3000%了</del> 因此, 现在开始学习如何使用是完全可取的, 因为本文所述的, 官方 Wiki 中包含的, 以及本身 API 架构不太可能再发生巨大变更.</p>\n<p>Minestom 不仅提供了一个更加模块化的 Minecraft 服务端事件, 而且也兼顾了性能和 API 的良好设计, 开放程度<a href=\"https://wiki.minestom.net/feature/map-rendering/glfwmaprendering\">远超 Spigot</a>. 但是在使用 Minestom 开发你的实现之前, 你要花更多精力在维持好程序的良好架构上, 不然就会 go die.<br><del>有人今天用minestom写东西写的一团糟我不说是谁</del> 所以, 我觉得如果不是很必要, 可以使用 Minestom 的 <a href=\"https://wiki.minestom.net/expansion/extensions\">扩展(插件)</a> API 和 <a href=\"https://wiki.minestom.net/expansion/scripting\">高度实验性的脚本</a> API.<br>这样做或许更加有利于 Minestom 的生态发展, 而最坏的情况就是大家都喜欢自己 hold 一个 Minestom, 谁也不服谁, 就好像那帮 Mod Loader 一样.<br>但是 Mod Loader 也各自多多少少有一些 Mod, 要是世界上光有 Mod Loader 没有 Mod 就真的成灾难了…</p>\n<h1 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h1><p>感谢你的观看, 欢迎在评论区留言.</p>\n",
            "tags": [
                "minecraft",
                "minestom",
                "guide"
            ]
        },
        {
            "id": "https://ib67.io/2022/07/06/Extending-Java-Compiler/",
            "url": "https://ib67.io/2022/07/06/Extending-Java-Compiler/",
            "title": "「9+」 Java 编译器插件教程 101",
            "date_published": "2022-07-06T11:25:58.000Z",
            "content_html": "<p>写了上万行 Java 代码，相比你已经对 Java “木纳呆板”的语法恨之入骨了。  </p>\n<p>那么，有没有一种可能，我是说可能，我们可以给 Java 编译器写插件？</p>\n<span id=\"more\"></span>\n\n<p>如果你要在面包店里买面包，你最好跟店员说你要买哪块面包。本文所指的 <code>Java 编译器</code> 均为 OpenJDK 自带的那个 <code>javac</code>，而不是其他的前端编译器实现。</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>自从 Java 8 起，Oracle 就将<a href=\"https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Plugin.html\">插件</a>系统引入了 <code>javac</code> 中，因此是可以写 Javac 插件的。</p>\n<p>虽然写一个 Javac 插件并且修改代码是可能的，但是这方面的资料很少（国内就更少了），并且大多内容重复（教你写个 HelloWorld 然后就结束），其次 javac 的东西也不是很好摸，毕竟不是公开 API（ JDK 9+ 开始已经不暴露在外了）。  </p>\n<p>恰逢今年还没写技术类的博客，就拿来磨磨刀吧。</p>\n<h1 id=\"先从插件说起\"><a href=\"#先从插件说起\" class=\"headerlink\" title=\"先从插件说起\"></a>先从插件说起</h1><p>上文刚刚提到了一个词，<code>插件</code>。它其实正是 <a href=\"https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Plugin.html\">com.sun.source.util.Plugin</a>。通过这个类，我们可以让 Javac 在编译时加载我们的代码。</p>\n<p>加载了代码，那么做什么呢？所以我们立一个目标：<em>给所有 <code>@Jsonized</code> 标注过的类都生成一个可以输出 json 的 <code>toString()</code> 方法。</em></p>\n<p>什么意思呢？就比如说这样一个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyResponse</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String message;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> success;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyResponse</span><span class=\"params\">(String message, <span class=\"type\">boolean</span> success)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.message = message;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.success = success;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后你想把它序列化成 Json。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">var</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyResponse</span>(<span class=\"string\">&quot;\\&quot;Success!\\&quot; Took me 114514 yr 1919810 m&quot;</span>,<span class=\"literal\">false</span>).toString();</span><br><span class=\"line\">response.equals(<span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;&quot;message&quot;: &quot;\\&quot;Success!\\&quot; Took me 114514 yr 1919810 m&quot;, &quot;success&quot;: false&#125;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>又快又便捷，还不需要第三方类库，这就是我们的目标。</p>\n<p>那么先把这个注解写出来吧！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.inlambda.kiwi.magic;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Classes with this type can be serialized to json by their &#123;<span class=\"doctag\">@link</span> #toString()&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Jsonized &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得提一点就是这些编译器注解的 <code>Retention</code> 用 <code>RetentionPolicy.SOURCE</code> 也是可以的，但是以后可能运行期间我们需要识别到这些被修改过的类，所以设置为 <code>RUNTIME</code>。</p>\n<p>接着是，实现 Javac 的 <code>Plugin</code> 接口！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.inlambda.kiwi.magic.plugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.util.Plugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">KiwiJavacPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Plugin</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Kiwi&quot;</span>; <span class=\"comment\">// 插件的名字</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(JavacTask task, String... args)</span> &#123; <span class=\"comment\">// 插件初始化回调</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello Kiwi&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是它不让你过编译。</p>\n<h2 id=\"打通模块的穴位\"><a href=\"#打通模块的穴位\" class=\"headerlink\" title=\"打通模块的穴位\"></a>打通模块的穴位</h2><p>这怎么能忍！在默认包目录下创建一个 <code>module-info.java</code>。  </p>\n<p><img src=\"https://i.ibb.co/JH5k9PV/image.png\" alt=\"Package Layout\"></p>\n<p>然后我们写点东西进去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> kiwi.magic.main &#123; <span class=\"comment\">// module 后跟模块名，下文要用</span></span><br><span class=\"line\">    <span class=\"keyword\">requires</span> jdk.internal.vm.compiler;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> jdk.compiler;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> java.naming;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加入这些之后，还要配置一下构建工具的编译参数。</p>\n<p>（本教程使用 Gradle, Maven/SBT 用户请自行摸索….）</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compileJava &#123;</span><br><span class=\"line\">    options.compilerArgs &lt;&lt; <span class=\"string\">&quot;--add-exports=jdk.compiler/com.sun.tools.javac.tree=kiwi.magic.main&quot;</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;--add-exports=jdk.compiler/com.sun.tools.javac.code=kiwi.magic.main&quot;</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;--add-exports=jdk.compiler/com.sun.tools.javac.util=kiwi.magic.main&quot;</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;--add-exports=jdk.compiler/com.sun.tools.javac.api=kiwi.magic.main&quot;</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;--add-exports=jdk.compiler/com.sun.tools.javac.processing=kiwi.magic.main&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就能过编译了！虽然 IDEA 仍然会划出红线，但是只要接受他的解决方案就好（形如 <code>add XX to compiler option</code>）</p>\n<blockquote>\n<p>由于 IDEA 可能不会自动补全没有确定模块关系的类，教程可能会大量使用完整的类名或是指向 Java SE 8 Documentation 的引用链接。</p>\n</blockquote>\n<h2 id=\"配置-Service\"><a href=\"#配置-Service\" class=\"headerlink\" title=\"配置 Service\"></a>配置 Service</h2><p>Javac 通过 <a href=\"https://www.baeldung.com/java-spi\">Java SPI</a> 发现插件，因此你需要写一个 Service 文件让他能够发现你。</p>\n<p>在 <code>src/main/resource/META-INF/services/com.source.util.Plugin</code> 中写出：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># 填写你的插件主类名，这是教程的例子。</span></span><br><span class=\"line\">org.inlambda.kiwi.magic.plugin.KiwiJavacPlugin</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.ibb.co/zbHD9vS/image.png\" alt=\"File Location\"></p>\n<p>但是还差一步。</p>\n<h2 id=\"加载插件\"><a href=\"#加载插件\" class=\"headerlink\" title=\"加载插件\"></a>加载插件</h2><p>Javac 也是一个 Java 程序，他是在他的运行时 classpath 里面寻找插件的。  </p>\n<p>而在 Gradle 中，<code>annotationProcessor</code> 就会被加入到编译器的 classpath 中。但我们不能用 <code>annotationProcessor this</code> ，因为 gradle 不允许，所以我们需要另外新建一个模块专门测试插件。</p>\n<p><img src=\"https://i.ibb.co/Cs4fckp/image.png\" alt=\"Module Layout\"></p>\n<p>为了加载插件，应当确保 <code>build.gradle</code> 中有如下内容：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    testImplementation <span class=\"string\">&#x27;org.junit.jupiter:junit-jupiter-api:5.8.1&#x27;</span></span><br><span class=\"line\">    testRuntimeOnly <span class=\"string\">&#x27;org.junit.jupiter:junit-jupiter-engine:5.8.1&#x27;</span></span><br><span class=\"line\">    compileOnly(project(<span class=\"string\">&quot;:magic&quot;</span>))</span><br><span class=\"line\">    annotationProcessor(project(<span class=\"string\">&quot;:magic&quot;</span>)) <span class=\"comment\">// 就是这个！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">compileJava &#123; options.compilerArgs &lt;&lt; <span class=\"string\">&#x27;-Xplugin:Kiwi&#x27;</span> &#125; <span class=\"comment\">// Kiwi 是插件的名字</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>万事具备，开 <code>assemble</code> ！</p>\n<p><img src=\"https://i.ibb.co/VpfMFc4/image.png\" alt=\"Gradle Assemble Output\"></p>\n<p>现在，我们已经让 Javac 加载了我们的代码，但这仅仅是个开始。为了实现 <code>@Jsonized</code> 的目标，我们还需要注入代码。</p>\n<h1 id=\"得到编译单元\"><a href=\"#得到编译单元\" class=\"headerlink\" title=\"得到编译单元\"></a>得到编译单元</h1><p>对 AST 下手，首先要拿到 <a href=\"https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/tree/CompilationUnitTree.html\">CompilationUnit</a></p>\n<p>而 Javac 通过 <a href=\"https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/TaskEvent.html\">TaskEvent</a> 将它传递给我们，因此我们要注册一个 <code>com.sun.source.util.TaskListener</code> 来收 <code>TaskEvent</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(JavacTask task, String... args)</span> &#123; <span class=\"comment\">// 插件初始化回调</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello Kiwi&quot;</span>);</span><br><span class=\"line\">    task.addTaskListener(<span class=\"keyword\">new</span> <span class=\"title class_\">KiwiTaskListener</span>(((BasicJavacTask) task).getContext()); <span class=\"comment\">// this!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>KiwiTaskListener</code>: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.inlambda.kiwi.magic.plugin.jc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.util.TaskEvent;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.util.TaskListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Context;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">KiwiTaskListener</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">TaskListener</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Context context;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">KiwiTaskListener</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.context = context;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">started</span><span class=\"params\">(TaskEvent e)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">finished</span><span class=\"params\">(TaskEvent e)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.getKind() != TaskEvent.Kind.PARSE) &#123; <span class=\"comment\">// 注意此处</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">var</span> <span class=\"variable\">compUnit</span> <span class=\"operator\">=</span> e.getCompilationUnit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>编译流程:<br>Java 编译器的几个阶段:</p>\n<ul>\n<li>COMPILATION</li>\n<li>PARSE – 构造抽象语法树 (AST)</li>\n<li>ENTER – 源码里的引用均已被解析</li>\n<li>ANALYZE – 生成 AST 并用于分析错误</li>\n<li>GENERATE – 为源码生成输出 (.class)</li>\n<li>ANNOTATION_PROCESSING - 注解处理器被唤起</li>\n<li>ANNOTATION_PROCESSING_ROUND</li>\n<li>COMPILATION</li>\n</ul>\n<p>因为我们的目标是修改代码（对编译器来说，也就是对抽象语法树下手），所以只需要关心 PARSE 阶段就好了。<br>如果你对 “AST” 和 “PARSE” 的概念还不太了解，那么你可以先看看我的<a href=\"./Writting-A-Compiler-1.md\">另一篇博客</a></p>\n</blockquote>\n<h2 id=\"获取-AST\"><a href=\"#获取-AST\" class=\"headerlink\" title=\"获取 AST\"></a>获取 AST</h2><p>得到 <code>CompilationUnit</code> 后，我们便可以<a href=\"https://refactoringguru.cn/design-patterns/visitor\">“访问”</a>到对应的 <code>class</code> 了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.inlambda.kiwi.magic.plugin.jc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.tree.ClassTree;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.util.TreeScanner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.tree.JCTree; <span class=\"comment\">//注意这些完整类名，如果你的 IDEA 补全不了尝试复制这些到 IDEA 里面去。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.tree.TreeMaker; </span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Names;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.inlambda.kiwi.magic.plugin.gens.GenJsonToString;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JsonizedTreeScanner</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">TreeScanner</span>&lt;Void, Context&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Void <span class=\"title function_\">visitClass</span><span class=\"params\">(ClassTree node, Context ctx)</span> &#123; <span class=\"comment\">// 此处 Context 是类型参数里规定的</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">var</span> <span class=\"variable\">maker</span> <span class=\"operator\">=</span> TreeMaker.instance(ctx); <span class=\"comment\">// 1</span></span><br><span class=\"line\">            <span class=\"type\">var</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> Names.instance(ctx); <span class=\"comment\">// 2</span></span><br><span class=\"line\">            <span class=\"type\">var</span> <span class=\"variable\">claz</span> <span class=\"operator\">=</span> (JCTree.JCClassDecl) node; <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.getModifiers()</span><br><span class=\"line\">                .getAnnotations()</span><br><span class=\"line\">                .stream()</span><br><span class=\"line\">                .anyMatch(e -&gt;</span><br><span class=\"line\">                    e.getAnnotationType()</span><br><span class=\"line\">                        .toString()</span><br><span class=\"line\">                        .equals(<span class=\"string\">&quot;Jsonized&quot;</span>))) &#123; <span class=\"comment\">// 判断是否有 Jsonized</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Jsonized class found: &quot;</span> + node.getSimpleName());</span><br><span class=\"line\">                <span class=\"built_in\">super</span>.visitClass(node, ctx);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            System.err.println(t.getMessage());</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (StackTraceElement stackTraceElement : t.getStackTrace()) &#123;</span><br><span class=\"line\">                System.out.println(stackTraceElement); </span><br><span class=\"line\">                <span class=\"comment\">// Javac 会屏蔽掉正常的报错输出，因此需要手动打印出来。</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.visitClass(node, ctx);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来逐个讲解这些代码。</p>\n<ol>\n<li><p><strong>TreeMaker</strong> 是一个非常重要的组件，通过 <code>TreeMaker</code> 我们可以创建语法树的组件然后把它们插入到现有的语法树里，也就是修改代码。</p>\n</li>\n<li><p><strong>Names</strong> 也是一个重要组件，因为它几乎就是符号表，虽然其本身是 <code>Identifier</code> ….。</p>\n</li>\n<li><p><code>JCTree.JCClassDecl</code> 就是类在AST中的定义，我们接下来会讲解到它以及更多 <code>JCTree</code> 子类的应用。</p>\n</li>\n</ol>\n<p>同时，我们在 <code>magic-test</code> 模块中创建一个类用于测试 <code>@Jsonized</code>，但为了节约篇幅，类的代码不列出。</p>\n<p>让我们的访客访问 <code>CompilationUnit</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">finished</span><span class=\"params\">(TaskEvent e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.getKind() != TaskEvent.Kind.PARSE) &#123; <span class=\"comment\">// 注意此处</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">compUnit</span> <span class=\"operator\">=</span> e.getCompilationUnit();</span><br><span class=\"line\">    compUnit.accept(<span class=\"keyword\">new</span> <span class=\"title class_\">JsonizedTreeScanner</span>(), context); <span class=\"comment\">// 此处 context 是上文类构造器依赖注入进来的</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>尝试编译 <code>magic-test</code>，你应当能在 <code>compileJava</code> 阶段看到 <code>Jsonized class found: XXX</code>。</p>\n<h1 id=\"对-AST-动手动脚\"><a href=\"#对-AST-动手动脚\" class=\"headerlink\" title=\"对 AST 动手动脚\"></a>对 AST 动手动脚</h1><p><em>哎呀，你怎么动手动脚的！</em>  </p>\n<p>拿到了类定义，我们就可以访问类里的所有元素了！另外，<code>JCTree</code> 的子类通常是可以<em>直接 toString()</em> 出来的，你可以利用这一点查看编译的输出。</p>\n<p>但在修改之前，得先了解一下 Javac 内部的 List 实现。</p>\n<h2 id=\"List-in-Javac\"><a href=\"#List-in-Javac\" class=\"headerlink\" title=\"List in Javac\"></a>List in Javac</h2><p>Javac 不知道出于什么缘故，他自己有一个链表（<code>com.sun.tools.javac.util.List&lt;A&gt;</code>）的实现，而且他是不可变的。</p>\n<p>这个链表不对外公开（因为 Oracle 官方网站也没有 Javadoc），所以不提供引用链接了。</p>\n<p>此处介绍几个常用的方法。</p>\n<ul>\n<li><p>List.nil()<br>静态方法。顾名思义，空集。</p>\n</li>\n<li><p>List.of(A x1, A x2, A x3, A… rest)<br>一个静态工厂，用于创建一个定长的 List.</p>\n</li>\n<li><p>一些类似 <code>prepend</code> 和 <code>append</code> 这样对元素操作的方法…<br>他们都返回新的实例，因为 <code>List&lt;A&gt;</code> 是不可变的，小心别被坑了。</p>\n</li>\n</ul>\n<p>等等，那不定长的呢？于是我们还有一个类，他就是 <code>com.sun.tools.javac.util.ListBuffer&lt;A&gt;</code>。</p>\n<p><code>ListBuffer&lt;A&gt;</code> 是 <code>List&lt;A&gt;</code> 某种类似 <a href=\"https://refactoringguru.cn/design-patterns/builder\">Builder</a> 的工具，他的 <code>append</code> 等方法始终返回他自己，用完之后可以 <code>toList()</code> 转换成 <code>List&lt;A&gt;</code>。</p>\n<p>做好这些基础知识的准备工作，我们终于，终于，终于可以开始动工了。</p>\n<h2 id=\"访问类里的元素\"><a href=\"#访问类里的元素\" class=\"headerlink\" title=\"访问类里的元素\"></a>访问类里的元素</h2><p><img src=\"https://i.ibb.co/ZGJ4Gts/image.png\" alt=\"Methods of JCClassDecl\"></p>\n<p><code>JCClassDecl</code> 并没有严格区分开来方法和字段，他们都是 <code>member</code>。然而 <code>getMembers()</code> 是只读的（因为 <code>List&lt;A&gt;</code> 不可变），所以我们要绕开 <code>getMembers()</code> 直接访问到后面的字段。</p>\n<p>绕也很简单…</p>\n<p><img src=\"https://i.ibb.co/vk3yMcv/image.png\" alt=\"field defs\"></p>\n<p>没想到吧，Javac 里面就是这么乱。</p>\n<p>接下来往 <code>defs</code> 里面插入方法即可。</p>\n<h2 id=\"构造方法然后插进去！\"><a href=\"#构造方法然后插进去！\" class=\"headerlink\" title=\"构造方法然后插进去！\"></a>构造方法然后插进去！</h2><p>这里我们就要请出刚刚提到过的大名鼎鼎的 <code>TreeMaker</code> 了！ 方法定义在 Javac 中就是 <code>com.sun.tools.javac.tree.JCTree.MethodDecl</code>，可以通过 <code>TreeMaker#MethodDef</code> 构造。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 建议把生成方法单独放起来</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> JCTree.JCMethodDecl <span class=\"title function_\">genMethod</span><span class=\"params\">(TreeMaker maker, Names symbolTable, JCTree.JCClassDecl claz)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> maker.at(claz.pos).MethodDef( <span class=\"comment\">// 1</span></span><br><span class=\"line\">            maker.Modifiers(Flags.PUBLIC | Flags.FINAL), <span class=\"comment\">// 方法的修饰符</span></span><br><span class=\"line\">            symbolTable.fromString(<span class=\"string\">&quot;toString&quot;</span>), <span class=\"comment\">// 2 方法的名称</span></span><br><span class=\"line\">            maker.Ident(symbolTable.fromString(<span class=\"string\">&quot;String&quot;</span>)), <span class=\"comment\">// 3 返回值类型</span></span><br><span class=\"line\">            List.nil(),</span><br><span class=\"line\">            List.nil(), <span class=\"comment\">// 这三个先忽略再说</span></span><br><span class=\"line\">            List.nil(),</span><br><span class=\"line\">            maker.Block(<span class=\"number\">0</span>, makeReturnJsonExpress(maker, symbolTable, claz)) <span class=\"comment\">// 方法体</span></span><br><span class=\"line\">            , <span class=\"literal\">null</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> method;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是不是有些迷糊？我们”娓娓道来”…</p>\n<ol>\n<li><code>at(claz.pos).MethodDef(</code><br> 这句的意思是把 <code>TreeMaker</code> 当前的位置调整到目标类上然后再创建一个方法定义，不然可能会把方法生成到别的地方。（不过我没试过，其实方法和类关系是比较确定的，所以这个 <code>pos</code> 可能是给语句用的，因为语句有顺序。）</li>\n<li><code>symbolTable.fromString(&quot;toString&quot;)</code><br> <code>Names</code> 提供了 <code>fromString</code> 方法用来创建对应的标识符/名字（Identifier）。</li>\n<li><code>maker.Ident</code><br> <code>Ident</code> 是一个很常用的方法，他可以接受一个 <code>Names</code> 然后输出一个 <code>JCIdent</code>。<br> 而 <code>JCIdent</code> 恰好是 <code>JCExpression</code>，也就是 <code>JCTree</code> 的子类。</li>\n</ol>\n<p>注意，从符号表拿类型并不需要把命名写完整（就好像上文写的不是 java.lang.String），如果要引入外部的类型只需要 <code>maker.Import</code> 即可</p>\n<blockquote>\n<p>例如：<code>maker.Import(maker.Ident(names.fromString(&quot;java.util.Objects&quot;)).getTree(), false);</code></p>\n</blockquote>\n<p>这还只是方法的基本信息，接下来是方法体，也就是最关键的那部分。</p>\n<p>但在写输出 Json 之前，我们不妨先写个 <code>HelloWorld</code> 试试。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;JCTree.JCStatement&gt; makeReturnJsonExpress(TreeMaker maker, Names name, JCTree.JCClassDecl claz) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> List.of(maker.Return(maker.Literal(<span class=\"string\">&quot;Hello Jsonized!&quot;</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们回到上文，把新的方法体插入到类里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">claz</span> <span class=\"operator\">=</span> (JCTree.JCClassDecl) node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.getModifiers().getAnnotations().stream().anyMatch(e -&gt; e.getAnnotationType().toString().equals(<span class=\"string\">&quot;Jsonized&quot;</span>))) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Jsonized class found: &quot;</span> + node.getSimpleName());</span><br><span class=\"line\">        claz.def = claz.def.append(genMethod(maker,name,claz)); <span class=\"comment\">// THIS</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>.visitClass(node, ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">    System.err.println(t.getMessage());</span><br></pre></td></tr></table></figure>\n\n<p>尝试编译 <code>magic-test</code> 模块并且查看编译输出，如果你没有干坏事的话应该能看到 <code>@Jsonized</code> 标注过的类里多出来一个 <code>public final String toString()</code>，并且代码体正是 <code>return &quot;Hello Jsonized!&quot;;</code>。</p>\n<p><img src=\"https://i.ibb.co/Rjqrbwh/image.png\" alt=\"Decompiler Output\"><br><em>(由于我的 Jsonized 用的是 <code>RetentionPolicy.SOURCE</code>，所以注解编译后就被抹除掉了)</em></p>\n<h1 id=\"AST-的常用姿势\"><a href=\"#AST-的常用姿势\" class=\"headerlink\" title=\"AST 的常用姿势\"></a>AST 的常用姿势</h1><p>到上一节，你已经成功的：</p>\n<ul>\n<li>让 Javac 加载你的代码</li>\n<li>对特定注解标志过的类添加代码</li>\n</ul>\n<p>那么这一节，我们着重讲解一些常用的操作以及更多基础知识。</p>\n<h2 id=\"从获取字段开始\"><a href=\"#从获取字段开始\" class=\"headerlink\" title=\"从获取字段开始\"></a>从获取字段开始</h2><p>为了序列化出所有字段，我们首先需要知道我们的类里有哪些字段。</p>\n<p>幸好，使用 <code>Stream</code> 就可以很轻松地做到这件事:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">var</span> <span class=\"variable\">nameToVar</span> <span class=\"operator\">=</span> claz.getMembers().stream()</span><br><span class=\"line\">    .filter(e -&gt; e.getKind() == Tree.Kind.VARIABLE) <span class=\"comment\">// 其实这个可能可以省略</span></span><br><span class=\"line\">    .filter(e -&gt; e <span class=\"keyword\">instanceof</span> JCTree.JCVariableDecl)</span><br><span class=\"line\">    .map(e -&gt; (JCTree.JCVariableDecl) e)</span><br><span class=\"line\">    .collect(Collectors.toMap(e -&gt; e.getName(), e -&gt; e.getType()));</span><br></pre></td></tr></table></figure>\n\n<p>产出一个 <code>Map&lt;Names, JCTree&gt;</code>。<code>JCTree</code> 就是类定义，此处为 <code>JCVariableDecl</code></p>\n<p>有了这样一个 nameToVar 之后，我们就可以构造 Json 了。</p>\n<h2 id=\"拼接字符串与二元表达式\"><a href=\"#拼接字符串与二元表达式\" class=\"headerlink\" title=\"拼接字符串与二元表达式\"></a>拼接字符串与二元表达式</h2><p><em>哪个男孩不想体验一下二元运算符呢？</em></p>\n<p><img src=\"https://i.ibb.co/gSj670J/image.png\" alt=\"Figure: Binary Operator\"></p>\n<p>“+” 是一个二元运算符，它接受两个参数: <code>a</code> 和 <code>b</code> 并且产出一个结果。</p>\n<p>在 Java 里，我们是这样写的：<code>a + b</code></p>\n<p>那么如果更多参数呢？</p>\n<p><img src=\"https://i.ibb.co/RDdyC40/image.png\" alt=\"Figure: Complexier Binary Tree\"></p>\n<p>以此类推，可以构造出一个很长很长的二元树，而这正好是我们今天要做的事情。  </p>\n<hr>\n<p>先从拼接字符串开始，举个例子：<code>a + &quot;literal&quot;</code></p>\n<p>如果我们要让一个命名 <code>a</code> 和一个字面量（<code>&quot;literal&quot;</code>）相加，要怎么做呢？其实很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JCTree.<span class=\"type\">JCBinary</span> <span class=\"variable\">binary</span> <span class=\"operator\">=</span> maker.Binary(</span><br><span class=\"line\">    JCTree.Tag.PLUS,</span><br><span class=\"line\">     maker.Ident(names.fromString(<span class=\"string\">&quot;a&quot;</span>)),</span><br><span class=\"line\">      maker.Literal(<span class=\"string\">&quot;literal&quot;</span>)); <span class=\"comment\">// 此处 PLUS 为运算符 &quot;+&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.ibb.co/6g320J4/image.png\" alt=\"Figure: Explaination of Java Code\"></p>\n<p>回过头来，我们拼接 Json 的代码应该是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&#123;\\&quot;success\\&quot;:&quot;</span>+ success +<span class=\"string\">&quot;,\\&quot;response\\&quot;:+&quot;</span> response <span class=\"string\">&quot;+&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>也就是:</p>\n<p><img src=\"https://i.ibb.co/drS5xr3/image.png\" alt=\"Figure: Example of Json Concatenating\"></p>\n<p>不难看出，到最后这些拼接代码都会被聚合成一个 <code>JCBinary</code>。通过这个性质，我们可以使用 <code>Stream#reduce</code> 来把众多元素聚合成一个 <code>JCBinary</code>。</p>\n<p>此处贴出完整的 <code>makeReturnJsonExpress</code> 以供参考。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;JCTree.JCStatement&gt; makeReturnJsonExpress(TreeMaker maker, Names name, JCTree.JCClassDecl claz) &#123;</span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> claz.getMembers().stream()</span><br><span class=\"line\">        .filter(e -&gt; e.getKind() == Tree.Kind.VARIABLE)</span><br><span class=\"line\">        .filter(e -&gt; e <span class=\"keyword\">instanceof</span> JCTree.JCVariableDecl)</span><br><span class=\"line\">        .map(e -&gt; (JCTree.JCVariableDecl) e)</span><br><span class=\"line\">        .collect(Collectors.toMap(e -&gt; e.getName(), e -&gt; e.getType()));</span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> json.entrySet().stream()</span><br><span class=\"line\">            .map(e -&gt; </span><br><span class=\"line\">            maker.Binary(JCTree.Tag.PLUS, </span><br><span class=\"line\">                maker.Literal(<span class=\"string\">&quot;\\&quot;&quot;</span> + e.getKey() + <span class=\"string\">&quot;\\&quot;:&quot;</span>),</span><br><span class=\"line\">                maker.Ident(e.getKey()) <span class=\"comment\">// 引用字段名</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">            ).reduce((e1, e2) -&gt; </span><br><span class=\"line\">                maker.Binary(</span><br><span class=\"line\">                    JCTree.Tag.PLUS, </span><br><span class=\"line\">                    e1, </span><br><span class=\"line\">                    maker.Binary(</span><br><span class=\"line\">                        JCTree.Tag.PLUS, </span><br><span class=\"line\">                        maker.Literal(<span class=\"string\">&quot;,&quot;</span>),</span><br><span class=\"line\">                        e2)</span><br><span class=\"line\">            ))</span><br><span class=\"line\">            .orElseThrow();</span><br><span class=\"line\">    list = maker.Binary(JCTree.Tag.PLUS, maker.Literal(<span class=\"string\">&quot;&#123;&quot;</span>), list);</span><br><span class=\"line\">    list = maker.Binary(JCTree.Tag.PLUS, list, maker.Literal(<span class=\"string\">&quot;&#125;&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> List.of(maker.Return(</span><br><span class=\"line\">            list</span><br><span class=\"line\">    ));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们的 <code>@Jsonized</code> 生成的 <code>toString</code> 已经可以处理简单情况了。</p>\n<h2 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h2><p>但是游戏还没结束，你很快会发现一个问题…. 如果数据里存有特殊字符，例如 <code>&quot;</code> 那就出事了！因此，要给字符串加一些特殊处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&#123;\\&quot;success\\&quot;:&quot;</span>+ success +<span class=\"string\">&quot;,\\&quot;response\\&quot;:+&quot;</span> response.replaceAll(<span class=\"string\">&quot;\\\\\\&quot;&quot;</span>,<span class=\"string\">&quot;\\\\\\\\\\&quot;&quot;</span>) <span class=\"string\">&quot;+&#125;&quot;</span> <span class=\"comment\">// 拼接的时候把 &quot; 替换为 \\&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>也就是说，我们要对 <code>response</code> 进行方法调用。那么，先引入一个新方法吧！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> JCTree.JCExpression <span class=\"title function_\">processValue</span><span class=\"params\">(JCTree value, Name name, TreeMaker maker, Names names)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">typeName</span> <span class=\"operator\">=</span> value.toString();</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (typeName) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;String&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;CharSequence&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;StringBuilder&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;StringBuffer&quot;</span>: <span class=\"comment\">// 一切可以 toString 的...</span></span><br><span class=\"line\">            <span class=\"type\">var</span> <span class=\"variable\">toS</span> <span class=\"operator\">=</span> maker.Exec(maker.Apply(</span><br><span class=\"line\">                    List.nil(),</span><br><span class=\"line\">                    maker.Select(</span><br><span class=\"line\">                            maker.Ident(name),</span><br><span class=\"line\">                            names.fromString(<span class=\"string\">&quot;toString&quot;</span>)</span><br><span class=\"line\">                    ),</span><br><span class=\"line\">                    List.nil()</span><br><span class=\"line\">            )); <span class=\"comment\">// toS: name.toString()</span></span><br><span class=\"line\">            <span class=\"type\">var</span> <span class=\"variable\">replaced</span> <span class=\"operator\">=</span> maker.Exec( <span class=\"comment\">// 1</span></span><br><span class=\"line\">                    maker.Apply( <span class=\"comment\">// 2</span></span><br><span class=\"line\">                            List.nil(), <span class=\"comment\">// 类型参数，就是方法的泛型，不多过关心</span></span><br><span class=\"line\">                            maker.Select( <span class=\"comment\">// 3</span></span><br><span class=\"line\">                                    toS.expr,</span><br><span class=\"line\">                                    names.fromString(<span class=\"string\">&quot;replaceAll&quot;</span>)</span><br><span class=\"line\">                            ),</span><br><span class=\"line\">                            List.of( <span class=\"comment\">// 方法参数</span></span><br><span class=\"line\">                                    maker.Literal(<span class=\"string\">&quot;\\\\\\&quot;&quot;</span>),</span><br><span class=\"line\">                                    maker.Literal(<span class=\"string\">&quot;\\\\\\\\\\&quot;&quot;</span>)</span><br><span class=\"line\">                            )</span><br><span class=\"line\">                    )</span><br><span class=\"line\">            ); <span class=\"comment\">// replaced: name.toString().replaceAll(...)</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> maker.Binary(JCTree.Tag.PLUS, maker.Literal(<span class=\"string\">&quot;\\&quot;&quot;</span>),</span><br><span class=\"line\">                    maker.Binary(JCTree.Tag.PLUS, replaced.expr, maker.Literal(<span class=\"string\">&quot;\\&quot;&quot;</span>)));</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> maker.Ident(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>写这篇博文的时候我还没有去深究具体要怎么获取到 <code>JCVariable</code> 的类型关系，所以只有这么蠢的方法。</p>\n</blockquote>\n<p>还是老样子，逐步解释代码：</p>\n<ol>\n<li><code>Exec</code> 执行的意思，这里可以传入一个 <code>JCExpression</code></li>\n<li><code>Apply</code> 返回一个 <code>JCMethodInvocation</code>，正是我们要的东西</li>\n<li><code>Select</code> 返回一个 <code>JCFieldAccess</code>，而参数是发起操作的对象和他对应的方法/字段（瞎猜的）<br>当然这里你也可以用 <code>maker.Ident(name)</code> 来代替 <code>Select</code>，也就是直接对 name 对应的对象发起动作。</li>\n</ol>\n<p>之后再修改一下之前的代码：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                .map(e -&gt; </span><br><span class=\"line\">                maker.Binary(JCTree.Tag.PLUS, </span><br><span class=\"line\">                    maker.Literal(&quot;\\&quot;&quot; + e.getKey() + &quot;\\&quot;:&quot;),</span><br><span class=\"line\"><span class=\"deletion\">-                   maker.Ident(e.getKey()) // 引用字段名</span></span><br><span class=\"line\"><span class=\"addition\">+                   processValue(e.getValue(), e.getKey(), maker, name)</span></span><br><span class=\"line\">                )</span><br><span class=\"line\">                ).reduce((e1, e2) -&gt; </span><br></pre></td></tr></table></figure>\n\n<p><em>大功告成。现在你已经得到了一个可以处理 <code>String/CharSequence/StringBuilder/StringBuffer</code> 里的转义问题（当然，只限于双引号）的编译期序列化 Json 的编译器插件了！</em></p>\n<blockquote>\n<p>一种更好的做法: 委托<br>与其这样大费周章的在编译器完成这些工作，倒不如再带几个类进去然后委托到类上的静态方法进行转换。<br>这样做的好处有很多，例如无需重新编译这些 <code>class</code> , 例如可以通过代码编写更灵活的转换机制… 等等。实际上，Java 14+ 中 Record 的 <code>equals</code> 正是通过 <code>INVOKEDYNAMIC</code> 委托到别处比较实现的，并且高版本 Java 中 String 类型的拼接也使用了委托。</p>\n</blockquote>\n<h1 id=\"附：使用注解处理器\"><a href=\"#附：使用注解处理器\" class=\"headerlink\" title=\"附：使用注解处理器\"></a>附：使用注解处理器</h1><p>除了直接编写 Javac 插件，我们还有另外一种做法，就是 <code>Annotation Processor</code>，注解处理器。</p>\n<p>比起 Javac 插件，它的局限较高，但是用起来会方便一点<del>因为不用加那个”-Xplugin”的编译器 参数</del></p>\n<p>所以这里简单介绍一下如何使用注解处理器访问 AST。类似 <code>Plugin</code>，你需要先继承一个 <code>AbstractProcessor</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.inlambda.kiwi.magic.plugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.util.Trees;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.tree.JCTree;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.tree.TreeMaker;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Names;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.inlambda.kiwi.magic.Jsonized;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.inlambda.kiwi.magic.NoNullExcepted;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.inlambda.kiwi.magic.plugin.gens.GenJsonToString;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.inlambda.kiwi.magic.plugin.gens.GenNoNull;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.processing.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.lang.model.SourceVersion;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.lang.model.element.Element;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.lang.model.element.TypeElement;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SupportedAnnotationTypes(&quot;*&quot;)</span> <span class=\"comment\">// 表示处理任意元素</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedSourceVersion(SourceVersion.RELEASE_11)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">KiwiAnnotationProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractProcessor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Context context;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Trees trees; <span class=\"comment\">// 注意这里还有个 Trees</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeMaker maker;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Names names;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(ProcessingEnvironment processingEnv)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.init(processingEnv);</span><br><span class=\"line\">        trees = Trees.instance(processingEnv);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">var</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> processingEnv.getClass().getDeclaredField(<span class=\"string\">&quot;context&quot;</span>); <span class=\"comment\">// 得到 context</span></span><br><span class=\"line\">            f.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            context = (Context) f.get(processingEnv);</span><br><span class=\"line\">            maker = TreeMaker.instance(context);</span><br><span class=\"line\">            names = Names.instance(context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后一样在 <code>META-INF/services/javax.annotation.processing.Processor</code> 里写上你的类名，注意是 <code>Processor</code> 而不是 <code>AbstractProcessor</code> …</p>\n<p>拿到 <code>TreeMaker</code>, <code>Context</code>，<code>Trees</code> 和 <code>Names</code> 之后就好办很多了，接下来的问题是怎么获取到 AST。</p>\n<p>好在 Annotation Processor API 允许我们处理所有元素而不只是规定的几个注解标注过的元素，我们可以在 <code>boolean process(...)</code> 方法中访问到所有我们要的元素（前提是 <code>@SupportedAnnotationTypes(&quot;*&quot;)</code> ）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TypeElement annotation : annotations) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotation.getQualifiedName().contentEquals(Jsonized.class.getName())) &#123; <span class=\"comment\">// 先判断这个注解是不是我们的</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Element element : roundEnv.getElementsAnnotatedWith(annotation)) &#123; </span><br><span class=\"line\">                <span class=\"comment\">//接着可以拿到注解标注过的所有元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 因为我们的注解 Target 是 TYPE，所以只能在类上。这里直接强转成 JCClassDecl 即可。</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 通过 Trees 得到它对应的 AST 元素。这里的 element 实际上是个 ClassSymbol</span></span><br><span class=\"line\">                <span class=\"type\">var</span> <span class=\"variable\">jtree</span> <span class=\"operator\">=</span> (JCTree.JCClassDecl) trees.getTree(element);</span><br><span class=\"line\">                <span class=\"type\">var</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> GenJsonToString.genMethod(maker, names, jtree); <span class=\"comment\">// 似曾相似的套路，这就是我什么推荐你单独放....</span></span><br><span class=\"line\">                jtree.defs = jtree.defs.append(method);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>That’s it!</em> 其实这种需求用注解处理器的话似乎比直接写 Javac 插件还要简单一些？</p>\n<blockquote>\n<p>注意: 注解处理器不能和 javac 插件混着用，而且在 gradle 中，他们似乎是在不同的环境里被加载的。（也就是你无法通过静态字段传递加载信息来判断用户想用的是插件还是注解处理器）</p>\n</blockquote>\n<h1 id=\"End-结语\"><a href=\"#End-结语\" class=\"headerlink\" title=\"End / 结语\"></a>End / 结语</h1><p>本文简要介绍了 javac 闭包 API 的基本使用以及一种使用注解处理器访问 javac AST 的方法。</p>\n<p>不过需要注意的是，虽然这些 API 自从 1.8 加入以来就没怎么变过（应该？），他们仍然是<strong>不稳定，不安全，无保障</strong>的。因此，若要使用，请总是进行单元测试并且尝试检查版本兼容性。</p>\n<p>本篇博客的所有代码均为 <a href=\"https://codeberg.org/InlinedLambdas/Kiwi\">Kiwi</a> 项目的一部分，Kiwi 以 MIT 协议开源，如果你想 Star 但是没有 Codeberg 帐号的话可以去 GitHub 上的<a href=\"https://github.com/InlinedLambdas/kiwi\">镜像</a> (疯狂暗示)</p>\n<p>文章可能有偏差，可以在评论区指正。</p>\n<p>End.</p>\n<hr>\n<p>Credits:</p>\n<p><a href=\"https://stackoverflow.com/questions/46773519/accessing-com-sun-tools-javac-util-from-java-9\">StackoverFlow - Accessing com.sun.tools.javac.util from Java 9</a><br><a href=\"https://www.baeldung.com/java-annotation-processing-builder\">Baeldung - Java Annotation Processing and create a builder</a><br><a href=\"https://www.baeldung.com/java-build-compiler-plugin\">Baeldung - Creating a Java Compiler Plugin</a>  </p>\n<p>… and many random StackoverFlow Answers. Thanks for them.</p>\n",
            "tags": [
                "compiler",
                "tech",
                "Java"
            ]
        },
        {
            "id": "https://ib67.io/2021/10/01/Writting-A-Compiler-1/",
            "url": "https://ib67.io/2021/10/01/Writting-A-Compiler-1/",
            "title": "从零开始的编译器生涯",
            "date_published": "2021-10-01T14:12:37.000Z",
            "content_html": "<p>近日一屑高二学生无聊动手写起了编译器….这是他的珍贵作战记录    </p>\n<span id=\"more\"></span>\n\n<h1 id=\"0x01-理论基础\"><a href=\"#0x01-理论基础\" class=\"headerlink\" title=\"0x01 理论基础\"></a>0x01 理论基础</h1><p>我摊牌，我没有看任何编译原理相关的书籍，因此这篇文章并不能作为严格的参考资料，甚至很多地方可能是错误的。  </p>\n<p>编译器，编译器，就是把高级语言的代码编译成另一种形式（class，asm，二进制，IR），而他在编译成另一种形式之前大概需要过这么个流程:</p>\n<p>Lex -&gt; Parse -&gt; Compile  </p>\n<p>接下来逐步讲解这个过程。</p>\n<h2 id=\"Lexer\"><a href=\"#Lexer\" class=\"headerlink\" title=\"Lexer\"></a>Lexer</h2><p>就是分词器，输入用户提供的代码接着把他分成 <code>tokens</code>，也就是 <code>tokenstream</code>。<br>你肯定看不懂上面那句话的意思，让我们来点实例：<br><img src=\"https://i.ibb.co/7rHNypx/image.png\" alt=\"image\"><br><code>a.value</code> 里的那个 <code>ArrayList</code> 就是一个 <code>token stream</code>，<code>str</code> 是被解析的代码。不难发现，语句被 Lexer 按顺序进行了分类以及数据的分割，如 <code>a</code> 被识别为了一个 <code>Identify</code> (标记)。 </p>\n<p>因此也可以归纳出来 <code>Token</code> 大致的代码长啥样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Token</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> line;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Parser\"><a href=\"#Parser\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p>Lexer 从源码中提取出 <code>token stream</code> 后将会交给 <code>Parser</code> 处理，它负责对 <code>token stream</code> 进行解析，生成一个 <code>AST (Abstract Syntax Tree)</code>，也就是 <code>抽象语法树</code>。  </p>\n<p><img src=\"https://i.ibb.co/7rHNypx/image.png\"><br>这张图直观的描述了这一过程，你可以看到它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。  </p>\n<p>接着，AST 将会丢给代码生成器用于生成代码，但是一般会先对 AST 进行优化，例如 <code>常量折叠</code></p>\n<h2 id=\"Static-Analyzing\"><a href=\"#Static-Analyzing\" class=\"headerlink\" title=\"Static Analyzing\"></a>Static Analyzing</h2><p>但在这之前，我们还有一些问题要解决。<br><del>其实这玩意我是和 Parser 写一块的</del><br>试想一下，如果有这样一行代码：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">var</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> love + cats</span><br></pre></td></tr></table></figure>\n<p>代码生成器如何知道 <code>love</code> 和 <code>cats</code> 是什么？ 在 Parser 的眼里，他们只是 <code>Identifier</code>，然而它们之间不能相加减。  </p>\n<p>在这种时候，Parser 需要预先建立一个符号表，这样他才能找出 <code>love</code> 和 <code>cats</code> 究竟是什么以及是否能够编译。</p>\n<p>同理，下面的代码也一样需要这一过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(List&lt;String&gt; args)</span>&#123; <span class=\"comment\">// 此处 Parser 将会分析出 java.lang.String 和 java.util.List</span></span><br><span class=\"line\">  <span class=\"type\">NullCat</span> <span class=\"variable\">nc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SBNC</span>(); <span class=\"comment\">// 按照 Java 的逻辑，此处没有导入（或同包）于是会产生错误，因为Parser找不到 SBNC / NullCat</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Code-Generation\"><a href=\"#Code-Generation\" class=\"headerlink\" title=\"Code Generation\"></a>Code Generation</h2><p>接着是生成代码！<br>一般编译器都会输出一种 <code>IR (Intermediate Representation)</code> 码，而他的作用则是一种中间表示。<br>例如，如果你输出 LLVM 的 IR 码，那么接下来你的编译工作（win,x64,linux,…jvm）就可以交给 LLVM 来完成，而像 <code>LLVM</code> 这样负责最后这一步骤的我们称之为 <code>编译器的后端</code></p>\n<p>使用这一种方法有几个好处：</p>\n<ul>\n<li>它可以使得开发者更专注于 <code>语言设计</code> 而不用过多的考虑 <code>优化</code>，因为大多数编译器后端会帮你完成这件事情 <del>，除非你直接输出汇编那就得你自己负责优化了</del>。</li>\n<li>IR 是中间表示，它可以按照相同的语义编译出不同平台，不同架构的代码，大大节省了开发者时间</li>\n<li>…</li>\n</ul>\n<p> 处于个人习惯，我选择了 Java 的字节码作为 “IR”，他将会被 JVM 加载并在运行过程中收集数据被更好的优化以及可以享受和 Java 互操作，跨平台的优势。</p>\n<h1 id=\"0x02-实践\"><a href=\"#0x02-实践\" class=\"headerlink\" title=\"0x02 实践\"></a>0x02 实践</h1><p>知道了这些理论，我们立即可以开始编写我们的第一个 Lexer 了。</p>\n<p>这是我们这一大章节的目标代码：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> java.util.<span class=\"function\">List</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">fn <span class=\"title\">main</span><span class=\"params\">(args: List&lt;<span class=\"type\">String</span>&gt;)</span></span>&#123;</span><br><span class=\"line\">  println <span class=\"string\">&quot;hello world!&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，让我们开始吧！<br>下文将会有大量代码，为了可读性，我会删掉一些无关紧要的部分。</p>\n<h2 id=\"Lexer-1\"><a href=\"#Lexer-1\" class=\"headerlink\" title=\"Lexer\"></a>Lexer</h2><p>我的 Lexer 分为两步：<code>fuzzyTokenize</code> 和 <code>tokenize</code>。<br>实际上这是取决于做法的，有正则转 DFA（状态机）的，也有直接 <code>charStream</code> 的。</p>\n<p>我选择了第二种，因为我认为使用正则的代码可读性比较糟糕，不易于维护。那么，让我们开始做一些准备工作…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Lexer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String fileName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String rawContent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Lexer</span><span class=\"params\">(String content,String fileName)</span> &#123;</span><br><span class=\"line\">        rawContent = content.replaceAll(<span class=\"string\">&quot;//.*|(\\&quot;(?:\\\\\\\\[^\\&quot;]|\\\\\\\\\\&quot;|.)*?\\&quot;)|(?s)/\\\\*.*?\\\\*/&quot;</span>, <span class=\"string\">&quot;$1 &quot;</span>); <span class=\"comment\">// remove comments.</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.fileName=fileName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从构造方法接受源代码和文件名并且删除注释。你可能会问文件名用来干啥，那当然是用来报错的～<br>接着，还有一个 <code>LexedNode</code> 用来表示 <code>fuzzyTokenize</code> 后的产物。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LexedNode</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> NodeType type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 初始化和getter...</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">NodeType</span> &#123;</span><br><span class=\"line\">        IDENTIFIER,SYMBOL,KEYWORD,OPERATOR,</span><br><span class=\"line\">        LINE_SEPERATOR,</span><br><span class=\"line\">        LITERAL_STRING,LITERAL_NUMBER</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这就是一个最基本的 <code>token</code>! 在后文，我们将会进行第二次 <code>tokenize</code> 使它变得更详细。  </p>\n<p>准备好了，开始写吧！首先是一个状态机：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;LexedNode&gt; <span class=\"title function_\">fuzzyTokenize</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>[] charStream = rawContent.toCharArray();</span><br><span class=\"line\">    List&lt;LexedNode&gt; nodes = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; charStream.length; i++) &#123; <span class=\"comment\">// 使用 fori 是为了循环时移动指针</span></span><br><span class=\"line\">        <span class=\"type\">char</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> charStream[i];</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (now) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\n&#x27;</span>:</span><br><span class=\"line\">              nodes.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LexedNode</span>(NodeType.LINE_SEPERATOR,<span class=\"string\">&quot;\\n&quot;</span>))</span><br><span class=\"line\">              <span class=\"keyword\">continue</span>; <span class=\"comment\">// 此处使用 continue 立即跳到下一次循环</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nodes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是你的第一个 Lexer，可以先输出一下看看结果：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"><span class=\"attribute\"></span></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"><span class=\"attribute\"></span></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"><span class=\"attribute\"></span></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"><span class=\"attribute\"></span></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br></pre></td></tr></table></figure>\n\n<p>因为代码有五行，因此是五个 <code>LINE_SEPERATOR</code>。<br>只有换行符可不够，我们还要识别 <code>KEYWORD</code> ，也就是关键词。<br>然而关键词使用空格分割，因此我们可以这样做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(...)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27; &#x27;</span>:                </span><br><span class=\"line\">        inIdOrLiteral = !inIdOrLiteral;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inIdOrLiteral) &#123; <span class=\"comment\">// start collecting</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// end!</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> buffer.toString();</span><br><span class=\"line\">        identifierParse(str, nodes);</span><br><span class=\"line\">        buffer = <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(); <span class=\"comment\">// compose</span></span><br><span class=\"line\">         <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 此处换行同理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Collect String or Identifier */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inIdOrLiteral) &#123;</span><br><span class=\"line\">        buffer.append(now);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以看到，我们引入了两个新的变量和一个方法，它们分别是 <code>inIdOrLiteral</code> 和 <code>buffer</code> 以及 <code>identifierParse</code>。</p>\n<p><strong>inIdOrLiteral</strong> 表示当前是否正在遍历一个 <code>Identifier</code> 或者一个字面量<br><strong>buffer</strong> 用于收集这个字面量，当然你也可以使用 <code>substring</code> 和 <code>charAt</code> 的方法<br><strong>identifierParse</strong> 是一个方法，他用于分类 Identifier。对于 <code>11</code>，他会分类成一个 <code>LITERAL_NUMBER</code>，对于 <code>not_a_keyword</code>，他会分类成一个 identifier，对于 <code>fn</code>，他会分类成一个 Keyword。</p>\n<p>还没完，天资聪颖的你肯定已经注意到了这里少了一样东西——我要怎么匹配最开头的一个 <code>using</code> ？ <code>using</code> 的前头可没有一个空格。<br>这时你可以回忆一下，在各种编程语言中作为 <code>Identifier</code> 的符号应该符合什么规则….是的，他们通常不会以运算符作为开头，以及他们不是一个关键字，因此我们还可以利用这个特性写出这样的代码:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         <span class=\"comment\">/* Other Symbols */</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (SYMBOL_OR_OPERATORS.contains(now）) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (inIdOrLiteral) &#123; <span class=\"comment\">// keyword</span></span><br><span class=\"line\">                 <span class=\"comment\">// now == a symbol,we should end this.</span></span><br><span class=\"line\">                 identifierParse(buffer.toString(), nodes);</span><br><span class=\"line\">                 buffer = <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">                 inIdOrLiteral = <span class=\"literal\">false</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (SYMBOLS.contains(now)) &#123;</span><br><span class=\"line\">                 nodes.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LexedNode</span>(now, LexedNode.NodeType.SYMBOL));</span><br><span class=\"line\">                 <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (OPERATORS.contains(now)) &#123;</span><br><span class=\"line\">                 nodes.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LexedNode</span>(now, LexedNode.NodeType.OPERATOR));</span><br><span class=\"line\">                 <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LexerException</span>(fileName+<span class=\"string\">&quot;: Unknown char: &quot;</span> + now+<span class=\"string\">&quot; line: &quot;</span>+line);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             inIdOrLiteral = <span class=\"literal\">true</span>; <span class=\"comment\">// not symbol &amp; not identifier</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Collect String or Identifier */</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (inIdOrLiteral) &#123;</span><br><span class=\"line\">     buffer.append(now);</span><br><span class=\"line\">     <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一段代码将会在匹配第一个字符没有遇到语言规定的操作符或者特殊符号的时候把 <code>inIdOrLiteral</code> 设置为 <code>true</code>。配合上面的代码，在遇到一个空格的时候他会结束收集并且尝试判断是什么。</p>\n<p>实际上应该是 <code>switch</code> 的任务但是写成 <code>if</code> 更加直观一些。  </p>\n<p>那么到现在，我们可以开始尝试代码了！这是 Lexer 的输出：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEYWORD using</span><br><span class=\"line\">IDENTIFIER java</span><br><span class=\"line\">OPERATOR .</span><br><span class=\"line\">IDENTIFIER util</span><br><span class=\"line\">OPERATOR .</span><br><span class=\"line\">IDENTIFIER List</span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">KEYWORD fn</span><br><span class=\"line\">IDENTIFIER main</span><br><span class=\"line\">SYMBOL (</span><br><span class=\"line\">IDENTIFIER args</span><br><span class=\"line\">OPERATOR :</span><br><span class=\"line\">IDENTIFIER List&lt;String&gt;</span><br><span class=\"line\">SYMBOL )</span><br><span class=\"line\">SYMBOL &#123;</span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">KEYWORD println</span><br><span class=\"line\"><span class=\"deletion\">- LITERAL_STRING hello world!</span></span><br><span class=\"line\"><span class=\"addition\">+ IDENTIFIER &quot;hello</span></span><br><span class=\"line\"><span class=\"addition\">+ IDENTIFIER world!&quot;</span></span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">SYMBOL &#125;</span><br><span class=\"line\">5: RIGHT_BRACKET &#125;</span><br></pre></td></tr></table></figure>\n\n<p>相比你已经注意到了，理应出现的 <code>LITERAL_STRING</code> 被两个 IDENTIFIER 代替了，这显然不是我们想要的结果。因此，我们要给 String 加入特 殊 支 持  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(now)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&quot;&#x27;</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; charStream[i - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;\\\\&#x27;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// string starts or end</span></span><br><span class=\"line\">                        inIdOrLiteral = !inIdOrLiteral;</span><br><span class=\"line\">                        stringMode = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!inIdOrLiteral) &#123;</span><br><span class=\"line\">                            stringMode = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                            <span class=\"comment\">// a new string!</span></span><br><span class=\"line\">                            nodes.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LexedNode</span>(buffer.toString(), LexedNode.NodeType.LITERAL_STRING));</span><br><span class=\"line\">                            buffer = <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    case &#x27; &#x27;:</span><br><span class=\"line\"><span class=\"addition\">+        if (stringMode) &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+            break;</span></span><br><span class=\"line\"><span class=\"addition\">+        &#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">- if (SYMBOL_OR_OPERATORS.contains(now)) &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+ if (SYMBOL_OR_OPERATORS.contains(now) &amp;&amp; !stringMode) &#123;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样我们就躲开了这个陷阱，完成了对于 String 的支持后，我们的 <code>fuzzyTokenize</code> 就做好了！</p>\n<blockquote>\n<p>关于 OPERATORS 和 SYMBOLS<br>一门语言里的符号很多，你绝对不会想把他们一个个 add 到 list 里面的，但你可以写一个 <a href=\"https://github.com/iceBear67/NullCatLang/blob/85a9b3234bcaab21451c0c6023f46d3599e5764d/src/main/java/io/ib67/lexer/Lexer.java#L11-L34\">loader</a> 来解决这个问题  </p>\n<p><img src=\"https://i.ibb.co/CMQdKXR/image.png\"></p>\n</blockquote>\n<hr>\n<p>然后，是 <code>tokenizer</code>。<code>fuzzyTokenize</code> 输出的结果显然不足以交给 Parser 做解析，我们需要使i结果更加详细。</p>\n<p>好在经过 <code>fuzzyTokenize</code> 后代码已经被格式化成了比较模糊的 <code>Token Stream</code>，这一点使我们写第二次 tokenize 的时候会轻松很多，因为你不会再见到 <code>inIdOrLiteral</code> 和 <code>stringMode</code> 这种让人抓狂的东西了。</p>\n<p>首先，让我们从一个新的 Token 开始（你不会想和 LexedNode 混一块的）:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Token</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> line;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Type</span>&#123;</span><br><span class=\"line\">        IDENTIFIER(<span class=\"string\">&quot;&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        CLASS(<span class=\"string\">&quot;class&quot;</span>),FUNCTION(<span class=\"string\">&quot;fn&quot;</span>),ANNOTATION(<span class=\"string\">&quot;annotation&quot;</span>),FOR(<span class=\"string\">&quot;for&quot;</span>),WHILE(<span class=\"string\">&quot;while&quot;</span>),IF(<span class=\"string\">&quot;if&quot;</span>),USING(<span class=\"string\">&quot;using&quot;</span>)</span><br><span class=\"line\">        ,THIS(<span class=\"string\">&quot;this&quot;</span>),TRUE(<span class=\"string\">&quot;true&quot;</span>),FALSE(<span class=\"string\">&quot;false&quot;</span>),ELSE(<span class=\"string\">&quot;else&quot;</span>),VAR(<span class=\"string\">&quot;var&quot;</span>),NULL(<span class=\"string\">&quot;null&quot;</span>),PRINTLN(<span class=\"string\">&quot;println&quot;</span>), <span class=\"comment\">// KEYWORDS</span></span><br><span class=\"line\">        VAL(<span class=\"string\">&quot;val&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        LEFT_BRACE(<span class=\"string\">&quot;(&quot;</span>),RIGHT_BRACE(<span class=\"string\">&quot;)&quot;</span>),</span><br><span class=\"line\">        LEFT_BRACKET(<span class=\"string\">&quot;&#123;&quot;</span>),RIGHT_BRACKET(<span class=\"string\">&quot;&#125;&quot;</span>),</span><br><span class=\"line\">        LEFT_MID_BRACE(<span class=\"string\">&quot;[&quot;</span>),RIGHT_MID_BRACE(<span class=\"string\">&quot;]&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        COMMA(<span class=\"string\">&quot;,&quot;</span>),DOT(<span class=\"string\">&quot;.&quot;</span>),MINUS(<span class=\"string\">&quot;-&quot;</span>),PLUS(<span class=\"string\">&quot;+&quot;</span>),STAR(<span class=\"string\">&quot;*&quot;</span>),SLASH(<span class=\"string\">&quot;/&quot;</span>), <span class=\"comment\">// operators</span></span><br><span class=\"line\">        BREAK_LINE(<span class=\"string\">&quot;\\n&quot;</span>),ASSIGNMENT(<span class=\"string\">&quot;=&quot;</span>),EQUALS(<span class=\"string\">&quot;==&quot;</span>),SEMICOLON(<span class=\"string\">&quot;;&quot;</span>),AT(<span class=\"string\">&quot;@&quot;</span>),COLON(<span class=\"string\">&quot;:&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        LITERAL_STRING(<span class=\"string\">&quot;&quot;</span>),LITERAL_NUMBER(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// literals</span></span><br><span class=\"line\">        <span class=\"meta\">@Getter</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String def;</span><br><span class=\"line\">        Type(String def)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.def=def;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>比上文的 LexedNode 详细了很多——比如他主动去分类 keyword 了。<br>接着是一个 fori ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Pair&lt;String,List&lt;Token&gt;&gt; <span class=\"title function_\">tokenize</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">lexedNodes</span> <span class=\"operator\">=</span> fuzzyTokenize();</span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">tokens</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Token&gt;();</span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; lexedNodes.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">LexedNode</span> <span class=\"variable\">lexedNode</span> <span class=\"operator\">=</span> lexedNodes.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (lexedNode.getType()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LINE_SEPERATOR:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.BREAK_LINE,<span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">                line++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SYMBOL:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> KEYWORD:</span><br><span class=\"line\">                <span class=\"type\">var</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> Arrays.stream(Token.Type.values()).filter(e -&gt; e.getDef().equals(lexedNode.getContent())).findFirst().orElseThrow(()-&gt;&#123;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(lexedNode.toString());</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, type, type.getDef()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LITERAL_STRING:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.LITERAL_STRING, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LITERAL_NUMBER:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.LITERAL_NUMBER, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OPERATOR:</span><br><span class=\"line\">                <span class=\"comment\">// =</span></span><br><span class=\"line\">                <span class=\"type\">boolean</span> <span class=\"variable\">isEnd</span> <span class=\"operator\">=</span> (i == lexedNodes.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (lexedNode.getContent()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;=&quot;</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (isEnd) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LexerException</span>(fileName+<span class=\"string\">&quot;: Invalid syntax line &quot;</span>+line);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (lexedNodes.get(i + <span class=\"number\">1</span>).getType() == LexedNode.NodeType.OPERATOR &amp;&amp; lexedNodes.get(i + <span class=\"number\">1</span>).getContent().equals(<span class=\"string\">&quot;=&quot;</span>)) &#123; <span class=\"comment\">// ==</span></span><br><span class=\"line\">                            tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.EQUALS, <span class=\"string\">&quot;==&quot;</span>));</span><br><span class=\"line\">                            i = i + <span class=\"number\">1</span>; <span class=\"comment\">// skip next</span></span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.ASSIGNMENT, <span class=\"string\">&quot;=&quot;</span>));</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;.&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.DOT, <span class=\"string\">&quot;.&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;,&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.COMMA, <span class=\"string\">&quot;,&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.MINUS, <span class=\"string\">&quot;-&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.PLUS, <span class=\"string\">&quot;+&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.STAR,<span class=\"string\">&quot;*&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.SLASH,<span class=\"string\">&quot;/&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;;&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.SEMICOLON,<span class=\"string\">&quot;;&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;:&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line,Token.Type.COLON,<span class=\"string\">&quot;:&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IDENTIFIER:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Token</span>(line, Token.Type.IDENTIFIER, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pair.of(fileName,tokens);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码并不难懂。在这个例子中，我们遍历来自 fuzzyTokenizer 的数据并且通过 switch 分类枚举来处理把他们转化成 <code>Token</code> 来表达并且存储到 <code>tokens</code>。对于 symbol 和 keyword，我们通过直接搜索 enum 内值的方法避免写出了像 <code>case OPERATOR</code> 里更糟糕的代码。  </p>\n<p><code>case OPERATOR</code> 里写成这样是为了双符号操作的支持，例如 <code>==</code></p>\n<p>回到原题，这次我们可以通过 tokenize 解析出这样的结果：</p>\n<figure class=\"highlight ldif\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">1</span>: USING using</span><br><span class=\"line\"><span class=\"attribute\">1</span>: IDENTIFIER java</span><br><span class=\"line\"><span class=\"attribute\">1</span>: DOT .</span><br><span class=\"line\"><span class=\"attribute\">1</span>: IDENTIFIER util</span><br><span class=\"line\"><span class=\"attribute\">1</span>: DOT .</span><br><span class=\"line\"><span class=\"attribute\">1</span>: IDENTIFIER List</span><br><span class=\"line\"><span class=\"attribute\">1</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">2</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">3</span>: FUNCTION fn</span><br><span class=\"line\"><span class=\"attribute\">3</span>: IDENTIFIER main</span><br><span class=\"line\"><span class=\"attribute\">3</span>: LEFT_BRACE (</span><br><span class=\"line\"><span class=\"attribute\">3</span>: IDENTIFIER args</span><br><span class=\"line\"><span class=\"attribute\">3</span>: COLON :</span><br><span class=\"line\"><span class=\"attribute\">3</span>: IDENTIFIER List&lt;String&gt;</span><br><span class=\"line\"><span class=\"attribute\">3</span>: RIGHT_BRACE )</span><br><span class=\"line\"><span class=\"attribute\">3</span>: LEFT_BRACKET &#123;</span><br><span class=\"line\"><span class=\"attribute\">3</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">4</span>: PRINTLN println</span><br><span class=\"line\"><span class=\"attribute\">4</span>: LITERAL_STRING hello world!</span><br><span class=\"line\"><span class=\"attribute\">4</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">5</span>: RIGHT_BRACKET &#125;</span><br><span class=\"line\"><span class=\"attribute\">5</span>: RIGHT_BRACKET &#125;</span><br></pre></td></tr></table></figure>\n<p>是不是详细了很多？接着我们就可以靠着这个写一个 Parser了</p>\n<h2 id=\"在-Parse-之前\"><a href=\"#在-Parse-之前\" class=\"headerlink\" title=\"在 Parse 之前\"></a>在 Parse 之前</h2><p>在 Parse 之前，我们需要先做一次 Static Analyzing。在这个阶段，Parser 会对文件里的类型和导入表作出关联，同时也是多文件编译的基础。</p>\n<h3 id=\"Metadata\"><a href=\"#Metadata\" class=\"headerlink\" title=\"Metadata\"></a>Metadata</h3><p>你不可能靠着所有人的源码来建立索引，而且源码中的无用信息太多了。<br>实际上，确定符号链接只需要这些信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CatMetadata</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">ClassDef</span> <span class=\"variable\">classDefinition</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassDef</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String,CatMetadata&gt; cachedUsings = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(); <span class=\"comment\">// 这是对于被解析对象才有的</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt; MethodSign&gt; methods = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, VariableDef&gt; fields = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关于 <code>ClassDef</code>, <code>MethodSign</code>, <code>VariableDef</code> 等信息本文不贴出，因为并不会影响观看体验。<br>如果有兴趣，可以在<a href=\"https://github.com/iceBear67/NullCatLang/tree/master/src/main/java/io/ib67/ast/decl\">这里</a>找到他们相对应的具体代码  </p>\n</blockquote>\n<p>以及一个编译器全局索引，用 FQDN 确定唯一性的 Map:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Global</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String,CatMetadata&gt; GLOBAL_METADATAS = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> CatMetadata <span class=\"title function_\">forClass</span><span class=\"params\">(String str)</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          * Scan compiler classPaths</span></span><br><span class=\"line\"><span class=\"comment\">          */</span></span><br><span class=\"line\">         <span class=\"type\">var</span> <span class=\"variable\">meta</span> <span class=\"operator\">=</span> NullCatCompiler.solveMeta(str);</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(meta!=<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             GLOBAL_METADATAS.put(str, meta);</span><br><span class=\"line\">         &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">             meta = NullCatCompiler.solveMeta(<span class=\"string\">&quot;java.lang.&quot;</span> + str);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> meta;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>准备就绪，我们来单独拿出一个类作为 <code>MetadataGenerator</code> 状态机  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequiredArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MetadataGenerator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String fileName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Token&gt; tokens;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">CatMetadata</span> <span class=\"variable\">cm</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CatMetadata</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着，是提取数据的部分:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> CatMetadata <span class=\"title function_\">gen</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tokens.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">Token</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> tokens.get(i);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> (i==tokens.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">Token</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> end?<span class=\"literal\">null</span>:tokens.get(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(now.getType())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> USING:</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!end)&#123;</span><br><span class=\"line\">                    i=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"type\">var</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> readAsStringUntilLB();</span><br><span class=\"line\">                    cm.getCachedUsings().put(clazz, Optional.ofNullable(CatMetadata.Global.forClass(clazz)).orElseThrow(()-&gt;<span class=\"keyword\">new</span> <span class=\"title class_\">ParseException</span>(<span class=\"string\">&quot;Can&#x27;t find clazz &quot;</span>+clazz)));</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    throwEOF();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> FUNCTION:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (end) &#123;</span><br><span class=\"line\">                    throwEOF();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// fn main()&#123;&#125;</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(next.getType() != Token.Type.IDENTIFIER)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ParseException</span>(fileName+<span class=\"string\">&quot;: Unexcepted &quot;</span>+next.getType()+<span class=\"string\">&quot; at line &quot;</span>+now.getLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> next.getContent();</span><br><span class=\"line\">                i=i+<span class=\"number\">1</span>; <span class=\"comment\">// Move Pointer to (</span></span><br><span class=\"line\">                <span class=\"type\">MethodSign</span> <span class=\"variable\">sign</span> <span class=\"operator\">=</span> readMethodSign(methodName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode()))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ParseException</span>(fileName+<span class=\"string\">&quot;: Duplicated method: &quot;</span>+sign+<span class=\"string\">&quot; at line &quot;</span>+now.getLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cm.getMethods().add(sign);</span><br><span class=\"line\">                skipCodeBlocks();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cm;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在这个循环当中，我们通过获取到 Token 的类型来判定需要做的操作，这是基于语言设计定义来做的—— 例如 <code>fn</code> 的后面必然是一个方法签名，而不可以是别的。最终 <code>MetadataGenerator</code> 将会返回一个 CatMetadata 以供后续操作。</p>\n<p>因此，这一阶段我们也可以发掘出类型错误和大的语法错误。</p>\n<h3 id=\"与-Java-的世界\"><a href=\"#与-Java-的世界\" class=\"headerlink\" title=\"与 Java 的世界\"></a>与 Java 的世界</h3><p>我们需要和 Java 交互，因此我们需要给 <code>Class</code> 建立 <code>CatMetadata</code> 。好在这很简单，因为 CatMetadata 需要的所有数据都可以通过反射获取，这里提供一段参考代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassMetaPathImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MetaPath</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassLoader classLoader;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CatMetadata <span class=\"title function_\">findClass</span><span class=\"params\">(String clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">CatMetadata</span> <span class=\"variable\">cm</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CatMetadata</span>();</span><br><span class=\"line\">        Class&lt;?&gt; claz = Util.runCatching(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Class.forName(clazz,<span class=\"literal\">false</span>,classLoader);</span><br><span class=\"line\">        &#125;).getResult();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(claz==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Field declaredField : claz.getDeclaredFields()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Modifier.isPublic(declaredField.getModifiers())) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"type\">VariableDef</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">VariableDef</span>(declaredField.getType().getCanonicalName(),declaredField.getName());</span><br><span class=\"line\">            cm.getFields().put(declaredField.getName(),def);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Method declaredMethod: claz.getDeclaredMethods())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Modifier.isPublic(declaredMethod.getModifiers()))<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"type\">MethodSign</span> <span class=\"variable\">sign</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MethodSign</span>(declaredMethod.getName(), (ArrayList&lt;String&gt;) Arrays.stream(declaredMethod.getParameterTypes()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList()));</span><br><span class=\"line\">            cm.getMethods().add(sign);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ClassDef</span> <span class=\"variable\">cdf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassDef</span>();</span><br><span class=\"line\">        cdf.setClassName(clazz);</span><br><span class=\"line\">        cdf.setSuperclass(claz.getSuperclass()==<span class=\"literal\">null</span>?<span class=\"literal\">null</span>:claz.getSuperclass().getCanonicalName());</span><br><span class=\"line\">        cdf.setInterfaces(Arrays.stream(claz.getInterfaces()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList()));</span><br><span class=\"line\">        cm.setClassDefinition(cdf);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>静态分析结束后，我们就要准备开始生成 AST 了。</p>\n<blockquote>\n<p>附<br>我们从 token 流中获取数据，并且根据类型进行匹配——但我们其实没有用到状态<br>仔细看，你会发现这个东西：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        i=i+1; // Move Pointer to (</span><br><span class=\"line\"><span class=\"addition\">+        MethodSign sign = readMethodSign(methodName);</span></span><br><span class=\"line\">        if(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode()))&#123;</span><br><span class=\"line\">            throw new ParseException(fileName+&quot;: Duplicated method: &quot;+sign+&quot; at line &quot;+now.getLine());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cm.getMethods().add(sign);</span><br><span class=\"line\"><span class=\"addition\">+        skipCodeBlocks();</span></span><br><span class=\"line\">        continue;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>是不是有些象是 DSL？<br>这其实归咎于类字段中那个不起眼的 <code>int i = 0</code>，它使得 for 循环的指针可以被整个类里的方法所共享。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">readAsStringUntilLB</span><span class=\"params\">()</span>&#123; <span class=\"comment\">// 一只读，读到一个换行为止并且收集成字符串</span></span><br><span class=\"line\">    <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> b=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> i; tokens.get(a).getType()!= Token.Type.BREAK_LINE;a++)&#123;</span><br><span class=\"line\">        sb.append(tokens.get(a).getContent());</span><br><span class=\"line\">        b=a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在经过更加详细的 tokenize 之后，代码实际上变得更加可观了，</p>\n</blockquote>\n<h2 id=\"Parser-1\"><a href=\"#Parser-1\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p>先占个坑位～</p>\n",
            "tags": [
                "compiler",
                "tech"
            ]
        },
        {
            "id": "https://ib67.io/2021/03/13/%E4%BD%BF%E7%94%A8-cproxy-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/",
            "url": "https://ib67.io/2021/03/13/%E4%BD%BF%E7%94%A8-cproxy-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/",
            "title": "使用 cproxy 对程序进行透明代理",
            "date_published": "2021-03-13T14:57:30.000Z",
            "content_html": "<p>在 Windows 下，说到 <code>透明代理</code> ，你可能会想到 <code>Proxifier</code> , <code>SSTap</code>, <code>Mellow</code><br>但在 Linux 下，你可能会想到 <code>proxychains</code> 然后再想到 <code>proxychains</code> 不能代理 static-linked 的程序。  </p>\n<span id=\"more\"></span>\n<h1 id=\"为什么-ProxyChains-NG-不能代理静态连接的程序\"><a href=\"#为什么-ProxyChains-NG-不能代理静态连接的程序\" class=\"headerlink\" title=\"为什么 ProxyChains(NG) 不能代理静态连接的程序\"></a>为什么 ProxyChains(NG) 不能代理静态连接的程序</h1><p>ProxyChains NG 通过一个预加载的共享库来hook到网络相关的函数(比如: connect,getaddrinfo)上，接着他就可以转发这些流量。<br>缺点似乎显而易见，如果只是通过 <a href=\"https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick\">LD_PRELOAD</a> 来进行透明代理，那么这招对于静态连接的程序是无用的（比如说 Go 程序..)<br>其次，ProxyChains 只支持 TCP，这可能导致无法转发 DNS 流量 -&gt; DNS 流量泄漏。  </p>\n<h1 id=\"cproxy-是什么\"><a href=\"#cproxy-是什么\" class=\"headerlink\" title=\"cproxy 是什么\"></a>cproxy 是什么</h1><p><a href=\"https://github.com/NOBLES5E/cproxy\">cproxy</a> 也是透明代理，作用和 proxychains 类似。<br>原理上与 proxychains 不同，它使用 <code>cgroup</code> 进行对程序的代理 <del>，不过配置起来还有点麻烦</del><br>本文将会教您在您的Linux PC上使用 cproxy，截至本文发布之前，cproxy似乎只支持 Linux。  </p>\n<h2 id=\"下载-cproxy\"><a href=\"#下载-cproxy\" class=\"headerlink\" title=\"下载 cproxy\"></a>下载 cproxy</h2><p>官方推荐的方法是: 直接用 <code>cargo</code>    </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo install cproxy</span><br></pre></td></tr></table></figure>\n\n<p>如果没有 cargo 可以在 <a href=\"https://github.com/NOBLES5E/cproxy/releases\">Release</a> 上下载压缩包。<br>解压压缩包，可能会发现有两个可执行文件，不过似乎只留一个就好了。  </p>\n<h2 id=\"安装-cproxy\"><a href=\"#安装-cproxy\" class=\"headerlink\" title=\"安装 cproxy\"></a>安装 cproxy</h2><p>先来试一试 cproxy！  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cproxy --port &lt;本地代理端口&gt; -- curl ip.sb</span><br></pre></td></tr></table></figure>\n\n<p>( ｀д′) 失败了<br>如果你和我一样，在port上写了 socks5 的代理端口，那么你就被坑了。<br>笔者填入 geph 的 HTTP 代理端口时是可以成功的，但是使用 v2ray 的s5/http端口都无法使用。<br>这是因为 cproxy 需要<a href=\"https://github.com/NOBLES5E/cproxy/wiki/Example-setup-with-V2Ray\">修改 v2ray 的配置</a>进行兼容，<a href=\"https://github.com/zfl9/ipt2socks\">如果你不想去改配置</a>  </p>\n<p>在确保可以使用 cproxy 后，我们来配置 <code>alias</code>。<br>将以下内容写到 <code>~/.bashrc</code>，记得自己修改一些部分。  </p>\n<pre><code class=\"bash\">alias &quot;px&quot;=&quot;/path/to/cproxy --port &lt;your-local-proxy-port&gt; --&quot;\n</code></pre>\n<p>例如我的配置：</p>\n<pre><code class=\"bash\">alias &quot;px&quot;=&quot;/bin/cproxy --port 60080 --use-tproxy -- &quot; # 60080 是ipt2socks的默认监听端口。\n</code></pre>\n<p>保存后，使用 <code>source ~/.bashrc</code> 载入，试试 <code>px curl ip.sb</code>，看看是否成功。  </p>\n<h2 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h2><p>每次使用都要 sudo ，还是挺烦人的吧…<br>对于这种情况，也可以考虑使用有后台常驻的 <a href=\"https://github.com/springzfx/cgproxy\">cgproxy</a>，但本文不做介绍，有兴趣可以自己了解。  </p>\n",
            "tags": [
                "tech",
                "Linux"
            ]
        }
    ]
}