{
    "version": "https://jsonfeed.org/version/1",
    "title": "nstd::out • All posts by \"writeup\" category",
    "description": "iceBear 的博客",
    "home_page_url": "https://ib67.io",
    "items": [
        {
            "id": "https://ib67.io/2022/02/10/How-to-help-Others/",
            "url": "https://ib67.io/2022/02/10/How-to-help-Others/",
            "title": "关于提问与回答",
            "date_published": "2022-02-10T12:16:48.000Z",
            "content_html": "<p>在「如何请求到他人的帮助来解决问题」上已经有许多优秀的<a href=\"https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way\">指导文章</a>，但在如何有效的帮助他人上似乎还是少了那么点东西。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"授人予鱼不如…\"><a href=\"#授人予鱼不如…\" class=\"headerlink\" title=\"授人予鱼不如…?\"></a>授人予鱼不如…?</h1><p>「帮助他人」自然算不上是什么难事，至少相比如何高效的提问来说是非常简单的了。但能够并不就代表着高效，很多时间我试着去帮助其他人解答他们的问题——无论难易或是问题给予的信息有多少，我总是将答案说的尽可能详细，想着以这样的方式来解决问题。</p>\n<p>不得不承认这种方法有时相当有效，只需要告诉对方「啊，先这样，然后那样」他们的问题就被解决掉了。但是随着时间推移，我在社区里解答过的问题越来越多，渐渐的我感到疲倦。这种手把手的解答方式当然非常有效，但对方能得到什么，我们持续的输出知识又能得到什么？带着这样的想法，我开始<em>不把话说的那么详细</em>。</p>\n<p>举个例子。</p>\n<p><img src=\"https://upload.cc/i1/2022/02/10/yY4Jgo.png\" alt=\"原问题\"></p>\n<p><img src=\"https://upload.cc/i1/2022/02/10/5LpBOI.png\" alt=\"我的回答\"></p>\n<p><img src=\"https://upload.cc/i1/2022/02/10/K0reQh.png\" alt=\"结果\"></p>\n<p>以下是在另一个群内发生的，相同的问题不同的答案：</p>\n<p><img src=\"https://upload.cc/i1/2022/02/10/v3lzPV.png\"></p>\n<p>我觉得我成功让对方<em>思考</em>了一番，而不只是我在唱独角戏。<br>所以说，有时候解决问题应当是引导提问的人寻找思考的方向，而不只是告诉他答案。正所谓 <code>授人以魚不如授人以漁</code></p>\n<h1 id=\"问句应使用问号而不是句号\"><a href=\"#问句应使用问号而不是句号\" class=\"headerlink\" title=\"问句应使用问号而不是句号\"></a>问句应使用问号而不是句号</h1><p>如果提问者的态度令人发指，自然应该拒绝它。<br>就我所在的圈子里而言，我经常能见到一些人是这样问问题的:</p>\n<p><img src=\"https://upload.cc/i1/2022/02/10/j8PGz7.png\"></p>\n<p>遇到这样的提问者，我通常会猜测两种人。</p>\n<ol>\n<li>语音输入用户</li>\n<li>日常聊天说什么话<em>末尾都要用个句号，连问句和感叹句都不放过</em>的人</li>\n</ol>\n<p>当然，语音输入用户没有做错任何事情。我无法理解的是第二种人，为什么日常聊天什么都得带个句号呢？对句号的执念是如此的深…</p>\n<p>当然，以上是我的个人吐槽，若有冒犯请多见谅。本段的重点不在于用问号还是句号，而是提问的态度。没有任何人有义务在社区里为了各自的问题来逐一解答，大家的时间都很有限，所以正确的提问方式（而不只是态度）尤其重要。试想一下如果遇到了这样的问题：</p>\n<p><img src=\"https://upload.cc/i1/2022/02/10/yVZgkw.png\" alt=\"反面教材\"></p>\n<p>那么如何解决？一不知道用的是什么权限组插件，二不知道他是要干什么，这样的问题必须要有人来进一步引导才能解决，然而他甚至可能已经在群发这种问题，根本看不到你的反问。  </p>\n<p>由此，<strong>纠正错误的提问方式尤其重要</strong>，每个人都应该学会如何正确的提一个问题来尽可能快的得到帮助，对你好也对我好。  </p>\n<p>正如上文所说，*在「如何请求到他人的帮助来解决问题」上已经有许多优秀的<a href=\"https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way\">指导文章</a>*，但直接把这玩意扔出去多半也没有什么人会看。</p>\n<p>但我们有别的做法。</p>\n<p><img src=\"https://upload.cc/i1/2022/02/10/wFrIXz.png\" alt=\"Ex.1\"></p>\n<p><img src=\"https://upload.cc/i1/2022/02/10/VKSyfE.png\" alt=\"Ex.2\"></p>\n<p>还有一种是“问题类型收费表”，把最差的问法放最贵，最好的问法放免费，这也不失为一种巧妙的做法。</p>\n<p>唯有问问题的人学着去问问题，解决问题的人才能把时间花在真正有用的地方上。</p>\n<h1 id=\"不要太多厨师\"><a href=\"#不要太多厨师\" class=\"headerlink\" title=\"不要太多厨师\"></a>不要太多厨师</h1><p>这句话其实出自英语里的 <code>too many cooks in the kitchen</code>，意思是这里有太多的人工作在同一件事情上，而这样会导致不好的结果。</p>\n<p>正如上文的一个反例：</p>\n<p><img src=\"https://upload.cc/i1/2022/02/10/v3lzPV.png\" alt=\"反例\"></p>\n<p>各抒己见自然有利于自由讨论，但不适用于解决问题上，其实也很可能会演化成情绪倾泻的垃圾桶，每个人都在坚持自己的意见，甚至可能还会出现人身攻击。</p>\n<p>当然，这种极端情况是后话而且并不多见。但一个问题确实不应该有太多的人上去解答，尤其是比较泛的问题。如果你已经看到有别的”厨师”正在解决这个问题，那么你只要纠正他的说法就好，而不是他说一套你也要跟着说一套，那样只会让提问的人更加混乱</p>\n<p><em>「我 TM 到底听谁的」</em></p>\n<h1 id=\"找出真正的问题\"><a href=\"#找出真正的问题\" class=\"headerlink\" title=\"找出真正的问题\"></a>找出真正的问题</h1><p>有一种问题，我们管它叫做 Y 问题，为什么呢？<br>因为 Y 问题是 X 问题的一个分支，解决了 Y 问题自然可以解决 X 问题，但<strong>不代表必须解决</strong> Y 问题才能解决 X 问题。</p>\n<p>这就是 XY-Problem ，大家都经常犯的错误。如果你遇到了一些比较不合理的需求，不妨问一问提问者「你的原始需求是啥啊」，或许你会得到一个新的看问题的视野。  </p>\n<p>举个例子:  </p>\n<p>「Q：有没有什么插件可以替换任意 GUI 里面的文本啊，我只找到替换聊天信息的」<br>「A: 你要替换什么文本？」<br>「Q：XX 插件的菜单里面都是英文的，我想通过替换来翻译一下」<br>「A: 直接在 <code>plugins\\XXX\\gui.yml</code> 里面改就好了，用不着找那种插件，况且也没有。」  </p>\n<p>除了 X-Y 问题，也可能是提问者表述不清，适当引导即可。</p>\n<hr>\n<p>说了这么多，其实核心只有两件事情：</p>\n<ol>\n<li>引导——有时我们要引导提问者而不只是给他答案，但不代表所有的问题都需要引导。</li>\n<li>态度——如果提问者的态度令人发指，你应该恰当的指出他的错误。</li>\n</ol>\n<p>就此抛砖引玉，欢迎在评论区留下评论。</p>\n",
            "tags": [
                "misc"
            ]
        },
        {
            "id": "https://ib67.io/2021/10/01/Writting-A-Compiler-1/",
            "url": "https://ib67.io/2021/10/01/Writting-A-Compiler-1/",
            "title": "从零开始的编译器生涯",
            "date_published": "2021-10-01T14:12:37.000Z",
            "content_html": "<p>近日一屑高二学生无聊动手写起了编译器….这是他的珍贵作战记录    </p>\n<span id=\"more\"></span>\n\n<h1 id=\"0x01-理论基础\"><a href=\"#0x01-理论基础\" class=\"headerlink\" title=\"0x01 理论基础\"></a>0x01 理论基础</h1><p>我摊牌，我没有看任何编译原理相关的书籍，因此这篇文章并不能作为严格的参考资料，甚至很多地方可能是错误的。  </p>\n<p>编译器，编译器，就是把高级语言的代码编译成另一种形式（class，asm，二进制，IR），而他在编译成另一种形式之前大概需要过这么个流程:</p>\n<p>Lex -&gt; Parse -&gt; Compile  </p>\n<p>接下来逐步讲解这个过程。</p>\n<h2 id=\"Lexer\"><a href=\"#Lexer\" class=\"headerlink\" title=\"Lexer\"></a>Lexer</h2><p>就是分词器，输入用户提供的代码接着把他分成 <code>tokens</code>，也就是 <code>tokenstream</code>。<br>你肯定看不懂上面那句话的意思，让我们来点实例：<br><img src=\"https://upload.cc/i1/2021/10/01/gGftuh.png\" alt=\"image\"><br><code>a.value</code> 里的那个 <code>ArrayList</code> 就是一个 <code>token stream</code>，<code>str</code> 是被解析的代码。不难发现，语句被 Lexer 按顺序进行了分类以及数据的分割，如 <code>a</code> 被识别为了一个 <code>Identify</code> (标记)。 </p>\n<p>因此也可以归纳出来 <code>Token</code> 大致的代码长啥样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Token</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> line;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Parser\"><a href=\"#Parser\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p>Lexer 从源码中提取出 <code>token stream</code> 后将会交给 <code>Parser</code> 处理，它负责对 <code>token stream</code> 进行解析，生成一个 <code>AST (Abstract Syntax Tree)</code>，也就是 <code>抽象语法树</code>。  </p>\n<p><img src=\"https://upload.cc/i1/2021/10/01/nVE3wl.png\"><br>这张图直观的描述了这一过程，你可以看到它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。  </p>\n<p>接着，AST 将会丢给代码生成器用于生成代码，但是一般会先对 AST 进行优化，例如 <code>常量折叠</code></p>\n<h2 id=\"Static-Analyzing\"><a href=\"#Static-Analyzing\" class=\"headerlink\" title=\"Static Analyzing\"></a>Static Analyzing</h2><p>但在这之前，我们还有一些问题要解决。<br><del>其实这玩意我是和 Parser 写一块的</del><br>试想一下，如果有这样一行代码：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = love + cats</span><br></pre></td></tr></table></figure>\n<p>代码生成器如何知道 <code>love</code> 和 <code>cats</code> 是什么？ 在 Parser 的眼里，他们只是 <code>Identifier</code>，然而它们之间不能相加减。  </p>\n<p>在这种时候，Parser 需要预先建立一个符号表，这样他才能找出 <code>love</code> 和 <code>cats</code> 究竟是什么以及是否能够编译。</p>\n<p>同理，下面的代码也一样需要这一过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(List&lt;String&gt; args)</span></span>&#123; <span class=\"comment\">// 此处 Parser 将会分析出 java.lang.String 和 java.util.List</span></span><br><span class=\"line\">  NullCat nc = <span class=\"keyword\">new</span> SBNC(); <span class=\"comment\">// 按照 Java 的逻辑，此处没有导入（或同包）于是会产生错误，因为Parser找不到 SBNC / NullCat</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Code-Generation\"><a href=\"#Code-Generation\" class=\"headerlink\" title=\"Code Generation\"></a>Code Generation</h2><p>接着是生成代码！<br>一般编译器都会输出一种 <code>IR (Intermediate Representation)</code> 码，而他的作用则是一种中间表示。<br>例如，如果你输出 LLVM 的 IR 码，那么接下来你的编译工作（win,x64,linux,…jvm）就可以交给 LLVM 来完成，而像 <code>LLVM</code> 这样负责最后这一步骤的我们称之为 <code>编译器的后端</code></p>\n<p>使用这一种方法有几个好处：</p>\n<ul>\n<li>它可以使得开发者更专注于 <code>语言设计</code> 而不用过多的考虑 <code>优化</code>，因为大多数编译器后端会帮你完成这件事情 <del>，除非你直接输出汇编那就得你自己负责优化了</del>。</li>\n<li>IR 是中间表示，它可以按照相同的语义编译出不同平台，不同架构的代码，大大节省了开发者时间</li>\n<li>…</li>\n</ul>\n<p> 处于个人习惯，我选择了 Java 的字节码作为 “IR”，他将会被 JVM 加载并在运行过程中收集数据被更好的优化以及可以享受和 Java 互操作，跨平台的优势。</p>\n<h1 id=\"0x02-实践\"><a href=\"#0x02-实践\" class=\"headerlink\" title=\"0x02 实践\"></a>0x02 实践</h1><p>知道了这些理论，我们立即可以开始编写我们的第一个 Lexer 了。</p>\n<p>这是我们这一大章节的目标代码：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> java.util.List</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">fn <span class=\"title\">main</span><span class=\"params\">(args: List&lt;<span class=\"keyword\">String</span>&gt;)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span> <span class=\"string\">&quot;hello world!&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，让我们开始吧！<br>下文将会有大量代码，为了可读性，我会删掉一些无关紧要的部分。</p>\n<h2 id=\"Lexer-1\"><a href=\"#Lexer-1\" class=\"headerlink\" title=\"Lexer\"></a>Lexer</h2><p>我的 Lexer 分为两步：<code>fuzzyTokenize</code> 和 <code>tokenize</code>。<br>实际上这是取决于做法的，有正则转 DFA（状态机）的，也有直接 <code>charStream</code> 的。</p>\n<p>我选择了第二种，因为我认为使用正则的代码可读性比较糟糕，不易于维护。那么，让我们开始做一些准备工作…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lexer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String fileName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String rawContent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Lexer</span><span class=\"params\">(String content,String fileName)</span> </span>&#123;</span><br><span class=\"line\">        rawContent = content.replaceAll(<span class=\"string\">&quot;//.*|(\\&quot;(?:\\\\\\\\[^\\&quot;]|\\\\\\\\\\&quot;|.)*?\\&quot;)|(?s)/\\\\*.*?\\\\*/&quot;</span>, <span class=\"string\">&quot;$1 &quot;</span>); <span class=\"comment\">// remove comments.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fileName=fileName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从构造方法接受源代码和文件名并且删除注释。你可能会问文件名用来干啥，那当然是用来报错的～<br>接着，还有一个 <code>LexedNode</code> 用来表示 <code>fuzzyTokenize</code> 后的产物。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LexedNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> NodeType type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 初始化和getter...</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">NodeType</span> </span>&#123;</span><br><span class=\"line\">        IDENTIFIER,SYMBOL,KEYWORD,OPERATOR,</span><br><span class=\"line\">        LINE_SEPERATOR,</span><br><span class=\"line\">        LITERAL_STRING,LITERAL_NUMBER</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这就是一个最基本的 <code>token</code>! 在后文，我们将会进行第二次 <code>tokenize</code> 使它变得更详细。  </p>\n<p>准备好了，开始写吧！首先是一个状态机：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;LexedNode&gt; <span class=\"title\">fuzzyTokenize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] charStream = rawContent.toCharArray();</span><br><span class=\"line\">    List&lt;LexedNode&gt; nodes = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> line = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; charStream.length; i++) &#123; <span class=\"comment\">// 使用 fori 是为了循环时移动指针</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> now = charStream[i];</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (now) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\n&#x27;</span>:</span><br><span class=\"line\">              nodes.add(<span class=\"keyword\">new</span> LexedNode(NodeType.LINE_SEPERATOR,<span class=\"string\">&quot;\\n&quot;</span>))</span><br><span class=\"line\">              <span class=\"keyword\">continue</span>; <span class=\"comment\">// 此处使用 continue 立即跳到下一次循环</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nodes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是你的第一个 Lexer，可以先输出一下看看结果：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">LINE_SEPERATOR</span></span><br></pre></td></tr></table></figure>\n\n<p>因为代码有五行，因此是五个 <code>LINE_SEPERATOR</code>。<br>只有换行符可不够，我们还要识别 <code>KEYWORD</code> ，也就是关键词。<br>然而关键词使用空格分割，因此我们可以这样做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(...)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27; &#x27;</span>:                </span><br><span class=\"line\">        inIdOrLiteral = !inIdOrLiteral;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inIdOrLiteral) &#123; <span class=\"comment\">// start collecting</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// end!</span></span><br><span class=\"line\">        String str = buffer.toString();</span><br><span class=\"line\">        identifierParse(str, nodes);</span><br><span class=\"line\">        buffer = <span class=\"keyword\">new</span> StringBuilder(); <span class=\"comment\">// compose</span></span><br><span class=\"line\">         <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 此处换行同理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Collect String or Identifier */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inIdOrLiteral) &#123;</span><br><span class=\"line\">        buffer.append(now);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以看到，我们引入了两个新的变量和一个方法，它们分别是 <code>inIdOrLiteral</code> 和 <code>buffer</code> 以及 <code>identifierParse</code>。</p>\n<p><strong>inIdOrLiteral</strong> 表示当前是否正在遍历一个 <code>Identifier</code> 或者一个字面量<br><strong>buffer</strong> 用于收集这个字面量，当然你也可以使用 <code>substring</code> 和 <code>charAt</code> 的方法<br><strong>identifierParse</strong> 是一个方法，他用于分类 Identifier。对于 <code>11</code>，他会分类成一个 <code>LITERAL_NUMBER</code>，对于 <code>not_a_keyword</code>，他会分类成一个 identifier，对于 <code>fn</code>，他会分类成一个 Keyword。</p>\n<p>还没完，天资聪颖的你肯定已经注意到了这里少了一样东西——我要怎么匹配最开头的一个 <code>using</code> ？ <code>using</code> 的前头可没有一个空格。<br>这时你可以回忆一下，在各种编程语言中作为 <code>Identifier</code> 的符号应该符合什么规则….是的，他们通常不会以运算符作为开头，以及他们不是一个关键字，因此我们还可以利用这个特性写出这样的代码:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         <span class=\"comment\">/* Other Symbols */</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (SYMBOL_OR_OPERATORS.contains(now）) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (inIdOrLiteral) &#123; <span class=\"comment\">// keyword</span></span><br><span class=\"line\">                 <span class=\"comment\">// now == a symbol,we should end this.</span></span><br><span class=\"line\">                 identifierParse(buffer.toString(), nodes);</span><br><span class=\"line\">                 buffer = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                 inIdOrLiteral = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (SYMBOLS.contains(now)) &#123;</span><br><span class=\"line\">                 nodes.add(<span class=\"keyword\">new</span> LexedNode(now, LexedNode.NodeType.SYMBOL));</span><br><span class=\"line\">                 <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (OPERATORS.contains(now)) &#123;</span><br><span class=\"line\">                 nodes.add(<span class=\"keyword\">new</span> LexedNode(now, LexedNode.NodeType.OPERATOR));</span><br><span class=\"line\">                 <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> LexerException(fileName+<span class=\"string\">&quot;: Unknown char: &quot;</span> + now+<span class=\"string\">&quot; line: &quot;</span>+line);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             inIdOrLiteral = <span class=\"keyword\">true</span>; <span class=\"comment\">// not symbol &amp; not identifier</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Collect String or Identifier */</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (inIdOrLiteral) &#123;</span><br><span class=\"line\">     buffer.append(now);</span><br><span class=\"line\">     <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一段代码将会在匹配第一个字符没有遇到语言规定的操作符或者特殊符号的时候把 <code>inIdOrLiteral</code> 设置为 <code>true</code>。配合上面的代码，在遇到一个空格的时候他会结束收集并且尝试判断是什么。</p>\n<p>实际上应该是 <code>switch</code> 的任务但是写成 <code>if</code> 更加直观一些。  </p>\n<p>那么到现在，我们可以开始尝试代码了！这是 Lexer 的输出：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEYWORD using</span><br><span class=\"line\">IDENTIFIER java</span><br><span class=\"line\">OPERATOR .</span><br><span class=\"line\">IDENTIFIER util</span><br><span class=\"line\">OPERATOR .</span><br><span class=\"line\">IDENTIFIER List</span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">KEYWORD fn</span><br><span class=\"line\">IDENTIFIER main</span><br><span class=\"line\">SYMBOL (</span><br><span class=\"line\">IDENTIFIER args</span><br><span class=\"line\">OPERATOR :</span><br><span class=\"line\">IDENTIFIER List&lt;String&gt;</span><br><span class=\"line\">SYMBOL )</span><br><span class=\"line\">SYMBOL &#123;</span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">KEYWORD println</span><br><span class=\"line\"><span class=\"deletion\">- LITERAL_STRING hello world!</span></span><br><span class=\"line\"><span class=\"addition\">+ IDENTIFIER &quot;hello</span></span><br><span class=\"line\"><span class=\"addition\">+ IDENTIFIER world!&quot;</span></span><br><span class=\"line\">LINE_SEPERATOR </span><br><span class=\"line\"></span><br><span class=\"line\">SYMBOL &#125;</span><br><span class=\"line\">5: RIGHT_BRACKET &#125;</span><br></pre></td></tr></table></figure>\n\n<p>相比你已经注意到了，理应出现的 <code>LITERAL_STRING</code> 被两个 IDENTIFIER 代替了，这显然不是我们想要的结果。因此，我们要给 String 加入特 殊 支 持  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(now)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&quot;&#x27;</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; charStream[i - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;\\\\&#x27;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// string starts or end</span></span><br><span class=\"line\">                        inIdOrLiteral = !inIdOrLiteral;</span><br><span class=\"line\">                        stringMode = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!inIdOrLiteral) &#123;</span><br><span class=\"line\">                            stringMode = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                            <span class=\"comment\">// a new string!</span></span><br><span class=\"line\">                            nodes.add(<span class=\"keyword\">new</span> LexedNode(buffer.toString(), LexedNode.NodeType.LITERAL_STRING));</span><br><span class=\"line\">                            buffer = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    case &#x27; &#x27;:</span><br><span class=\"line\"><span class=\"addition\">+        if (stringMode) &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+            break;</span></span><br><span class=\"line\"><span class=\"addition\">+        &#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">- if (SYMBOL_OR_OPERATORS.contains(now)) &#123;</span></span><br><span class=\"line\"><span class=\"addition\">+ if (SYMBOL_OR_OPERATORS.contains(now) &amp;&amp; !stringMode) &#123;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样我们就躲开了这个陷阱，完成了对于 String 的支持后，我们的 <code>fuzzyTokenize</code> 就做好了！</p>\n<blockquote>\n<p>关于 OPERATORS 和 SYMBOLS<br>一门语言里的符号很多，你绝对不会想把他们一个个 add 到 list 里面的，但你可以写一个 <a href=\"https://github.com/iceBear67/NullCatLang/blob/85a9b3234bcaab21451c0c6023f46d3599e5764d/src/main/java/io/ib67/lexer/Lexer.java#L11-L34\">loader</a> 来解决这个问题  </p>\n<p><img src=\"https://upload.cc/i1/2021/10/01/HwBhRN.png\"></p>\n</blockquote>\n<hr>\n<p>然后，是 <code>tokenizer</code>。<code>fuzzyTokenize</code> 输出的结果显然不足以交给 Parser 做解析，我们需要使i结果更加详细。</p>\n<p>好在经过 <code>fuzzyTokenize</code> 后代码已经被格式化成了比较模糊的 <code>Token Stream</code>，这一点使我们写第二次 tokenize 的时候会轻松很多，因为你不会再见到 <code>inIdOrLiteral</code> 和 <code>stringMode</code> 这种让人抓狂的东西了。</p>\n<p>首先，让我们从一个新的 Token 开始（你不会想和 LexedNode 混一块的）:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Token</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> line;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String content;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Type</span></span>&#123;</span><br><span class=\"line\">        IDENTIFIER(<span class=\"string\">&quot;&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        CLASS(<span class=\"string\">&quot;class&quot;</span>),FUNCTION(<span class=\"string\">&quot;fn&quot;</span>),ANNOTATION(<span class=\"string\">&quot;annotation&quot;</span>),FOR(<span class=\"string\">&quot;for&quot;</span>),WHILE(<span class=\"string\">&quot;while&quot;</span>),IF(<span class=\"string\">&quot;if&quot;</span>),USING(<span class=\"string\">&quot;using&quot;</span>)</span><br><span class=\"line\">        ,THIS(<span class=\"string\">&quot;this&quot;</span>),TRUE(<span class=\"string\">&quot;true&quot;</span>),FALSE(<span class=\"string\">&quot;false&quot;</span>),ELSE(<span class=\"string\">&quot;else&quot;</span>),VAR(<span class=\"string\">&quot;var&quot;</span>),NULL(<span class=\"string\">&quot;null&quot;</span>),PRINTLN(<span class=\"string\">&quot;println&quot;</span>), <span class=\"comment\">// KEYWORDS</span></span><br><span class=\"line\">        VAL(<span class=\"string\">&quot;val&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        LEFT_BRACE(<span class=\"string\">&quot;(&quot;</span>),RIGHT_BRACE(<span class=\"string\">&quot;)&quot;</span>),</span><br><span class=\"line\">        LEFT_BRACKET(<span class=\"string\">&quot;&#123;&quot;</span>),RIGHT_BRACKET(<span class=\"string\">&quot;&#125;&quot;</span>),</span><br><span class=\"line\">        LEFT_MID_BRACE(<span class=\"string\">&quot;[&quot;</span>),RIGHT_MID_BRACE(<span class=\"string\">&quot;]&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        COMMA(<span class=\"string\">&quot;,&quot;</span>),DOT(<span class=\"string\">&quot;.&quot;</span>),MINUS(<span class=\"string\">&quot;-&quot;</span>),PLUS(<span class=\"string\">&quot;+&quot;</span>),STAR(<span class=\"string\">&quot;*&quot;</span>),SLASH(<span class=\"string\">&quot;/&quot;</span>), <span class=\"comment\">// operators</span></span><br><span class=\"line\">        BREAK_LINE(<span class=\"string\">&quot;\\n&quot;</span>),ASSIGNMENT(<span class=\"string\">&quot;=&quot;</span>),EQUALS(<span class=\"string\">&quot;==&quot;</span>),SEMICOLON(<span class=\"string\">&quot;;&quot;</span>),AT(<span class=\"string\">&quot;@&quot;</span>),COLON(<span class=\"string\">&quot;:&quot;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        LITERAL_STRING(<span class=\"string\">&quot;&quot;</span>),LITERAL_NUMBER(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// literals</span></span><br><span class=\"line\">        <span class=\"meta\">@Getter</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String def;</span><br><span class=\"line\">        Type(String def)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.def=def;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>比上文的 LexedNode 详细了很多——比如他主动去分类 keyword 了。<br>接着是一个 fori ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Pair&lt;String,List&lt;Token&gt;&gt; tokenize() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lexedNodes = fuzzyTokenize();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tokens = <span class=\"keyword\">new</span> ArrayList&lt;Token&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> line = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lexedNodes.size(); i++) &#123;</span><br><span class=\"line\">        LexedNode lexedNode = lexedNodes.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (lexedNode.getType()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LINE_SEPERATOR:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.BREAK_LINE,<span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">                line++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SYMBOL:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> KEYWORD:</span><br><span class=\"line\">                <span class=\"keyword\">var</span> type = Arrays.stream(Token.Type.values()).filter(e -&gt; e.getDef().equals(lexedNode.getContent())).findFirst().orElseThrow(()-&gt;&#123;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NullPointerException(lexedNode.toString());</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, type, type.getDef()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LITERAL_STRING:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.LITERAL_STRING, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LITERAL_NUMBER:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.LITERAL_NUMBER, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OPERATOR:</span><br><span class=\"line\">                <span class=\"comment\">// =</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> isEnd = (i == lexedNodes.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (lexedNode.getContent()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;=&quot;</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (isEnd) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> LexerException(fileName+<span class=\"string\">&quot;: Invalid syntax line &quot;</span>+line);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (lexedNodes.get(i + <span class=\"number\">1</span>).getType() == LexedNode.NodeType.OPERATOR &amp;&amp; lexedNodes.get(i + <span class=\"number\">1</span>).getContent().equals(<span class=\"string\">&quot;=&quot;</span>)) &#123; <span class=\"comment\">// ==</span></span><br><span class=\"line\">                            tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.EQUALS, <span class=\"string\">&quot;==&quot;</span>));</span><br><span class=\"line\">                            i = i + <span class=\"number\">1</span>; <span class=\"comment\">// skip next</span></span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.ASSIGNMENT, <span class=\"string\">&quot;=&quot;</span>));</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;.&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.DOT, <span class=\"string\">&quot;.&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;,&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.COMMA, <span class=\"string\">&quot;,&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.MINUS, <span class=\"string\">&quot;-&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.PLUS, <span class=\"string\">&quot;+&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.STAR,<span class=\"string\">&quot;*&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.SLASH,<span class=\"string\">&quot;/&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;;&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.SEMICOLON,<span class=\"string\">&quot;;&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> <span class=\"string\">&quot;:&quot;</span>:</span><br><span class=\"line\">                        tokens.add(<span class=\"keyword\">new</span> Token(line,Token.Type.COLON,<span class=\"string\">&quot;:&quot;</span>));</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IDENTIFIER:</span><br><span class=\"line\">                tokens.add(<span class=\"keyword\">new</span> Token(line, Token.Type.IDENTIFIER, lexedNode.getContent()));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pair.of(fileName,tokens);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码并不难懂。在这个例子中，我们遍历来自 fuzzyTokenizer 的数据并且通过 switch 分类枚举来处理把他们转化成 <code>Token</code> 来表达并且存储到 <code>tokens</code>。对于 symbol 和 keyword，我们通过直接搜索 enum 内值的方法避免写出了像 <code>case OPERATOR</code> 里更糟糕的代码。  </p>\n<p><code>case OPERATOR</code> 里写成这样是为了双符号操作的支持，例如 <code>==</code></p>\n<p>回到原题，这次我们可以通过 tokenize 解析出这样的结果：</p>\n<figure class=\"highlight ldif\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">1</span>: USING using</span><br><span class=\"line\"><span class=\"attribute\">1</span>: IDENTIFIER java</span><br><span class=\"line\"><span class=\"attribute\">1</span>: DOT .</span><br><span class=\"line\"><span class=\"attribute\">1</span>: IDENTIFIER util</span><br><span class=\"line\"><span class=\"attribute\">1</span>: DOT .</span><br><span class=\"line\"><span class=\"attribute\">1</span>: IDENTIFIER List</span><br><span class=\"line\"><span class=\"attribute\">1</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">2</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">3</span>: FUNCTION fn</span><br><span class=\"line\"><span class=\"attribute\">3</span>: IDENTIFIER main</span><br><span class=\"line\"><span class=\"attribute\">3</span>: LEFT_BRACE (</span><br><span class=\"line\"><span class=\"attribute\">3</span>: IDENTIFIER args</span><br><span class=\"line\"><span class=\"attribute\">3</span>: COLON :</span><br><span class=\"line\"><span class=\"attribute\">3</span>: IDENTIFIER List&lt;String&gt;</span><br><span class=\"line\"><span class=\"attribute\">3</span>: RIGHT_BRACE )</span><br><span class=\"line\"><span class=\"attribute\">3</span>: LEFT_BRACKET &#123;</span><br><span class=\"line\"><span class=\"attribute\">3</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">4</span>: PRINTLN println</span><br><span class=\"line\"><span class=\"attribute\">4</span>: LITERAL_STRING hello world!</span><br><span class=\"line\"><span class=\"attribute\">4</span>: BREAK_LINE </span><br><span class=\"line\"><span class=\"attribute\">5</span>: RIGHT_BRACKET &#125;</span><br><span class=\"line\"><span class=\"attribute\">5</span>: RIGHT_BRACKET &#125;</span><br></pre></td></tr></table></figure>\n<p>是不是详细了很多？接着我们就可以靠着这个写一个 Parser了</p>\n<h2 id=\"在-Parse-之前\"><a href=\"#在-Parse-之前\" class=\"headerlink\" title=\"在 Parse 之前\"></a>在 Parse 之前</h2><p>在 Parse 之前，我们需要先做一次 Static Analyzing。在这个阶段，Parser 会对文件里的类型和导入表作出关联，同时也是多文件编译的基础。</p>\n<h3 id=\"Metadata\"><a href=\"#Metadata\" class=\"headerlink\" title=\"Metadata\"></a>Metadata</h3><p>你不可能靠着所有人的源码来建立索引，而且源码中的无用信息太多了。<br>实际上，确定符号链接只需要这些信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CatMetadata</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassDef classDefinition = <span class=\"keyword\">new</span> ClassDef();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String,CatMetadata&gt; cachedUsings = <span class=\"keyword\">new</span> HashMap&lt;&gt;(); <span class=\"comment\">// 这是对于被解析对象才有的</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt; MethodSign&gt; methods = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, VariableDef&gt; fields = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关于 <code>ClassDef</code>, <code>MethodSign</code>, <code>VariableDef</code> 等信息本文不贴出，因为并不会影响观看体验。<br>如果有兴趣，可以在<a href=\"https://github.com/iceBear67/NullCatLang/tree/master/src/main/java/io/ib67/ast/decl\">这里</a>找到他们相对应的具体代码  </p>\n</blockquote>\n<p>以及一个编译器全局索引，用 FQDN 确定唯一性的 Map:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Global</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String,CatMetadata&gt; GLOBAL_METADATAS = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> CatMetadata <span class=\"title\">forClass</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          * Scan compiler classPaths</span></span><br><span class=\"line\"><span class=\"comment\">          */</span></span><br><span class=\"line\">         <span class=\"keyword\">var</span> meta = NullCatCompiler.solveMeta(str);</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(meta!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             GLOBAL_METADATAS.put(str, meta);</span><br><span class=\"line\">         &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">             meta = NullCatCompiler.solveMeta(<span class=\"string\">&quot;java.lang.&quot;</span> + str);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> meta;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>准备就绪，我们来单独拿出一个类作为 <code>MetadataGenerator</code> 状态机  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequiredArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MetadataGenerator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String fileName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Token&gt; tokens;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> CatMetadata cm = <span class=\"keyword\">new</span> CatMetadata();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着，是提取数据的部分:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CatMetadata <span class=\"title\">gen</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tokens.size(); i++) &#123;</span><br><span class=\"line\">        Token now = tokens.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> end = (i==tokens.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">        Token next = end?<span class=\"keyword\">null</span>:tokens.get(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(now.getType())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> USING:</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!end)&#123;</span><br><span class=\"line\">                    i=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> clazz = readAsStringUntilLB();</span><br><span class=\"line\">                    cm.getCachedUsings().put(clazz, Optional.ofNullable(CatMetadata.Global.forClass(clazz)).orElseThrow(()-&gt;<span class=\"keyword\">new</span> ParseException(<span class=\"string\">&quot;Can&#x27;t find clazz &quot;</span>+clazz)));</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    throwEOF();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> FUNCTION:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (end) &#123;</span><br><span class=\"line\">                    throwEOF();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// fn main()&#123;&#125;</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(next.getType() != Token.Type.IDENTIFIER)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ParseException(fileName+<span class=\"string\">&quot;: Unexcepted &quot;</span>+next.getType()+<span class=\"string\">&quot; at line &quot;</span>+now.getLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                String methodName = next.getContent();</span><br><span class=\"line\">                i=i+<span class=\"number\">1</span>; <span class=\"comment\">// Move Pointer to (</span></span><br><span class=\"line\">                MethodSign sign = readMethodSign(methodName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode()))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ParseException(fileName+<span class=\"string\">&quot;: Duplicated method: &quot;</span>+sign+<span class=\"string\">&quot; at line &quot;</span>+now.getLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cm.getMethods().add(sign);</span><br><span class=\"line\">                skipCodeBlocks();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cm;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在这个循环当中，我们通过获取到 Token 的类型来判定需要做的操作，这是基于语言设计定义来做的—— 例如 <code>fn</code> 的后面必然是一个方法签名，而不可以是别的。最终 <code>MetadataGenerator</code> 将会返回一个 CatMetadata 以供后续操作。</p>\n<p>因此，这一阶段我们也可以发掘出类型错误和大的语法错误。</p>\n<h3 id=\"与-Java-的世界\"><a href=\"#与-Java-的世界\" class=\"headerlink\" title=\"与 Java 的世界\"></a>与 Java 的世界</h3><p>我们需要和 Java 交互，因此我们需要给 <code>Class</code> 建立 <code>CatMetadata</code> 。好在这很简单，因为 CatMetadata 需要的所有数据都可以通过反射获取，这里提供一段参考代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassMetaPathImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">MetaPath</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassLoader classLoader;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CatMetadata <span class=\"title\">findClass</span><span class=\"params\">(String clazz)</span> </span>&#123;</span><br><span class=\"line\">        CatMetadata cm = <span class=\"keyword\">new</span> CatMetadata();</span><br><span class=\"line\">        Class&lt;?&gt; claz = Util.runCatching(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Class.forName(clazz,<span class=\"keyword\">false</span>,classLoader);</span><br><span class=\"line\">        &#125;).getResult();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(claz==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Field declaredField : claz.getDeclaredFields()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Modifier.isPublic(declaredField.getModifiers())) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            VariableDef def = <span class=\"keyword\">new</span> VariableDef(declaredField.getType().getCanonicalName(),declaredField.getName());</span><br><span class=\"line\">            cm.getFields().put(declaredField.getName(),def);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Method declaredMethod: claz.getDeclaredMethods())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Modifier.isPublic(declaredMethod.getModifiers()))<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            MethodSign sign = <span class=\"keyword\">new</span> MethodSign(declaredMethod.getName(), (ArrayList&lt;String&gt;) Arrays.stream(declaredMethod.getParameterTypes()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList()));</span><br><span class=\"line\">            cm.getMethods().add(sign);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ClassDef cdf = <span class=\"keyword\">new</span> ClassDef();</span><br><span class=\"line\">        cdf.setClassName(clazz);</span><br><span class=\"line\">        cdf.setSuperclass(claz.getSuperclass()==<span class=\"keyword\">null</span>?<span class=\"keyword\">null</span>:claz.getSuperclass().getCanonicalName());</span><br><span class=\"line\">        cdf.setInterfaces(Arrays.stream(claz.getInterfaces()).map(e-&gt;e.getCanonicalName()).collect(Collectors.toList()));</span><br><span class=\"line\">        cm.setClassDefinition(cdf);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>静态分析结束后，我们就要准备开始生成 AST 了。</p>\n<blockquote>\n<p>附<br>我们从 token 流中获取数据，并且根据类型进行匹配——但我们其实没有用到状态<br>仔细看，你会发现这个东西：</p>\n<figure class=\"highlight patch\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        i=i+1; // Move Pointer to (</span><br><span class=\"line\"><span class=\"addition\">+        MethodSign sign = readMethodSign(methodName);</span></span><br><span class=\"line\">        if(cm.getMethods().stream().anyMatch(e-&gt;e.hashCode()==sign.hashCode()))&#123;</span><br><span class=\"line\">            throw new ParseException(fileName+&quot;: Duplicated method: &quot;+sign+&quot; at line &quot;+now.getLine());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cm.getMethods().add(sign);</span><br><span class=\"line\"><span class=\"addition\">+        skipCodeBlocks();</span></span><br><span class=\"line\">        continue;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>是不是有些象是 DSL？<br>这其实归咎于类字段中那个不起眼的 <code>int i = 0</code>，它使得 for 循环的指针可以被整个类里的方法所共享。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String <span class=\"title\">readAsStringUntilLB</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 一只读，读到一个换行为止并且收集成字符串</span></span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> a = i; tokens.get(a).getType()!= Token.Type.BREAK_LINE;a++)&#123;</span><br><span class=\"line\">        sb.append(tokens.get(a).getContent());</span><br><span class=\"line\">        b=a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在经过更加详细的 tokenize 之后，代码实际上变得更加可观了，</p>\n</blockquote>\n<h2 id=\"Parser-1\"><a href=\"#Parser-1\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p>先占个坑位～</p>\n",
            "tags": [
                "tech"
            ]
        }
    ]
}