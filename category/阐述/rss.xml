<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>nstd::out • Posts by &#34;阐述&#34; category</title>
        <link>https://ib67.io</link>
        <description>iceBear 的博客</description>
        <language>zh-CN</language>
        <pubDate>Fri, 05 Nov 2021 23:20:16 +0800</pubDate>
        <lastBuildDate>Fri, 05 Nov 2021 23:20:16 +0800</lastBuildDate>
        <category>编译器</category>
        <category>技术</category>
        <category>Java</category>
        <category>日常</category>
        <category>回忆</category>
        <category>Linux</category>
        <category>总结</category>
        <item>
            <guid isPermalink="true">https://ib67.io/2021/11/05/How-Does-Java-Tag-Garbages/</guid>
            <title>浅谈 Java 虚拟机是如何标识垃圾的</title>
            <link>https://ib67.io/2021/11/05/How-Does-Java-Tag-Garbages/</link>
            <category>技术</category>
            <pubDate>Fri, 05 Nov 2021 23:20:16 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;Java 作为一门 VM 语言，它的垃圾回收机制确实帮我们省了很多事情，我们不再需要去”手动管理内存的分配和释放”，只需要交给 VM 来做就好了。  &lt;/p&gt;
&lt;p&gt;然而，真的是这样吗？即使有&lt;a href=&#34;https://malloc.se/blog/zgc-jdk16&#34;&gt;神一般高性能的垃圾回收器&lt;/a&gt;，我们写代码时仍然需要注意它是&lt;em&gt;如何标记垃圾对象&lt;/em&gt;的，因为垃圾回收器并不是万能的，仍然有一些工作需要程序员自己完成。  &lt;/p&gt;
&lt;p&gt;本文试图通俗易懂的讲解 JVM 上标记垃圾的方法，如有错误请在评论区指正。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;h1 id=&#34;两种标记垃圾的方式&#34;&gt;&lt;a href=&#34;#两种标记垃圾的方式&#34; class=&#34;headerlink&#34; title=&#34;两种标记垃圾的方式&#34;&gt;&lt;/a&gt;两种标记垃圾的方式&lt;/h1&gt;&lt;p&gt;或许你曾听闻过 &lt;code&gt;引用计数法&lt;/code&gt;，也就是 &lt;code&gt;一个对象被引用时计数器 + 1 ，解除引用时计数器 - 1，当计数器为 0 时将会被 GC&lt;/code&gt;，看起来非常可行。  &lt;/p&gt;
&lt;p&gt;但是这种方法没有被 Java 采用，因为他有两个显而易见的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环引用问题 如果一个对象内部引用了另一个 引用这个对象的 对象，那么计数器将永远不会为 0&lt;/li&gt;
&lt;li&gt;计数器的维护问题 引用计数器的值会以极快的速度更新，更新任务变得繁重 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或许因此，Java 采用了 &lt;code&gt;可达性分析&lt;/code&gt; 的方法对垃圾进行标记。&lt;/p&gt;
&lt;h1 id=&#34;可达性分析&#34;&gt;&lt;a href=&#34;#可达性分析&#34; class=&#34;headerlink&#34; title=&#34;可达性分析&#34;&gt;&lt;/a&gt;可达性分析&lt;/h1&gt;&lt;p&gt;可达性分析的思路很简单。&lt;/p&gt;
&lt;p&gt;他从一组叫 &lt;code&gt;GC Root&lt;/code&gt; 的引用出发，递归搜索出所有能被到达的节点作为&lt;strong&gt;存活&lt;/strong&gt;的对象，而此外那些没有被搜索到的对象就会被标记 &lt;strong&gt;将被清理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.cc/i1/2021/11/05/cvqtiw.png&#34;&gt;  &lt;/p&gt;
&lt;p&gt;途中，被蓝色尖头指向的对象将不会被清除，因为他们间接或者直接的被 &lt;code&gt;GC Root&lt;/code&gt; 引用。而旁边没有被 &lt;code&gt;GC Root&lt;/code&gt; 引用的两个对象将会被清除，无论他们之间有什么关系。&lt;/p&gt;
&lt;p&gt;不久，因为 &lt;code&gt;Garbage F&lt;/code&gt; 和他的朋友 &lt;code&gt;Garbage E&lt;/code&gt; 没有来自 &lt;code&gt;GC Root&lt;/code&gt; 的直接/间接引用，他们就会被 gc 回收掉了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;想想看，如果在这个图中 &lt;code&gt;Object C&lt;/code&gt; 建立了到 &lt;code&gt;Garbage F&lt;/code&gt; 的一个引用，会发生什么？  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;引用&#34;&gt;&lt;a href=&#34;#引用&#34; class=&#34;headerlink&#34; title=&#34;引用&#34;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;p&gt;在聊 &lt;code&gt;GC Root&lt;/code&gt; 是什么之前，你可能需要知道引用是什么。  &lt;/p&gt;
&lt;p&gt;举个例子:  &lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;Object a = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; Object();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; b = a;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; c = b;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;assert&lt;/span&gt; a == c;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以上代码运行不会报错，因为他们是在内存中是同一个对象。这是如何做到的呢？ JVM 并没有把这个对象拷贝很多次，因为他赋值并不是赋一个对象，而是引用。  &lt;/p&gt;
&lt;p&gt;这是因为对象是分配在堆里的，&lt;code&gt;new Object()&lt;/code&gt; 返回的实际上是一个&lt;code&gt;引用&lt;/code&gt;。引用就是指向对象的钥匙。  &lt;/p&gt;
&lt;p&gt;打个比方说， &lt;code&gt;网盘链接&lt;/code&gt; 可以指向一个资源，你把链接给了别人并不是直接把资源发送给了别人，只是给了一个指向资源的钥匙，它可以通过这个钥匙获取到资源。  &lt;/p&gt;
&lt;p&gt;再来看一个例子  &lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;List&amp;lt;Object&amp;gt; someObject = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;someObject.add(objectA);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;someObject.add(objectB);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;显然，以上的代码将两个对象塞到了一个容器里，看起来是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.cc/i1/2021/11/05/7QuXlj.png&#34;&gt;   &lt;/p&gt;
&lt;p&gt;当然，不只是塞到容器才有引用&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    A anotherA;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;A a = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;A b = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;a.anotherA = b;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.cc/i1/2021/11/06/0Dv9Rg.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外，Java 还有多种引用类型来帮助你实现更加灵活的对象生命周期管理。本文主要讨论的是强引用的情况，并不考虑弱引用类型，有兴趣的读者可以自行了解( WeakReference , PhantomReference , SoftReference )。&lt;/p&gt;
&lt;p&gt;如果你无法理解引用也没有问题，只需要理解成一个对象存了另一个对象之间建立的关系就好了。  &lt;/p&gt;
&lt;h2 id=&#34;GC-Root&#34;&gt;&lt;a href=&#34;#GC-Root&#34; class=&#34;headerlink&#34; title=&#34;GC Root&#34;&gt;&lt;/a&gt;GC Root&lt;/h2&gt;&lt;p&gt;GC Root 是垃圾收集器进行分析的起点，不会被回收，而且类型有很多种&lt;del&gt;但是基本上不用特地记&lt;/del&gt;，主要就注意这几个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;局部变量，参数之类的 就是指方法里面声明的那些变量，不过出了方法就没了&lt;/li&gt;
&lt;li&gt;类静态字段或常量 比如 &lt;code&gt;private static final XX xx = new XX()&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;虚拟机内部引用&lt;/li&gt;
&lt;li&gt;被同步锁持有的对象&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;来个例子&#34;&gt;&lt;a href=&#34;#来个例子&#34; class=&#34;headerlink&#34; title=&#34;来个例子&#34;&gt;&lt;/a&gt;来个例子&lt;/h1&gt;&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; List&amp;lt;OOMObject&amp;gt; oomObjects = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt;&lt;span class=&#34;number&#34;&gt;114514&lt;/span&gt; ; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    oomObjects.add(&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; OOMObject());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;试图说明程序内存溢出的原因。&lt;/p&gt;
&lt;h1 id=&#34;End&#34;&gt;&lt;a href=&#34;#End&#34; class=&#34;headerlink&#34; title=&#34;End&#34;&gt;&lt;/a&gt;End&lt;/h1&gt;&lt;p&gt;总之，写代码的时候要注意一些潜在的，未消除的引用，虽然一般碰不到。&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
