{
    "version": "https://jsonfeed.org/version/1",
    "title": "nstd::out • All posts by \"阐述\" category",
    "description": "iceBear 的博客",
    "home_page_url": "https://ib67.io",
    "items": [
        {
            "id": "https://ib67.io/2021/11/05/How-Does-Java-Tag-Garbages/",
            "url": "https://ib67.io/2021/11/05/How-Does-Java-Tag-Garbages/",
            "title": "浅谈 Java 虚拟机是如何标识垃圾的",
            "date_published": "2021-11-05T15:20:16.000Z",
            "content_html": "<p>Java 作为一门 VM 语言，它的垃圾回收机制确实帮我们省了很多事情，我们不再需要去”手动管理内存的分配和释放”，只需要交给 VM 来做就好了。  </p>\n<p>然而，真的是这样吗？即使有<a href=\"https://malloc.se/blog/zgc-jdk16\">神一般高性能的垃圾回收器</a>，我们写代码时仍然需要注意它是<em>如何标记垃圾对象</em>的，因为垃圾回收器并不是万能的，仍然有一些工作需要程序员自己完成。  </p>\n<p>本文试图通俗易懂的讲解 JVM 上标记垃圾的方法，如有错误请在评论区指正。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"两种标记垃圾的方式\"><a href=\"#两种标记垃圾的方式\" class=\"headerlink\" title=\"两种标记垃圾的方式\"></a>两种标记垃圾的方式</h1><p>或许你曾听闻过 <code>引用计数法</code>，也就是 <code>一个对象被引用时计数器 + 1 ，解除引用时计数器 - 1，当计数器为 0 时将会被 GC</code>，看起来非常可行。  </p>\n<p>但是这种方法没有被 Java 采用，因为他有两个显而易见的问题：</p>\n<ul>\n<li>循环引用问题 如果一个对象内部引用了另一个 引用这个对象的 对象，那么计数器将永远不会为 0</li>\n<li>计数器的维护问题 引用计数器的值会以极快的速度更新，更新任务变得繁重 </li>\n</ul>\n<p>或许因此，Java 采用了 <code>可达性分析</code> 的方法对垃圾进行标记。</p>\n<h1 id=\"可达性分析\"><a href=\"#可达性分析\" class=\"headerlink\" title=\"可达性分析\"></a>可达性分析</h1><p>可达性分析的思路很简单。</p>\n<p>他从一组叫 <code>GC Root</code> 的引用出发，递归搜索出所有能被到达的节点作为<strong>存活</strong>的对象，而此外那些没有被搜索到的对象就会被标记 <strong>将被清理</strong>。</p>\n<p><img src=\"https://i.ibb.co/dGZrFXj/image.png\">  </p>\n<p>途中，被蓝色尖头指向的对象将不会被清除，因为他们间接或者直接的被 <code>GC Root</code> 引用。而旁边没有被 <code>GC Root</code> 引用的两个对象将会被清除，无论他们之间有什么关系。</p>\n<p>不久，因为 <code>Garbage F</code> 和他的朋友 <code>Garbage E</code> 没有来自 <code>GC Root</code> 的直接/间接引用，他们就会被 gc 回收掉了。</p>\n<blockquote>\n<p>想想看，如果在这个图中 <code>Object C</code> 建立了到 <code>Garbage F</code> 的一个引用，会发生什么？  </p>\n</blockquote>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>在聊 <code>GC Root</code> 是什么之前，你可能需要知道引用是什么。  </p>\n<p>举个例子:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"type\">var</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> a;</span><br><span class=\"line\"><span class=\"type\">var</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> b;</span><br><span class=\"line\"><span class=\"keyword\">assert</span> a == c;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码运行不会报错，因为他们是在内存中是同一个对象。这是如何做到的呢？ JVM 并没有把这个对象拷贝很多次，因为他赋值并不是赋一个对象，而是引用。  </p>\n<p>这是因为对象是分配在堆里的，<code>new Object()</code> 返回的实际上是一个<code>引用</code>。引用就是指向对象的钥匙。  </p>\n<p>打个比方说， <code>网盘链接</code> 可以指向一个资源，你把链接给了别人并不是直接把资源发送给了别人，只是给了一个指向资源的钥匙，它可以通过这个钥匙获取到资源。  </p>\n<p>再来看一个例子  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt; someObject = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">someObject.add(objectA);</span><br><span class=\"line\">someObject.add(objectB);</span><br></pre></td></tr></table></figure>\n\n<p>显然，以上的代码将两个对象塞到了一个容器里，看起来是这样的：</p>\n<p><img src=\"https://i.ibb.co/zs5rDPn/image.png\">   </p>\n<p>当然，不只是塞到容器才有引用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">    A anotherA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">A</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\"><span class=\"type\">A</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">a.anotherA = b;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.ibb.co/6PLKg54/image.png\"></p>\n<p>另外，Java 还有多种引用类型来帮助你实现更加灵活的对象生命周期管理。本文主要讨论的是强引用的情况，并不考虑弱引用类型，有兴趣的读者可以自行了解( WeakReference , PhantomReference , SoftReference )。</p>\n<p>如果你无法理解引用也没有问题，只需要理解成一个对象存了另一个对象之间建立的关系就好了。  </p>\n<h2 id=\"GC-Root\"><a href=\"#GC-Root\" class=\"headerlink\" title=\"GC Root\"></a>GC Root</h2><p>GC Root 是垃圾收集器进行分析的起点，不会被回收，而且类型有很多种<del>但是基本上不用特地记</del>，主要就注意这几个。</p>\n<ol>\n<li>局部变量，参数之类的 就是指方法里面声明的那些变量，不过出了方法就没了</li>\n<li>类静态字段或常量 比如 <code>private static final XX xx = new XX()</code> </li>\n<li>虚拟机内部引用</li>\n<li>被同步锁持有的对象</li>\n</ol>\n<h1 id=\"来个例子\"><a href=\"#来个例子\" class=\"headerlink\" title=\"来个例子\"></a>来个例子</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;OOMObject&gt; oomObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;<span class=\"number\">114514</span> ; i++) &#123;</span><br><span class=\"line\">    oomObjects.add(<span class=\"keyword\">new</span> <span class=\"title class_\">OOMObject</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>试图说明程序内存溢出的原因。</p>\n<h1 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h1><p>总之，写代码的时候要注意一些潜在的，未消除的引用，虽然一般碰不到。</p>\n",
            "tags": [
                "tech"
            ]
        }
    ]
}